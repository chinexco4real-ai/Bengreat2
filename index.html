<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Deriv Digit Over 5 Pro - Advanced ML Edition v4 (PSF + LSTM Enhanced)</title>
<style>
/* --- STYLES PRESERVED --- */
body { background: #020617; color: #e5e7eb; font-family: system-ui, -apple-system, sans-serif; margin: 0; padding: 0; }
.app { max-width: 420px; margin: auto; padding: 15px; }
.card { background: #0f172a; padding: 12px; border-radius: 12px; margin-bottom: 12px; border: 1px solid #1e293b; }
h2, h3 { text-align: center; margin-bottom: 8px; margin-top: 8px; }
h2 { color: #22c55e; }
label { font-size: 13px; opacity: 0.8; display: block; margin-top: 8px; }
input, select, button { width: 100%; padding: 10px; margin: 5px 0 10px; border-radius: 8px; border: none; box-sizing: border-box; }
input, select { background: #1e293b; color: #e5e7eb; border: 1px solid #334155; }
input:focus, select:focus { outline: none; border-color: #22c55e; }
button { background: #22c55e; color: #020617; font-weight: 700; cursor: pointer; transition: all 0.2s; }
button:hover { background: #16a34a; transform: translateY(-1px); }
button:active { transform: translateY(0); }
button:disabled { background: #374151; cursor: not-allowed; opacity: 0.5; }
.buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 12px; }
.status-container { display: flex; gap: 5px; margin-bottom: 10px; }
.status { flex: 2; text-align: center; padding: 8px; border-radius: 8px; font-weight: 600; }
.account-type { flex: 1.5; text-align: center; padding: 8px; border-radius: 8px; font-weight: 700; font-size: 11px; display: none; text-transform: uppercase; align-self: center; }
.demo-badge { background: #f59e0b; color: #020617; }
.live-badge { background: #22c55e; color: #020617; }
.connected { background: #16a34a; color: white; }
.disconnected { background: #dc2626; color: white; }
.stats { display: grid; grid-template-columns: repeat(4, 1fr); text-align: center; gap: 10px; }
.stats > div { display: flex; flex-direction: column; gap: 5px; }
.stats span { font-size: 12px; opacity: 0.7; }
.stats b { font-size: 16px; color: #22c55e; }
.table-container { overflow-x: auto; max-height: 300px; overflow-y: auto; }
table { width: 100%; font-size: 13px; border-collapse: collapse; }
thead { position: sticky; top: 0; background: #1e293b; }
th { padding: 8px; text-align: left; font-weight: 600; border-bottom: 2px solid #334155; }
td { padding: 8px; border-bottom: 1px solid #1e293b; }
tbody tr:hover { background: #1e293b; }
.win { color: #22c55e; }
.loss { color: #ef4444; }
.balance-display { text-align: center; padding: 10px; background: #0f172a; border-radius: 8px; margin-bottom: 10px; border: 1px solid #1e293b; }
.balance-display span { opacity: 0.7; font-size: 14px; }
.balance-display b { color: #22c55e; font-size: 18px; margin: 0 5px; }
.session-timer { margin-top: 8px; font-size: 12px; color: #f59e0b; font-weight: 600; }
.shutdown-timer { font-size: 12px; color: #ef4444; font-weight: 700; margin-top: 4px; display: none; }
.reset-button-permanent { background: #f59e0b !important; width: 100%; margin-bottom: 12px; font-size: 15px; display: block; }
.reset-button-permanent:hover { background: #d97706 !important; }
.analyzer-grid { display: grid; grid-template-columns: repeat(10, 1fr); gap: 5px; margin: 10px 0; }
.digit-box { aspect-ratio: 1; display: flex; align-items: center; justify-content: center; border-radius: 6px; font-weight: 700; font-size: 14px; border: 2px solid transparent; }
.digit-over { background: #22c55e; color: #020617; }
.digit-under { background: #ef4444; color: white; }
.analyzer-stats { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; text-align: center; margin-top: 10px; }
.analyzer-stats > div { background: #1e293b; padding: 8px; border-radius: 6px; }
.analyzer-stats span { font-size: 11px; opacity: 0.7; display: block; }
.analyzer-stats b { font-size: 18px; display: block; margin-top: 3px; }
.log-container { background: #020617; border: 1px solid #1e293b; border-radius: 6px; height: 120px; overflow-y: auto; padding: 8px; font-family: 'Courier New', monospace; font-size: 11px; margin-top: 10px; }
.log-entry { margin-bottom: 4px; border-bottom: 1px solid #1e293b; padding-bottom: 2px; }
.log-time { color: #94a3b8; margin-right: 5px; }
.log-msg-info { color: #3b82f6; }
.log-msg-success { color: #22c55e; }
.log-msg-error { color: #ef4444; }
.log-msg-warn { color: #f59e0b; }
.btn-cycle { background: #3b82f6; color: white; margin-bottom: 5px; font-size: 14px; }
.btn-cycle.active { background: #8b5cf6; border: 2px solid #fff; }
.btn-cooldown { background: #475569; color: white; margin-bottom: 5px; font-size: 14px; }
.btn-cooldown.active { background: #f59e0b; color: #020617; border: 2px solid #020617; }
.btn-reverse { background: #334155; color: white; margin-bottom: 12px; font-size: 14px; }
.btn-reverse.active { background: #f43f5e; }
.cycle-timer-display { color: #f59e0b; font-size: 13px; font-weight: bold; text-align: center; margin-bottom: 10px; display: none; padding: 8px; border: 2px dashed #f59e0b; border-radius: 8px; background: rgba(245, 158, 11, 0.1); }
.specific-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; margin-bottom: 10px; }
.specific-grid input { text-align: center; padding: 8px 0; margin: 0; }
.window-timer { margin-top: 10px; font-size: 12px; text-align: center; font-weight: 800; padding: 8px; border-radius: 6px; background: #020617; border: 2px solid #334155; transition: all 0.3s; }

/* Sequence UI Styles */
.sequence-slot { background: #1e293b; border: 1px solid #334155; border-radius: 8px; padding: 10px; margin-bottom: 10px; }
.sequence-slot-title { font-size: 11px; font-weight: 700; color: #3b82f6; margin-bottom: 5px; text-transform: uppercase; }
.seq-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px; }
.seq-grid input { font-size: 11px; padding: 5px; margin: 0; }

/* ML Enhancement Styles */
.ml-indicator { display: inline-block; padding: 3px 8px; border-radius: 4px; font-size: 10px; font-weight: 700; margin-left: 5px; }
.ml-learning { background: #8b5cf6; color: white; }
.ml-active { background: #22c55e; color: #020617; }
.advanced-stats { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-top: 8px; font-size: 10px; }
.advanced-stats > div { background: #020617; padding: 5px; border-radius: 4px; text-align: center; }

/* Radio Button Styles */
.radio-group { margin: 10px 0; }
.radio-option { display: flex; align-items: center; padding: 8px; margin: 5px 0; background: #1e293b; border-radius: 6px; cursor: pointer; border: 2px solid #334155; transition: all 0.2s; }
.radio-option:hover { border-color: #22c55e; background: #1e3a2b; }
.radio-option input[type="radio"] { margin-right: 10px; cursor: pointer; width: auto; }
.radio-option.selected { border-color: #22c55e; background: #1e3a2b; }
.radio-option label { cursor: pointer; margin: 0; opacity: 1; font-size: 13px; font-weight: 600; width: 100%; }

/* Pattern Mode UI */
.pattern-target-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; margin-top: 10px; }
.pattern-target-grid input { text-align: center; padding: 8px; margin: 0; background: #0f172a; border: 2px solid #8b5cf6; }
.pattern-mode-active { background: #8b5cf6; padding: 8px; border-radius: 6px; text-align: center; margin: 10px 0; font-weight: 700; color: white; }
.ensemble-filter-box { background: #0f172a; border: 2px solid #f59e0b; border-radius: 6px; padding: 10px; margin-top: 10px; }
.ensemble-filter-box label { color: #f59e0b; font-weight: 700; font-size: 12px; }
.ensemble-status { text-align: center; font-size: 11px; margin-top: 5px; padding: 5px; border-radius: 4px; background: #1e293b; }
.ensemble-filter-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 8px; }
.filter-warning { background: #ef4444; color: white; padding: 6px; border-radius: 4px; text-align: center; font-size: 10px; font-weight: 700; margin-top: 5px; display: none; }

/* Toggle Switch Styles */
.toggle-container { display: flex; align-items: center; justify-content: space-between; padding: 10px; background: #1e293b; border-radius: 6px; margin: 10px 0; border: 2px solid #334155; }
.toggle-label { font-size: 13px; font-weight: 700; color: #e5e7eb; }
.toggle-switch { position: relative; width: 50px; height: 26px; }
.toggle-switch input { opacity: 0; width: 0; height: 0; }
.toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #334155; border-radius: 34px; transition: .4s; }
.toggle-slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 4px; bottom: 4px; background-color: white; border-radius: 50%; transition: .4s; }
.toggle-switch input:checked + .toggle-slider { background-color: #22c55e; }
.toggle-switch input:checked + .toggle-slider:before { transform: translateX(24px); }

/* Specific Ensemble Percentages */
.specific-ensemble-section { background: #0f172a; border: 2px solid #8b5cf6; border-radius: 6px; padding: 10px; margin-top: 10px; display: none; }
.specific-ensemble-section.active { display: block; }
.specific-ensemble-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; margin-top: 8px; }
.specific-ensemble-grid input { text-align: center; padding: 8px; margin: 0; background: #1e293b; border: 2px solid #8b5cf6; }

/* Model Performance Indicators */
.model-performance { display: grid; grid-template-columns: 1fr 1fr 1fr 1fr 1fr; gap: 5px; margin-top: 8px; font-size: 10px; }
.model-performance > div { background: #1e293b; padding: 5px; border-radius: 4px; text-align: center; border: 1px solid #334155; }
.model-perf-high { border-color: #22c55e; }
.model-perf-low { border-color: #ef4444; }

/* Virtual Trade Styles */
.virtual-trade-container { background: #1e293b; border: 2px solid #8b5cf6; border-radius: 8px; padding: 10px; margin-bottom: 12px; }
.virtual-trade-header { font-size: 13px; font-weight: 700; color: #8b5cf6; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; }
.virtual-trade-status { background: #8b5cf6; color: white; padding: 6px 10px; border-radius: 6px; text-align: center; font-size: 11px; font-weight: 700; margin-top: 8px; display: none; }
.virtual-trade-status.active { display: block; }
.virtual-trade-stats { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 8px; }
.virtual-trade-stats > div { background: #0f172a; padding: 6px; border-radius: 4px; text-align: center; }
.virtual-trade-stats span { font-size: 10px; opacity: 0.7; display: block; }
.virtual-trade-stats b { font-size: 14px; display: block; margin-top: 2px; color: #8b5cf6; }
.switch-notice { background: #22c55e; color: #020617; padding: 6px; border-radius: 4px; text-align: center; font-size: 11px; font-weight: 700; margin-top: 8px; display: none; }
.switch-notice.active { display: block; }

/* New Digit Percentage Display */
.digit-percentage-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; margin-top: 10px; padding: 10px; background: #1e293b; border-radius: 6px; }
.digit-percentage-grid > div { text-align: center; padding: 5px; border-radius: 4px; background: #0f172a; }
.digit-percentage-grid span { font-size: 10px; opacity: 0.7; display: block; }
.digit-percentage-grid b { font-size: 14px; display: block; margin-top: 2px; }
.safe-zone { background: #22c55e; color: #020617; padding: 6px; border-radius: 4px; text-align: center; font-size: 11px; font-weight: 700; margin-top: 8px; }
.danger-zone { background: #ef4444; color: white; padding: 6px; border-radius: 4px; text-align: center; font-size: 11px; font-weight: 700; margin-top: 8px; }

/* LSTM Training Indicator */
.lstm-training { background: #8b5cf6; color: white; padding: 8px; border-radius: 6px; text-align: center; font-size: 11px; font-weight: 700; margin-top: 8px; display: none; }
.lstm-training.active { display: block; }
</style>
</head>
<body>
<div class="app">

<h2>Deriv Digit Over 5 Pro <span class="ml-indicator ml-active">ML v4 (PSF + LSTM Enhanced)</span></h2>

<div class="status-container">
    <div id="status" class="status disconnected">Disconnected</div>
    <div id="accountType" class="account-type"></div>
</div>

<div id="balanceDisplay" class="balance-display" style="display:none;">
  <span>Balance:</span>
  <b id="balance">0.00</b>
  <span id="balanceCurrency">USD</span>
  <div id="sessionTimer" class="session-timer">Session: 00:00:00</div>
  <div id="shutdownDisplay" class="shutdown-timer">Shutdown in: --:--:--</div>
</div>

<div class="card">
  <input id="token" type="password" placeholder="Deriv API Token" required>
  <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <button onclick="connect()">Login</button>
    <button id="logoutBtn" style="background: #ef4444;">Logout</button>
  </div>
</div>

<!-- Virtual Trade Feature -->
<div class="virtual-trade-container">
  <div class="virtual-trade-header">
    üéÆ Virtual Trade Mode
  </div>
  
  <div class="toggle-container" style="margin: 0;">
    <span class="toggle-label">Enable Virtual Trade First</span>
    <label class="toggle-switch">
      <input type="checkbox" id="virtualTradeToggle" onchange="toggleVirtualTrade()">
      <span class="toggle-slider"></span>
    </label>
  </div>
  
  <div id="virtualTradeSettings" style="display: none; margin-top: 10px;">
    <label>Consecutive Losses to Switch to Live</label>
    <input id="virtualLossThreshold" class="save-setting" type="number" value="3" min="1" max="20">
    
    <div class="virtual-trade-stats">
      <div>
        <span>Virtual Losses</span>
        <b id="virtualLossCount">0</b>
      </div>
      <div>
        <span>Threshold</span>
        <b id="virtualThresholdDisplay">3</b>
      </div>
    </div>
    
    <div class="virtual-trade-status" id="virtualTradeStatus">
      üéÆ Trading on VIRTUAL account
    </div>
    
    <div class="switch-notice" id="switchNotice">
      ‚ö†Ô∏è Switched to LIVE account after hitting loss threshold!
    </div>
  </div>
</div>

<div class="card">
  <h3>üìä Advanced ML Analyzer v4 (PSF + LSTM Enhanced)</h3>
  <div class="analyzer-grid" id="digitDisplay"></div>
  <div class="analyzer-stats">
    <div><span>Over 5</span><b id="overCount" style="color: #22c55e;">0</b></div>
    <div><span>Total Ticks</span><b id="totalCount" style="color: #e5e7eb;">0</b></div>
    <div><span>Over %</span><b id="overPercent" style="color: #22c55e;">0%</b></div>
  </div>
  
  <!-- New Digit Percentage Display -->
  <div class="digit-percentage-grid">
    <div><span>D 6-9%</span><b id="digit69Percent" style="color: #22c55e;">0%</b></div>
    <div><span>D 0-5%</span><b id="digit05Percent" style="color: #ef4444;">0%</b></div>
    <div><span>Even%</span><b id="evenPercent" style="color: #3b82f6;">0%</b></div>
    <div><span>Odd%</span><b id="oddPercent" style="color: #f59e0b;">0%</b></div>
    <div><span>RSI</span><b id="rsiValue" style="color: #8b5cf6;">50</b></div>
  </div>
  
  <div id="marketZone" style="display: none;"></div>
  
  <div style="margin-top: 10px; padding: 12px; background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%); border-radius: 8px; border: 2px solid #22c55e;">
    <div style="font-size: 14px; font-weight: 700; margin-bottom: 10px; color: #22c55e;">üîÆ ML Prediction Engine v4 (PSF + LSTM + DTW)</div>
    
    <div id="signalTimerDisplay" class="window-timer">SYNCING CLOCK...</div>

    <div style="background: #0f172a; padding: 10px; border-radius: 6px; margin-bottom: 8px; margin-top: 8px;">
      <div style="font-size: 11px; opacity: 0.7; margin-bottom: 5px;">Next Digit Prediction:</div>
      <div style="font-size: 24px; font-weight: 700; text-align: center;" id="nextDigitPrediction">-</div>
      <div style="font-size: 11px; text-align: center; margin-top: 5px;" id="predictionConfidence">-</div>
    </div>
    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; font-size: 11px;">
      <div style="background: #1e293b; padding: 6px; border-radius: 4px; text-align: center;"><div>Freq Bias</div><b id="freqScore" style="color: #22c55e;">0%</b></div>
      <div style="background: #1e293b; padding: 6px; border-radius: 4px; text-align: center;"><div>Gap Count</div><b id="cycleScore" style="color: #3b82f6;">0</b></div>
      <div style="background: #1e293b; padding: 6px; border-radius: 4px; text-align: center;"><div>Volatility</div><b id="volatilityScore" style="color: #f59e0b;">Low</b></div>
    </div>
    
    <div class="advanced-stats">
      <div><span style="opacity:0.6">Bayesian Prob</span><b id="bayesianProb" style="color:#8b5cf6">50%</b></div>
      <div><span style="opacity:0.6">Markov Pred</span><b id="markovProb" style="color:#3b82f6">50%</b></div>
      <div><span style="opacity:0.6">PSF Pred</span><b id="psfProb" style="color:#f59e0b">50%</b></div>
      <div><span style="opacity:0.6">LSTM Pred</span><b id="lstmProb" style="color:#ec4899">50%</b></div>
      <div><span style="opacity:0.6">Ensemble</span><b id="ensembleScore" style="color:#22c55e">50%</b></div>
      <div><span style="opacity:0.6">Confidence Adj</span><b id="confAdj" style="color:#f59e0b">0%</b></div>
    </div>
    
    <div class="model-performance">
      <div id="heuristicPerf"><span style="opacity:0.6">Heuristic</span><b style="color:#22c55e">--%</b></div>
      <div id="bayesianPerf"><span style="opacity:0.6">Bayesian</span><b style="color:#8b5cf6">--%</b></div>
      <div id="markovPerf"><span style="opacity:0.6">Markov</span><b style="color:#3b82f6">--%</b></div>
      <div id="psfPerf"><span style="opacity:0.6">PSF</span><b style="color:#f59e0b">--%</b></div>
      <div id="lstmPerf"><span style="opacity:0.6">LSTM</span><b style="color:#ec4899">--%</b></div>
    </div>
    
    <div class="lstm-training" id="lstmTrainingStatus">
      üß† LSTM Model Training... Please wait
    </div>
    
    <div style="margin-top: 8px; font-size: 11px; opacity: 0.7; text-align: center;" id="patternMatch">Analyzing patterns...</div>
    
    <div style="margin-top: 15px; border-top: 1px solid #334155; padding-top: 10px;">
        <div style="font-size: 12px; font-weight: 600; color: #94a3b8; display: flex; justify-content: space-between;">
            <span>SYSTEM & TRADE LOG</span>
            <span style="cursor:pointer; color:#3b82f6" onclick="document.getElementById('logContainer').innerHTML=''">Clear</span>
        </div>
        <div class="log-container" id="logContainer">
            <div class="log-entry"><span class="log-time">[System]</span> <span class="log-msg-success">ML Engine v4 Ready (PSF + LSTM + DTW Enhanced).</span></div>
        </div>
    </div>
  </div>
</div>

<div class="card">
  <h3>Trade Settings</h3>
  
  <label>PSF Window Size (Pattern Length)</label>
  <input id="psfWindowSize" class="save-setting" type="number" value="10" min="5" max="50">
  
  <label>PSF Top Matches (K-Nearest)</label>
  <input id="psfTopMatches" class="save-setting" type="number" value="5" min="3" max="20">
  
  <label>LSTM Sequence Length</label>
  <input id="lstmSeqLength" class="save-setting" type="number" value="20" min="10" max="100">
  
  <label>LSTM Training Epochs</label>
  <input id="lstmEpochs" class="save-setting" type="number" value="30" min="10" max="100">
  
  <button onclick="trainLSTMModel()" id="trainLSTMBtn" style="background: #8b5cf6; margin-bottom: 10px;">üß† Train/Retrain LSTM Model</button>
  
  <label>Stake ($)</label>
  <input id="stake" class="save-setting" type="number" value="1" min="0.35" step="0.01">
  <label>Duration (Ticks)</label>
  <input id="duration" class="save-setting" type="number" value="1" min="1" max="10">
  <label>Cooldown (seconds)</label>
  <input id="cooldown" class="save-setting" type="number" value="2" min="1">
  
  <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <div>
      <label>Window: Closing (Sec)</label>
      <input id="closingSec" class="save-setting" type="number" value="10" min="1" max="59">
    </div>
    <div>
      <label>Window: Opening (Sec)</label>
      <input id="openingSec" class="save-setting" type="number" value="10" min="1" max="59">
    </div>
  </div>
  
  <!-- New Strategy Settings -->
  <label>Minimum Digit 6-9% for Over-5 Trade</label>
  <input id="minDigit69Percent" class="save-setting" type="number" value="54" min="0" max="100">
  
  <label>Maximum Volatility for Trading</label>
  <input id="maxVolatilityThreshold" class="save-setting" type="number" value="2.5" min="0" max="10" step="0.1">
  
  <label>Minimum Streak Count for Trade</label>
  <input id="minStreakCount" class="save-setting" type="number" value="3" min="1" max="10">
  
  <label>Maximum Streak Count (Cap)</label>
  <input id="maxStreakCount" class="save-setting" type="number" value="7" min="1" max="20">

  <label>Confidence Selection Mode</label>
  <div class="radio-group" id="confidenceModeRadios">
      <div class="radio-option" onclick="selectConfidenceMode('range')">
          <input type="radio" name="confidenceMode" value="range" id="modeRange" checked>
          <label for="modeRange">Mode 1: Range (Min-Max)</label>
      </div>
      <div class="radio-option" onclick="selectConfidenceMode('specific')">
          <input type="radio" name="confidenceMode" value="specific" id="modeSpecific">
          <label for="modeSpecific">Mode 2: Specific Numbers (Pick 5)</label>
      </div>
      <div class="radio-option" onclick="selectConfidenceMode('sequence')">
          <input type="radio" name="confidenceMode" value="sequence" id="modeSequence">
          <label for="modeSequence">Mode 3: Sequence Pattern (3 Slots)</label>
      </div>
      <div class="radio-option" onclick="selectConfidenceMode('pattern')">
          <input type="radio" name="confidenceMode" value="pattern" id="modePattern">
          <label for="modePattern">Mode 4: Pattern Detection (Next Likely Digit)</label>
      </div>
  </div>

  <div id="rangeUI">
      <label>Confidence Range (Min - Max %)</label>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
        <input id="minConfidence" class="save-setting" type="number" value="55" min="0" max="100" placeholder="Min">
        <input id="maxConfidence" class="save-setting" type="number" value="70" min="0" max="100" placeholder="Max">
      </div>
  </div>

  <div id="specificUI" style="display:none;">
      <label>Specific Target Numbers</label>
      <div class="specific-grid">
          <input id="spec1" class="save-setting" type="number" value="10" min="0" max="100">
          <input id="spec2" class="save-setting" type="number" value="25" min="0" max="100">
          <input id="spec3" class="save-setting" type="number" value="49" min="0" max="100">
          <input id="spec4" class="save-setting" type="number" value="50" min="0" max="100">
          <input id="spec5" class="save-setting" type="number" value="65" min="0" max="100">
      </div>
  </div>

  <div id="sequenceUI" style="display:none;">
      <label>Sequence Slots Logic</label>
      
      <div class="sequence-slot">
          <div class="sequence-slot-title">Slot 1</div>
          <div class="seq-grid">
              <div><span style="font-size:9px">1st Pred >=</span><input id="s1_p1_min" class="save-setting" type="number" value="40"></div>
              <div><span style="font-size:9px">2nd Pred >=</span><input id="s1_p2_min" class="save-setting" type="number" value="50"></div>
              <div><span style="font-size:9px">2nd Pred <=</span><input id="s1_p2_max" class="save-setting" type="number" value="98"></div>
          </div>
      </div>

      <div class="sequence-slot">
          <div class="sequence-slot-title">Slot 2</div>
          <div class="seq-grid">
              <div><span style="font-size:9px">1st Pred >=</span><input id="s2_p1_min" class="save-setting" type="number" value="15"></div>
              <div><span style="font-size:9px">2nd Pred >=</span><input id="s2_p2_min" class="save-setting" type="number" value="60"></div>
              <div><span style="font-size:9px">2nd Pred <=</span><input id="s2_p2_max" class="save-setting" type="number" value="98"></div>
          </div>
      </div>

      <div class="sequence-slot">
          <div class="sequence-slot-title">Slot 3</div>
          <div class="seq-grid">
              <div><span style="font-size:9px">1st Pred >=</span><input id="s3_p1_min" class="save-setting" type="number" value="50"></div>
              <div><span style="font-size:9px">2nd Pred >=</span><input id="s3_p2_min" class="save-setting" type="number" value="50"></div>
              <div><span style="font-size:9px">2nd Pred <=</span><input id="s3_p2_max" class="save-setting" type="number" value="98"></div>
          </div>
      </div>
  </div>

  <div id="patternUI" style="display:none;">
      <div class="pattern-mode-active">üéØ Pattern Detection Mode Active (v4 Enhanced)</div>
      <label>Target Digits for Pattern Match (0-9)</label>
      <div class="pattern-target-grid">
          <input id="pattern1" class="save-setting" type="number" value="0" min="0" max="9" placeholder="Digit 1">
          <input id="pattern2" class="save-setting" type="number" value="1" min="0" max="9" placeholder="Digit 2">
          <input id="pattern3" class="save-setting" type="number" value="6" min="0" max="9" placeholder="Digit 3">
          <input id="pattern4" class="save-setting" type="number" value="7" min="0" max="9" placeholder="Digit 4">
          <input id="pattern5" class="save-setting" type="number" value="8" min="0" max="9" placeholder="Digit 5">
      </div>
      <div style="font-size: 11px; opacity: 0.7; margin-top: 8px; text-align: center;">
          Bot will trade when pattern's "Next Likely" digit matches any of the above targets
      </div>
      
      <div class="ensemble-filter-box">
          <label>‚ö° Next Likely % Filter (Use ONE at a time)</label>
          <div class="ensemble-filter-grid">
              <div>
                  <span style="font-size: 10px; opacity: 0.7; display: block; margin-bottom: 3px;">Trade if ‚â§ (Less/Equal)</span>
                  <input id="patternEnsembleMax" class="save-setting ensemble-filter-input" type="number" value="0" min="0" max="100" placeholder="0 = OFF">
              </div>
              <div>
                  <span style="font-size: 10px; opacity: 0.7; display: block; margin-bottom: 3px;">Trade if ‚â• (Greater/Equal)</span>
                  <input id="patternEnsembleMin" class="save-setting ensemble-filter-input" type="number" value="0" min="0" max="100" placeholder="0 = OFF">
              </div>
          </div>
          <div class="filter-warning" id="filterWarning">
              ‚ö†Ô∏è Cannot use multiple filters! Only ONE can be active
          </div>
          <div class="ensemble-status" id="ensembleFilterStatus">
              All filters disabled - Trading on pattern match only
          </div>
          <div style="font-size: 10px; opacity: 0.6; margin-top: 8px; line-height: 1.4;">
              üìå <strong>Quick Guide:</strong><br>
              <strong>‚â§ (Max):</strong> Trade when Next Likely % is LOW (0 = OFF)<br>
              <strong>‚â• (Min):</strong> Trade when Next Likely % is HIGH (0 = OFF)<br>
              <strong>‚ö†Ô∏è Only ONE filter active at a time</strong>
          </div>
      </div>
      
      <!-- Specific Ensemble Percentages Toggle -->
      <div class="toggle-container">
          <span class="toggle-label">üìä Specific Next Likely % Filter</span>
          <label class="toggle-switch">
              <input type="checkbox" id="specificEnsembleToggle" onchange="toggleSpecificEnsemble()">
              <span class="toggle-slider"></span>
          </label>
      </div>
      
      <div class="specific-ensemble-section" id="specificEnsembleSection">
          <label style="color: #8b5cf6; font-weight: 700; font-size: 12px; margin-bottom: 8px; display: block;">
              üéØ Specific Next Likely Percentages (Pick up to 5)
          </label>
          <div class="specific-ensemble-grid">
              <input id="specEns1" class="save-setting" type="number" value="25" min="0" max="100" placeholder="%1">
              <input id="specEns2" class="save-setting" type="number" value="50" min="0" max="100" placeholder="%2">
              <input id="specEns3" class="save-setting" type="number" value="65" min="0" max="100" placeholder="%3">
              <input id="specEns4" class="save-setting" type="number" value="75" min="0" max="100" placeholder="%4">
              <input id="specEns5" class="save-setting" type="number" value="85" min="0" max="100" placeholder="%5">
          </div>
          <div style="text-align: center; font-size: 11px; margin-top: 8px; padding: 6px; background: #1e293b; border-radius: 4px;" id="specificEnsembleStatus">
              Trade only when Next Likely % matches these specific values
          </div>
          <div style="font-size: 10px; opacity: 0.6; margin-top: 8px; line-height: 1.4;">
              üí° Example: If you set 25, 50, 75 - bot will ONLY trade when Next Likely % is exactly 25%, 50%, or 75%
          </div>
      </div>
  </div>

  <label>Market</label>
  <div class="radio-group" id="marketRadios">
      <div class="radio-option" onclick="selectMarket('R_10')">
          <input type="radio" name="market" value="R_10" id="marketR10" checked>
          <label for="marketR10">R_10</label>
      </div>
      <div class="radio-option" onclick="selectMarket('R_25')">
          <input type="radio" name="market" value="R_25" id="marketR25">
          <label for="marketR25">R_25</label>
      </div>
      <div class="radio-option" onclick="selectMarket('R_50')">
          <input type="radio" name="market" value="R_50" id="marketR50">
          <label for="marketR50">R_50</label>
      </div>
      <div class="radio-option" onclick="selectMarket('R_75')">
          <input type="radio" name="market" value="R_75" id="marketR75">
          <label for="marketR75">R_75</label>
      </div>
      <div class="radio-option" onclick="selectMarket('R_100')">
          <input type="radio" name="market" value="R_100" id="marketR100">
          <label for="marketR100">R_100</label>
      </div>
  </div>
</div>

<div class="card">
  <h3>Risk Management</h3>
  <label>Stop Loss ($)</label>
  <input id="stoploss" class="save-setting" type="number" value="10" min="1">
  <label>Take Profit ($)</label>
  <input id="takeprofit" class="save-setting" type="number" value="10" min="1">
  <label>Auto Trade Duration (Hours) - [0 = Unlimited]</label>
  <input id="autoDurationHrs" class="save-setting" type="number" value="1" min="0" step="0.01">
</div>

<button onclick="toggleMarketCycle()" id="cycleBtn" class="btn-cycle">Auto Market Cycle: OFF</button>
<button onclick="toggleCooldownLoop()" id="cooldownBtn" class="btn-cooldown">Cycle Cooldown Loop: OFF</button>
<div id="cycleTimerDisplay" class="cycle-timer-display">Next Loop in: --:--</div>

<div class="card" style="margin-top: 0;">
  <label>Wait Time (Minutes)</label>
  <input id="cycleWaitTime" class="save-setting" type="number" value="5" min="1">
</div>

<button onclick="toggleReverseTrade()" id="reverseBtn" class="btn-reverse">Reverse Trade: OFF</button>

<div class="buttons">
  <button onclick="manualTrade()" id="manualBtn">Manual Trade</button>
  <button onclick="toggleAuto()" id="autoBtn">Start Auto</button>
</div>

<button onclick="resetStats()" class="reset-button-permanent">üîÑ Reset All Stats</button>

<div class="card stats">
  <div><span>Trades</span><b id="trades">0</b></div>
  <div><span>Wins</span><b id="wins">0</b></div>
  <div><span>Losses</span><b id="losses">0</b></div>
  <div><span>P/L</span><b id="profit">0.00</b></div>
</div>

<div class="card">
<h3>Trade History</h3>
<div class="table-container">
<table>
<thead><tr><th>#</th><th>Result</th><th>P/L</th><th>Market</th></tr></thead>
<tbody id="history"></tbody>
</table>
</div>
</div>

</div>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
<script>
// ============ CORE VARIABLES ============
let ws = null;
let isConnected = false;
let isAutoRunning = false;
let currentContractId = null;
let accountBalance = 0;
let stats = { trades: 0, wins: 0, losses: 0, profit: 0 };
let digitHistory = [];
let sessionStartTime = null;
let autoStartTime = null; 
let timerIntervalId = null;
let isExplicitLogout = false;
let lastPredictionConfidence = 0; 
let previousPredictionConfidence = 0;
let lastPredictionType = '-';
let lastTradeTime = 0;
let lastRequestTime = 0; 
let currentConfidenceMode = 'range';
let currentMarketValue = 'R_10';
let isSpecificEnsembleActive = false;

let isMarketCycleActive = false;
let isCooldownLoopActive = false;
let isCycleCooldown = false;
const marketSequence = ["R_10", "R_25", "R_50", "R_75", "R_100"];
let currentMarketIndex = 0;
let isReverseTradeActive = false;
let cycleTimerId = null;
let isSignalWindowOpen = false;

// ============ VIRTUAL TRADE VARIABLES ============
let isVirtualTradeEnabled = false;
let virtualLossStreak = 0;
let hasSwatchedToLive = false;
let virtualTradeHistory = [];

// ============ ENHANCED ML VARIABLES v4 (PSF + LSTM + DTW) ============
let bayesianAlpha = 1;
let bayesianBeta = 1;
let markovTransitionMatrix = {};
let markovTransitionMatrix2ndOrder = {};
let recentWinRates = [];
let extendedHistory = [];
let patternCache = {};
let volatilityWindow = [];
let detectedPattern = null;

// NEW v4: PSF and LSTM variables
let psfPatternClusters = [];
let lstmModel = null;
let isLSTMTrained = false;
let isLSTMTraining = false;

// Model performance tracking
let modelAccuracies = {
    heuristic: 0,
    bayesian: 0,
    markov: 0,
    psf: 0,
    lstm: 0
};
let modelPredictions = {
    heuristic: [],
    bayesian: [],
    markov: [],
    psf: [],
    lstm: []
};

// Advanced pattern detection
let fuzzyPatternCache = {};
let patternDecayTimer = 0;

// Decay factor for Bayesian
const BAYESIAN_DECAY = 0.995;

// OPTIMIZED CONSTANTS
const MIN_PATTERN_LENGTH = 6;
const MIN_PATTERN_OCCURRENCES = 3;
const MIN_HISTORY_FOR_PATTERNS = 20;

// NEW v4: Digit statistics tracking
let digitCounts = Array(10).fill(0);
let evenOddCounts = { even: 0, odd: 0 };
let rsiValues = [];

// ============ NEW v4: DTW (Dynamic Time Warping) Implementation ============
function dtwDistance(seq1, seq2) {
    const n = seq1.length;
    const m = seq2.length;
    const dtw = Array(n + 1).fill(null).map(() => Array(m + 1).fill(Infinity));
    
    dtw[0][0] = 0;
    
    for (let i = 1; i <= n; i++) {
        for (let j = 1; j <= m; j++) {
            const cost = Math.abs(seq1[i - 1] - seq2[j - 1]);
            dtw[i][j] = cost + Math.min(
                dtw[i - 1][j],     // insertion
                dtw[i][j - 1],     // deletion
                dtw[i - 1][j - 1]  // match
            );
        }
    }
    
    return dtw[n][m];
}

// ============ NEW v4: PSF (Pattern Sequence-Based Forecasting) Implementation ============
function calculateEuclideanDistance(arr1, arr2) {
    if (arr1.length !== arr2.length) return Infinity;
    let sum = 0;
    for (let i = 0; i < arr1.length; i++) {
        sum += Math.pow(arr1[i] - arr2[i], 2);
    }
    return Math.sqrt(sum);
}

function buildPSFPatterns() {
    const windowSize = parseInt(document.getElementById('psfWindowSize').value) || 10;
    const patterns = [];
    
    if (extendedHistory.length < windowSize + 1) {
        return patterns;
    }
    
    for (let i = 0; i < extendedHistory.length - windowSize - 1; i++) {
        const pattern = extendedHistory.slice(i, i + windowSize);
        const nextDigit = extendedHistory[i + windowSize];
        const timestamp = Date.now() - (extendedHistory.length - i) * 1000;
        
        patterns.push({
            pattern: pattern,
            nextDigit: nextDigit,
            timestamp: timestamp,
            index: i
        });
    }
    
    return patterns;
}

function calculatePSFPrediction() {
    if (digitHistory.length < 10) return { prediction: 50, confidence: 0, method: 'PSF' };
    
    const windowSize = parseInt(document.getElementById('psfWindowSize').value) || 10;
    const topK = parseInt(document.getElementById('psfTopMatches').value) || 5;
    
    if (digitHistory.length < windowSize) {
        return { prediction: 50, confidence: 0, method: 'PSF' };
    }
    
    const currentPattern = digitHistory.slice(0, windowSize);
    const allPatterns = buildPSFPatterns();
    
    if (allPatterns.length === 0) {
        return { prediction: 50, confidence: 0, method: 'PSF' };
    }
    
    // Calculate distances using DTW for better accuracy
    const distances = allPatterns.map(p => ({
        ...p,
        distance: dtwDistance(currentPattern, p.pattern),
        euclidean: calculateEuclideanDistance(currentPattern, p.pattern)
    }));
    
    // Sort by DTW distance and get top K matches
    distances.sort((a, b) => a.distance - b.distance);
    const topMatches = distances.slice(0, topK);
    
    // Apply exponential weighting (recent patterns get higher weight)
    const now = Date.now();
    let weightedSum = 0;
    let totalWeight = 0;
    
    topMatches.forEach((match, idx) => {
        const recencyWeight = Math.exp(-(now - match.timestamp) / (86400000 * 7)); // 7-day decay
        const distanceWeight = Math.exp(-match.distance / windowSize);
        const rankWeight = Math.exp(-idx / topK);
        
        const combinedWeight = recencyWeight * distanceWeight * rankWeight;
        
        weightedSum += match.nextDigit * combinedWeight;
        totalWeight += combinedWeight;
    });
    
    const predictedDigit = totalWeight > 0 ? Math.round(weightedSum / totalWeight) : 5;
    
    // Calculate confidence based on distance variance
    const avgDistance = topMatches.reduce((sum, m) => sum + m.distance, 0) / topMatches.length;
    const maxDistance = windowSize * 9; // Maximum possible distance
    const confidence = Math.max(0, Math.min(98, 100 - (avgDistance / maxDistance) * 100));
    
    // Convert to over/under 5 probability
    const isOver5 = predictedDigit > 5;
    const psfProb = isOver5 ? (50 + confidence / 2) : (50 - confidence / 2);
    
    return {
        prediction: psfProb,
        confidence: confidence,
        predictedDigit: predictedDigit,
        method: 'PSF',
        topMatches: topMatches.length,
        avgDistance: avgDistance.toFixed(2)
    };
}

// ============ NEW v4: LSTM Implementation ============
async function buildLSTMModel() {
    const seqLength = parseInt(document.getElementById('lstmSeqLength').value) || 20;
    
    const model = tf.sequential();
    
    // LSTM layer with dropout for regularization
    model.add(tf.layers.lstm({
        units: 50,
        returnSequences: true,
        inputShape: [seqLength, 1],
        dropout: 0.2,
        recurrentDropout: 0.2
    }));
    
    // Second LSTM layer
    model.add(tf.layers.lstm({
        units: 30,
        dropout: 0.2,
        recurrentDropout: 0.2
    }));
    
    // Dense layers
    model.add(tf.layers.dense({ units: 20, activation: 'relu' }));
    model.add(tf.layers.dropout({ rate: 0.2 }));
    model.add(tf.layers.dense({ units: 1, activation: 'sigmoid' })); // Output: probability of over 5
    
    model.compile({
        optimizer: tf.train.adam(0.001),
        loss: 'binaryCrossentropy',
        metrics: ['accuracy']
    });
    
    return model;
}

function prepareLSTMData(history, seqLength) {
    const sequences = [];
    const labels = [];
    
    for (let i = seqLength; i < history.length; i++) {
        const seq = history.slice(i - seqLength, i);
        const nextDigit = history[i];
        const label = nextDigit > 5 ? 1 : 0;
        
        sequences.push(seq);
        labels.push(label);
    }
    
    if (sequences.length === 0) return null;
    
    // Normalize sequences to 0-1 range
    const normalizedSeqs = sequences.map(seq => seq.map(d => d / 9));
    
    // Convert to tensors with shape [samples, timesteps, features]
    const xs = tf.tensor3d(normalizedSeqs.map(seq => seq.map(d => [d])));
    const ys = tf.tensor2d(labels, [labels.length, 1]);
    
    return { xs, ys };
}

async function trainLSTMModel() {
    if (isLSTMTraining) {
        addLog("LSTM training already in progress...", "warn");
        return;
    }
    
    const seqLength = parseInt(document.getElementById('lstmSeqLength').value) || 20;
    
    if (extendedHistory.length < seqLength + 100) {
        addLog(`Need at least ${seqLength + 100} data points to train LSTM. Current: ${extendedHistory.length}`, "error");
        return;
    }
    
    isLSTMTraining = true;
    document.getElementById('lstmTrainingStatus').classList.add('active');
    document.getElementById('trainLSTMBtn').disabled = true;
    document.getElementById('trainLSTMBtn').textContent = 'üß† Training...';
    
    addLog("üß† Starting LSTM model training...", "info");
    
    try {
        // Build model
        if (lstmModel) {
            lstmModel.dispose();
        }
        lstmModel = await buildLSTMModel();
        
        // Prepare training data
        const data = prepareLSTMData(extendedHistory, seqLength);
        
        if (!data) {
            throw new Error("Failed to prepare training data");
        }
        
        const epochs = parseInt(document.getElementById('lstmEpochs').value) || 30;
        
        // Add data augmentation: create noisy copies
        const augmentedData = [];
        const augmentedLabels = [];
        
        // Original data
        const originalXs = await data.xs.array();
        const originalYs = await data.ys.array();
        
        for (let i = 0; i < originalXs.length; i++) {
            augmentedData.push(originalXs[i]);
            augmentedLabels.push(originalYs[i]);
            
            // Add noisy version (5% of data)
            if (Math.random() < 0.05) {
                const noisySeq = originalXs[i].map(val => {
                    const noise = (Math.random() - 0.5) * 0.1; // Small noise
                    return [Math.max(0, Math.min(1, val[0] + noise))];
                });
                augmentedData.push(noisySeq);
                augmentedLabels.push(originalYs[i]);
            }
        }
        
        const augXs = tf.tensor3d(augmentedData);
        const augYs = tf.tensor2d(augmentedLabels, [augmentedLabels.length, 1]);
        
        // Train model
        await lstmModel.fit(augXs, augYs, {
            epochs: epochs,
            batchSize: 32,
            validationSplit: 0.2,
            shuffle: true,
            callbacks: {
                onEpochEnd: (epoch, logs) => {
                    if (epoch % 5 === 0) {
                        addLog(`Epoch ${epoch + 1}/${epochs}: loss=${logs.loss.toFixed(4)}, acc=${(logs.acc * 100).toFixed(1)}%`, "info");
                    }
                }
            }
        });
        
        // Cleanup
        data.xs.dispose();
        data.ys.dispose();
        augXs.dispose();
        augYs.dispose();
        
        isLSTMTrained = true;
        addLog("‚úÖ LSTM training complete! Model ready.", "success");
        
        // Save model to browser storage
        await lstmModel.save('localstorage://lstm-digit-model');
        addLog("üíæ LSTM model saved to browser storage", "success");
        
    } catch (error) {
        addLog(`‚ùå LSTM training failed: ${error.message}`, "error");
        console.error("LSTM training error:", error);
    } finally {
        isLSTMTraining = false;
        document.getElementById('lstmTrainingStatus').classList.remove('active');
        document.getElementById('trainLSTMBtn').disabled = false;
        document.getElementById('trainLSTMBtn').textContent = 'üß† Train/Retrain LSTM Model';
    }
}

async function loadLSTMModel() {
    try {
        lstmModel = await tf.loadLayersModel('localstorage://lstm-digit-model');
        isLSTMTrained = true;
        addLog("‚úÖ Loaded LSTM model from browser storage", "success");
        return true;
    } catch (error) {
        addLog("No saved LSTM model found. Please train first.", "warn");
        return false;
    }
}

function calculateLSTMPrediction() {
    if (!isLSTMTrained || !lstmModel) {
        return { prediction: 50, confidence: 0, method: 'LSTM' };
    }
    
    const seqLength = parseInt(document.getElementById('lstmSeqLength').value) || 20;
    
    if (digitHistory.length < seqLength) {
        return { prediction: 50, confidence: 0, method: 'LSTM' };
    }
    
    try {
        const inputSeq = digitHistory.slice(0, seqLength).reverse(); // Reverse to get chronological order
        const normalizedSeq = inputSeq.map(d => d / 9);
        
        const input = tf.tensor3d([[normalizedSeq.map(d => [d])]]);
        const prediction = lstmModel.predict(input);
        const predValue = prediction.dataSync()[0];
        
        input.dispose();
        prediction.dispose();
        
        // Convert to percentage (probability of over 5)
        const lstmProb = predValue * 100;
        const confidence = Math.abs(predValue - 0.5) * 200; // 0-100 confidence
        
        return {
            prediction: lstmProb,
            confidence: confidence,
            method: 'LSTM',
            rawPrediction: predValue
        };
    } catch (error) {
        console.error("LSTM prediction error:", error);
        return { prediction: 50, confidence: 0, method: 'LSTM' };
    }
}

// ============ VIRTUAL TRADE FUNCTIONS ============
function toggleVirtualTrade() {
    isVirtualTradeEnabled = document.getElementById('virtualTradeToggle').checked;
    const settingsDiv = document.getElementById('virtualTradeSettings');
    const statusDiv = document.getElementById('virtualTradeStatus');
    const switchNotice = document.getElementById('switchNotice');
    
    if (isVirtualTradeEnabled) {
        settingsDiv.style.display = 'block';
        statusDiv.classList.add('active');
        virtualLossStreak = 0;
        hasSwatchedToLive = false;
        switchNotice.classList.remove('active');
        updateVirtualTradeUI();
        addLog("üéÆ Virtual Trade Mode ENABLED - Trading on virtual account first", "success");
    } else {
        settingsDiv.style.display = 'none';
        statusDiv.classList.remove('active');
        switchNotice.classList.remove('active');
        virtualLossStreak = 0;
        hasSwatchedToLive = false;
        addLog("Virtual Trade Mode DISABLED - Trading on main account", "warn");
    }
    
    saveSettings();
}

function updateVirtualTradeUI() {
    document.getElementById('virtualLossCount').textContent = virtualLossStreak;
    const threshold = parseInt(document.getElementById('virtualLossThreshold').value) || 3;
    document.getElementById('virtualThresholdDisplay').textContent = threshold;
    
    const statusDiv = document.getElementById('virtualTradeStatus');
    const switchNotice = document.getElementById('switchNotice');
    
    if (hasSwatchedToLive) {
        statusDiv.style.display = 'none';
        switchNotice.classList.add('active');
    } else {
        statusDiv.classList.add('active');
        switchNotice.classList.remove('active');
    }
}

function handleVirtualTradeResult(isWin) {
    if (!isVirtualTradeEnabled || hasSwatchedToLive) return;
    
    if (isWin) {
        virtualLossStreak = 0;
        addLog("üéÆ Virtual Trade WIN - Loss streak reset to 0", "success");
    } else {
        virtualLossStreak++;
        addLog(`üéÆ Virtual Trade LOSS - Consecutive losses: ${virtualLossStreak}`, "error");
        
        const threshold = parseInt(document.getElementById('virtualLossThreshold').value) || 3;
        
        if (virtualLossStreak >= threshold) {
            hasSwatchedToLive = true;
            addLog(`‚ö†Ô∏è SWITCHING TO LIVE ACCOUNT after ${virtualLossStreak} consecutive losses!`, "warn");
            addLog("üî¥ Now trading on LIVE account - Real money at risk!", "error");
            updateVirtualTradeUI();
        }
    }
    
    updateVirtualTradeUI();
}

function isCurrentlyVirtualMode() {
    return isVirtualTradeEnabled && !hasSwatchedToLive;
}

// ============ NEW v4: DIGIT STATISTICS FUNCTIONS ============

function calculateDigitPercentages() {
    const totalDigits = digitHistory.length;
    if (totalDigits === 0) return { digit69: 0, digit05: 0, even: 0, odd: 0 };
    
    const digit69Count = digitHistory.filter(d => d >= 6 && d <= 9).length;
    const digit05Count = digitHistory.filter(d => d >= 0 && d <= 5).length;
    
    const evenCount = digitHistory.filter(d => d % 2 === 0).length;
    const oddCount = digitHistory.filter(d => d % 2 !== 0).length;
    
    return {
        digit69: (digit69Count / totalDigits) * 100,
        digit05: (digit05Count / totalDigits) * 100,
        even: (evenCount / totalDigits) * 100,
        odd: (oddCount / totalDigits) * 100
    };
}

function calculateRSI(data, period = 14) {
    if (data.length < period + 1) return 50;
    
    const recentData = data.slice(0, period + 1);
    let gains = 0;
    let losses = 0;
    
    for (let i = 0; i < period; i++) {
        const change = recentData[i] - recentData[i + 1];
        if (change > 0) {
            gains += change;
        } else {
            losses += Math.abs(change);
        }
    }
    
    const avgGain = gains / period;
    const avgLoss = losses / period;
    
    if (avgLoss === 0) return 100;
    
    const rs = avgGain / avgLoss;
    const rsi = 100 - (100 / (1 + rs));
    
    return Math.round(rsi);
}

function updateDigitStatisticsDisplay() {
    const percentages = calculateDigitPercentages();
    
    document.getElementById('digit69Percent').textContent = percentages.digit69.toFixed(1) + '%';
    document.getElementById('digit05Percent').textContent = percentages.digit05.toFixed(1) + '%';
    document.getElementById('evenPercent').textContent = percentages.even.toFixed(1) + '%';
    document.getElementById('oddPercent').textContent = percentages.odd.toFixed(1) + '%';
    
    const rsi = calculateRSI(digitHistory, 14);
    document.getElementById('rsiValue').textContent = rsi;
    
    const rsiEl = document.getElementById('rsiValue');
    if (rsi < 30) {
        rsiEl.style.color = '#22c55e';
    } else if (rsi > 70) {
        rsiEl.style.color = '#ef4444';
    } else {
        rsiEl.style.color = '#8b5cf6';
    }
}

function evaluateMarketZone() {
    if (digitHistory.length < 10) return null;
    
    const volatility = calculateVolatility(volatilityWindow, 50);
    const maxVolThreshold = parseFloat(document.getElementById('maxVolatilityThreshold').value) || 2.5;
    const recentLosses = stats.losses - stats.wins;
    
    const zoneEl = document.getElementById('marketZone');
    
    const percentages = calculateDigitPercentages();
    const minDigit69 = parseFloat(document.getElementById('minDigit69Percent').value) || 54;
    
    if (volatility <= maxVolThreshold && recentLosses <= 0 && percentages.digit69 >= minDigit69) {
        zoneEl.className = 'safe-zone';
        zoneEl.textContent = '‚úÖ SAFE ZONE - Good trading conditions';
        zoneEl.style.display = 'block';
        return 'safe';
    } else if (volatility > maxVolThreshold || recentLosses > 2) {
        zoneEl.className = 'danger-zone';
        zoneEl.textContent = '‚ö†Ô∏è DANGER ZONE - Avoid trading or reduce stake';
        zoneEl.style.display = 'block';
        return 'danger';
    } else {
        zoneEl.style.display = 'none';
        return 'neutral';
    }
}

function applySimpleMovingAverage(data, period = 5) {
    if (data.length < period) return data;
    
    const smoothed = [];
    for (let i = 0; i < data.length; i++) {
        if (i < period - 1) {
            smoothed.push(data[i]);
        } else {
            let sum = 0;
            for (let j = 0; j < period; j++) {
                sum += data[i - j];
            }
            smoothed.push(sum / period);
        }
    }
    return smoothed;
}

// ============ UTILITY FUNCTIONS ============
function addLog(msg, type = 'info') {
    const container = document.getElementById('logContainer');
    const time = new Date().toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
    const entry = document.createElement('div');
    entry.className = 'log-entry';
    entry.innerHTML = `<span class="log-time">[${time}]</span> <span class="log-msg-${type}">${msg}</span>`;
    container.appendChild(entry);
    container.scrollTop = container.scrollHeight;
}

function updateSignalWindowTimer() {
    const now = new Date();
    const sec = now.getSeconds();
    const timerEl = document.getElementById('signalTimerDisplay');
    
    const closeWindowSize = parseInt(document.getElementById('closingSec').value) || 10;
    const openWindowSize = parseInt(document.getElementById('openingSec').value) || 10;
    
    const inClosingWindow = (sec >= (60 - closeWindowSize));
    const inOpeningWindow = (sec <= openWindowSize);
    
    if (inClosingWindow || inOpeningWindow) {
        isSignalWindowOpen = true;
        if (timerEl) {
            timerEl.style.color = "#22c55e";
            timerEl.style.borderColor = "#22c55e";
            timerEl.style.background = "rgba(34, 197, 94, 0.1)";
            timerEl.innerHTML = `SCANNING SIGNAL... (${sec}s)`;
        }
    } else {
        isSignalWindowOpen = false;
        const nextWindowIn = (60 - closeWindowSize) - sec;
        if (timerEl) {
            timerEl.style.color = "#f59e0b";
            timerEl.style.borderColor = "#334155";
            timerEl.style.background = "#020617";
            timerEl.innerHTML = `WAITING FOR WINDOW: ${nextWindowIn}s`;
        }
    }
}

function selectConfidenceMode(mode) {
    currentConfidenceMode = mode;
    document.querySelectorAll('#confidenceModeRadios .radio-option').forEach(opt => {
        opt.classList.remove('selected');
    });
    const selectedOption = document.querySelector(`#confidenceModeRadios .radio-option input[value="${mode}"]`).parentElement;
    selectedOption.classList.add('selected');
    document.getElementById(`mode${mode.charAt(0).toUpperCase() + mode.slice(1)}`).checked = true;
    
    toggleConfidenceUI();
    saveSettings();
}

function selectMarket(market) {
    currentMarketValue = market;
    document.querySelectorAll('#marketRadios .radio-option').forEach(opt => {
        opt.classList.remove('selected');
    });
    const selectedOption = document.querySelector(`#marketRadios .radio-option input[value="${market}"]`).parentElement;
    selectedOption.classList.add('selected');
    document.getElementById(`market${market.replace('_', '')}`).checked = true;
    
    if (isConnected) subscribeToTicks();
    saveSettings();
}

function toggleSpecificEnsemble() {
    isSpecificEnsembleActive = document.getElementById('specificEnsembleToggle').checked;
    const section = document.getElementById('specificEnsembleSection');
    
    if (isSpecificEnsembleActive) {
        section.classList.add('active');
        document.getElementById('patternEnsembleMax').value = 0;
        document.getElementById('patternEnsembleMin').value = 0;
        addLog("Specific Next Likely % Filter ENABLED", "info");
    } else {
        section.classList.remove('active');
        addLog("Specific Next Likely % Filter DISABLED", "warn");
    }
    
    updateEnsembleFilterStatus();
    saveSettings();
}

function updateEnsembleFilterStatus() {
    const maxEnsemble = parseInt(document.getElementById('patternEnsembleMax').value) || 0;
    const minEnsemble = parseInt(document.getElementById('patternEnsembleMin').value) || 0;
    const statusEl = document.getElementById('ensembleFilterStatus');
    const warningEl = document.getElementById('filterWarning');
    
    let activeCount = 0;
    if (maxEnsemble > 0) activeCount++;
    if (minEnsemble > 0) activeCount++;
    if (isSpecificEnsembleActive) activeCount++;
    
    if (activeCount > 1) {
        warningEl.style.display = 'block';
        statusEl.textContent = '‚ö†Ô∏è CONFLICT! Multiple filters active - Only ONE allowed';
        statusEl.style.color = '#ef4444';
        statusEl.style.background = 'rgba(239, 68, 68, 0.1)';
        statusEl.style.border = '1px solid #ef4444';
        return;
    }
    
    warningEl.style.display = 'none';
    statusEl.style.background = '#1e293b';
    statusEl.style.border = 'none';
    
    if (activeCount === 0) {
        statusEl.textContent = 'üîì All filters DISABLED - Trading on pattern match only';
        statusEl.style.color = '#22c55e';
    } else if (maxEnsemble > 0) {
        statusEl.textContent = `üîí Active: Trade if Next Likely % ‚â§ ${maxEnsemble}% (LOW confidence)`;
        statusEl.style.color = '#f59e0b';
    } else if (minEnsemble > 0) {
        statusEl.textContent = `üîí Active: Trade if Next Likely % ‚â• ${minEnsemble}% (HIGH confidence)`;
        statusEl.style.color = '#3b82f6';
    } else if (isSpecificEnsembleActive) {
        const specs = [
            parseInt(document.getElementById('specEns1').value),
            parseInt(document.getElementById('specEns2').value),
            parseInt(document.getElementById('specEns3').value),
            parseInt(document.getElementById('specEns4').value),
            parseInt(document.getElementById('specEns5').value)
        ].filter(v => !isNaN(v) && v >= 0 && v <= 100);
        statusEl.textContent = `üéØ Active: Trade if Next Likely % = ${specs.join(', ')}%`;
        statusEl.style.color = '#8b5cf6';
    }
}

function toggleConfidenceUI() {
    const mode = currentConfidenceMode;
    document.getElementById('rangeUI').style.display = (mode === 'range') ? 'block' : 'none';
    document.getElementById('specificUI').style.display = (mode === 'specific') ? 'block' : 'none';
    document.getElementById('sequenceUI').style.display = (mode === 'sequence') ? 'block' : 'none';
    document.getElementById('patternUI').style.display = (mode === 'pattern') ? 'block' : 'none';
    
    if (mode === 'pattern') {
        updateEnsembleFilterStatus();
    }
    
    addLog(`Confidence Mode: ${mode}`, "info");
}

function saveSettings() {
    const settings = {
        confidenceMode: currentConfidenceMode,
        market: currentMarketValue,
        specificEnsembleActive: isSpecificEnsembleActive,
        virtualTradeEnabled: isVirtualTradeEnabled,
        virtualLossStreak: virtualLossStreak,
        hasSwatchedToLive: hasSwatchedToLive
    };
    document.querySelectorAll('.save-setting').forEach(el => settings[el.id] = el.value);
    localStorage.setItem('bot_settings_v11_ml', JSON.stringify(settings));
}

function loadSettings() {
    const saved = localStorage.getItem('bot_settings_v11_ml');
    if (saved) {
        const settings = JSON.parse(saved);
        for (const id in settings) {
            const el = document.getElementById(id);
            if (el) el.value = settings[id];
        }
        
        if (settings.confidenceMode) {
            currentConfidenceMode = settings.confidenceMode;
            selectConfidenceMode(currentConfidenceMode);
        }
        
        if (settings.market) {
            currentMarketValue = settings.market;
            selectMarket(currentMarketValue);
        }
        
        if (settings.specificEnsembleActive) {
            isSpecificEnsembleActive = settings.specificEnsembleActive;
            document.getElementById('specificEnsembleToggle').checked = isSpecificEnsembleActive;
            if (isSpecificEnsembleActive) {
                document.getElementById('specificEnsembleSection').classList.add('active');
            }
        }
        
        if (settings.virtualTradeEnabled !== undefined) {
            isVirtualTradeEnabled = settings.virtualTradeEnabled;
            document.getElementById('virtualTradeToggle').checked = isVirtualTradeEnabled;
            if (isVirtualTradeEnabled) {
                document.getElementById('virtualTradeSettings').style.display = 'block';
            }
        }
        
        if (settings.virtualLossStreak !== undefined) {
            virtualLossStreak = settings.virtualLossStreak;
        }
        
        if (settings.hasSwatchedToLive !== undefined) {
            hasSwatchedToLive = settings.hasSwatchedToLive;
        }
        
        updateVirtualTradeUI();
    }
    
    toggleConfidenceUI();
    
    const savedExtHistory = localStorage.getItem('extended_history_v11');
    if(savedExtHistory) {
        try {
            extendedHistory = JSON.parse(savedExtHistory);
            addLog(`Loaded ${extendedHistory.length} historical ticks for ML`, "success");
        } catch(e) {
            addLog("Error loading extended history", "warn");
            extendedHistory = [];
        }
    }
    
    const savedHistory = localStorage.getItem('trade_history_v11');
    if(savedHistory) document.getElementById('history').innerHTML = savedHistory;
    
    const savedStats = localStorage.getItem('trade_stats_v11');
    if(savedStats) { 
        stats = JSON.parse(savedStats); 
        updateStats(); 
    }
    
    const savedBayesian = localStorage.getItem('bayesian_params_v11');
    if(savedBayesian) {
        const params = JSON.parse(savedBayesian);
        bayesianAlpha = params.alpha || 1;
        bayesianBeta = params.beta || 1;
    }
    
    const savedMarkov = localStorage.getItem('markov_matrix_v11');
    if(savedMarkov) {
        try {
            markovTransitionMatrix = JSON.parse(savedMarkov);
            addLog("Loaded Markov transition matrix", "success");
        } catch(e) {
            markovTransitionMatrix = {};
        }
    }
    
    const savedMarkov2nd = localStorage.getItem('markov_matrix_2nd_v11');
    if(savedMarkov2nd) {
        try {
            markovTransitionMatrix2ndOrder = JSON.parse(savedMarkov2nd);
            addLog("Loaded 2nd-order Markov matrix", "success");
        } catch(e) {
            markovTransitionMatrix2ndOrder = {};
        }
    }
}

document.querySelectorAll('.save-setting').forEach(el => {
    el.addEventListener('input', saveSettings);
    el.addEventListener('change', saveSettings);
});

// ============ WEBSOCKET CONNECTION ============
function connect() {
  const token = document.getElementById('token').value.trim();
  if (!token) { addLog("Error: API Token missing.", "error"); return; }
  if (ws) ws.close();
  sessionStorage.setItem('derivToken', token);
  isExplicitLogout = false;
  updateStatus('Connecting...', 'disconnected');
  ws = new WebSocket('wss://ws.derivws.com/websockets/v3?app_id=1089');
  ws.onopen = () => { addLog("WebSocket Connected.", "info"); sendAPIRequest({ authorize: token }); };
  ws.onmessage = (msg) => handleMessage(JSON.parse(msg.data));
  ws.onclose = () => {
    isConnected = false;
    updateStatus('Disconnected', 'disconnected');
    document.getElementById('accountType').style.display = 'none';
    if (!isExplicitLogout) { 
        addLog("Connection lost. Reconnecting in 5s...", "warn"); 
        setTimeout(connect, 5000); 
    }
  };
  ws.onerror = (error) => {
    addLog("WebSocket error occurred", "error");
    console.error("WebSocket error:", error);
  };
}

function handleMessage(data) {
  if (data.error) { 
    addLog(`API ERROR: ${data.error.message}`, "error"); 
    console.error("API Error:", data.error);
    return; 
  }
  
  if (data.authorize) {
    isConnected = true;
    updateStatus('Connected', 'connected');
    const accTypeEl = document.getElementById('accountType');
    const isVirtual = data.authorize.is_virtual === 1 || data.authorize.loginid.includes('VRTC');
    accTypeEl.textContent = isVirtual ? 'Demo Account' : 'Live Account';
    accTypeEl.className = 'account-type ' + (isVirtual ? 'demo-badge' : 'live-badge');
    accTypeEl.style.display = 'block';
    addLog(`Authorized: ${data.authorize.email}`, "success");
    sendAPIRequest({ balance: 1, subscribe: 1 });
    subscribeToTicks();
    startSessionTimer();
    
    const persistedAuto = localStorage.getItem('isAutoRunning') === 'true';
    if(persistedAuto && !isAutoRunning) {
        resumeAutoTrade();
    }
  }
  
  if (data.balance) { 
    accountBalance = data.balance.balance; 
    updateBalance(); 
  }
  
  if (data.tick) {
    const lastDigit = parseInt(data.tick.quote.toString().slice(-1));
    addDigitToAnalyzer(lastDigit);
  }
  
  if (data.buy) {
    currentContractId = data.buy.contract_id;
    const tradeMode = isCurrentlyVirtualMode() ? "VIRTUAL" : "LIVE";
    addLog(`${tradeMode} Trade Placed (ID: ${currentContractId})`, "success");
    sendAPIRequest({ proposal_open_contract: 1, contract_id: currentContractId, subscribe: 1 });
  }
  
  if (data.proposal_open_contract) {
    const contract = data.proposal_open_contract;
    if (contract.is_settled === 1 || ['won', 'lost', 'sold'].includes(contract.status)) {
      handleTradeResult(contract);
      currentContractId = null;
      if (data.subscription) sendAPIRequest({ forget: data.subscription.id });
    }
  }
}

function resumeAutoTrade() {
    isAutoRunning = true;
    const btn = document.getElementById('autoBtn');
    const shutdownUI = document.getElementById('shutdownDisplay');
    autoStartTime = parseInt(localStorage.getItem('autoStartTime')) || Date.now();
    shutdownUI.style.display = 'block';
    btn.textContent = 'Stop Auto'; 
    btn.style.background = '#ef4444';
    addLog("Resuming Persistent Auto-Trade...", "success");
}

// ============ ENHANCED ML FUNCTIONS v4 (PSF + LSTM + DTW) ============

function smoothOutliers(digit, history) {
    if (history.length < 10) return digit;
    
    const mean = history.reduce((a, b) => a + b, 0) / history.length;
    const variance = history.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / history.length;
    const stdDev = Math.sqrt(variance);
    
    if (stdDev > 0 && Math.abs(digit - mean) > 3 * stdDev) {
        const smoothed = Math.round(mean);
        addLog(`Outlier detected: ${digit} ‚Üí smoothed to ${smoothed}`, "warn");
        return smoothed;
    }
    
    return digit;
}

function calculateVolatility(data, windowSize = 50) {
    if (data.length < windowSize) windowSize = data.length;
    if (windowSize < 2) return 0;
    
    const recent = data.slice(0, windowSize);
    const mean = recent.reduce((a, b) => a + b, 0) / recent.length;
    const variance = recent.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / recent.length;
    return Math.sqrt(variance);
}

function updateBayesianModel(isOver5) {
    bayesianAlpha *= BAYESIAN_DECAY;
    bayesianBeta *= BAYESIAN_DECAY;
    
    if (isOver5) {
        bayesianAlpha += 1;
    } else {
        bayesianBeta += 1;
    }
    
    if ((bayesianAlpha + bayesianBeta) % 20 < 1) {
        localStorage.setItem('bayesian_params_v11', JSON.stringify({
            alpha: bayesianAlpha,
            beta: bayesianBeta
        }));
    }
    
    const posteriorMean = bayesianAlpha / (bayesianAlpha + bayesianBeta);
    return posteriorMean * 100;
}

function updateMarkovModel(currentDigit) {
    if (digitHistory.length < 1) return;
    
    const prevDigit = digitHistory[0];
    if (!markovTransitionMatrix[prevDigit]) {
        markovTransitionMatrix[prevDigit] = Array(10).fill(0);
    }
    markovTransitionMatrix[prevDigit][currentDigit]++;
    
    if (digitHistory.length >= 2) {
        const state = `${digitHistory[1]}-${digitHistory[0]}`;
        if (!markovTransitionMatrix2ndOrder[state]) {
            markovTransitionMatrix2ndOrder[state] = Array(10).fill(0);
        }
        markovTransitionMatrix2ndOrder[state][currentDigit]++;
    }
    
    if (digitHistory.length % 50 === 0) {
        localStorage.setItem('markov_matrix_v11', JSON.stringify(markovTransitionMatrix));
        localStorage.setItem('markov_matrix_2nd_v11', JSON.stringify(markovTransitionMatrix2ndOrder));
    }
}

function calculateMarkovPrediction() {
    let prediction = 50;
    
    if (digitHistory.length >= 2) {
        const state = `${digitHistory[1]}-${digitHistory[0]}`;
        if (markovTransitionMatrix2ndOrder[state]) {
            const transitions = markovTransitionMatrix2ndOrder[state];
            const totalTransitions = transitions.reduce((a, b) => a + b, 0);
            
            if (totalTransitions > 0) {
                const smoothedTransitions = transitions.map(t => t + 1);
                const smoothedTotal = smoothedTransitions.reduce((a, b) => a + b, 0);
                const over5Transitions = smoothedTransitions.slice(6, 10).reduce((a, b) => a + b, 0);
                prediction = (over5Transitions / smoothedTotal) * 100;
                return prediction;
            }
        }
    }
    
    if (digitHistory.length >= 1 && markovTransitionMatrix[digitHistory[0]]) {
        const transitions = markovTransitionMatrix[digitHistory[0]];
        const totalTransitions = transitions.reduce((a, b) => a + b, 0);
        
        if (totalTransitions > 0) {
            const smoothedTransitions = transitions.map(t => t + 1);
            const smoothedTotal = smoothedTransitions.reduce((a, b) => a + b, 0);
            const over5Transitions = smoothedTransitions.slice(6, 10).reduce((a, b) => a + b, 0);
            prediction = (over5Transitions / smoothedTotal) * 100;
        }
    }
    
    return prediction;
}

function levenshtein(a, b) {
    const matrix = Array(a.length + 1).fill(null).map(() => Array(b.length + 1).fill(0));
    
    for (let i = 0; i <= a.length; i++) matrix[i][0] = i;
    for (let j = 0; j <= b.length; j++) matrix[0][j] = j;
    
    for (let i = 1; i <= a.length; i++) {
        for (let j = 1; j <= b.length; j++) {
            const cost = a[i - 1] === b[j - 1] ? 0 : 1;
            matrix[i][j] = Math.min(
                matrix[i - 1][j] + 1,
                matrix[i][j - 1] + 1,
                matrix[i - 1][j - 1] + cost
            );
        }
    }
    
    return matrix[a.length][b.length];
}

// ============ ENHANCED PATTERN DETECTION v4 (WITH FUZZY MATCHING + FREQUENT PATTERN MINING) ============
function detectPatterns() {
    if (digitHistory.length < MIN_HISTORY_FOR_PATTERNS) return null;
    
    patternDecayTimer++;
    
    if (patternDecayTimer >= 100) {
        patternDecayTimer = 0;
        for (const key in patternCache) {
            if (patternCache[key].count > 0) {
                patternCache[key].count = Math.floor(patternCache[key].count * 0.5);
                if (patternCache[key].count < 1) {
                    delete patternCache[key];
                }
            }
        }
    }
    
    // Use longer patterns (6-15) as recommended
    for (let len = MIN_PATTERN_LENGTH; len <= Math.min(15, digitHistory.length); len++) {
        const pattern = digitHistory.slice(0, len);
        const patternStr = pattern.join(',');
        const cacheKey = `pattern_${len}_${patternStr}`;
        
        if (patternCache[cacheKey]) {
            patternCache[cacheKey].count++;
            patternCache[cacheKey].lastSeen = Date.now();
        } else {
            patternCache[cacheKey] = { count: 1, lastSeen: Date.now() };
        }
        
        if (patternCache[cacheKey].count < MIN_PATTERN_OCCURRENCES) {
            continue;
        }
        
        for (let i = len; i <= digitHistory.length - len; i++) {
            const comparePattern = digitHistory.slice(i, i + len);
            
            // Use DTW for better matching
            const dtwDist = dtwDistance(pattern, comparePattern);
            const maxDistance = len * 2; // Adaptive threshold
            
            if (dtwDist <= maxDistance) {
                if (i + len < digitHistory.length) {
                    const nextDigit = digitHistory[i + len];
                    const isNextOver5 = nextDigit > 5;
                    
                    // Enhanced confidence calculation
                    const baseConf = 55;
                    const lengthBonus = len * 3;
                    const occurrenceBonus = (patternCache[cacheKey]?.count || 0) * 2;
                    const distancePenalty = (dtwDist / maxDistance) * 10;
                    
                    const confidence = Math.min(95, baseConf + lengthBonus + occurrenceBonus - distancePenalty);
                    
                    return {
                        pattern: patternStr,
                        nextDigit: nextDigit,
                        nextDigitClass: isNextOver5 ? 'OVER' : 'UNDER',
                        confidence: confidence,
                        fuzzy: dtwDist > 0,
                        distance: dtwDist.toFixed(2),
                        occurrences: patternCache[cacheKey].count,
                        method: 'DTW'
                    };
                }
            }
        }
    }
    
    return null;
}

function calculateAdaptiveThreshold() {
    if (recentWinRates.length < 5) return 0;
    
    const recentAvg = recentWinRates.slice(-10).reduce((a, b) => a + b, 0) / Math.min(10, recentWinRates.length);
    
    if (recentAvg < 0.40) {
        return 15;
    } else if (recentAvg < 0.45) {
        return 10;
    } else if (recentAvg > 0.65) {
        return -8;
    } else if (recentAvg > 0.60) {
        return -5;
    }
    return 0;
}

// ============ NEW v4: ENHANCED ENSEMBLE WITH PSF + LSTM ============
function calculateEnsemblePrediction(heuristicConf, bayesianProb, markovProb, psfProb, lstmProb, volatility) {
    // Dynamic weights based on model performance
    let weights = {
        heuristic: 0.25,
        bayesian: 0.20,
        markov: 0.20,
        psf: 0.20,
        lstm: 0.15
    };
    
    const totalAccuracy = modelAccuracies.heuristic + modelAccuracies.bayesian + 
                          modelAccuracies.markov + modelAccuracies.psf + modelAccuracies.lstm;
    
    // Adjust weights based on model performance
    if (totalAccuracy > 0) {
        const heuristicWeight = (modelAccuracies.heuristic / totalAccuracy) * 0.5;
        const bayesianWeight = (modelAccuracies.bayesian / totalAccuracy) * 0.5;
        const markovWeight = (modelAccuracies.markov / totalAccuracy) * 0.5;
        const psfWeight = (modelAccuracies.psf / totalAccuracy) * 0.5;
        const lstmWeight = (modelAccuracies.lstm / totalAccuracy) * 0.5;
        
        weights.heuristic = 0.20 + heuristicWeight * 0.2;
        weights.bayesian = 0.15 + bayesianWeight * 0.2;
        weights.markov = 0.15 + markovWeight * 0.2;
        weights.psf = 0.20 + psfWeight * 0.2;
        weights.lstm = 0.15 + lstmWeight * 0.2;
    }
    
    // Adjust for volatility - favor Bayesian and LSTM in high volatility
    if (volatility > 3.0) {
        weights.bayesian += 0.10;
        weights.lstm += 0.10;
        weights.heuristic -= 0.10;
        weights.markov -= 0.05;
        weights.psf -= 0.05;
    } else if (volatility > 2.5) {
        weights.bayesian += 0.05;
        weights.lstm += 0.05;
        weights.heuristic -= 0.05;
        weights.markov -= 0.025;
        weights.psf -= 0.025;
    }
    
    // Pattern bonus from enhanced detection
    const pattern = detectPatterns();
    let patternBonus = 0;
    if (pattern) {
        patternBonus = pattern.fuzzy ? 3 : 5;
        if (pattern.confidence > 70) patternBonus += 5;
        if (pattern.occurrences > 5) patternBonus += 3;
    }
    
    // Calculate weighted ensemble
    const ensemble = (
        heuristicConf * weights.heuristic +
        bayesianProb * weights.bayesian +
        markovProb * weights.markov +
        psfProb * weights.psf +
        lstmProb * weights.lstm +
        patternBonus
    );
    
    return Math.min(98, Math.max(0, ensemble));
}

function updateModelAccuracies(actualResult) {
    const isOver5 = actualResult > 5;
    
    // Update heuristic accuracy
    if (modelPredictions.heuristic.length > 0) {
        const lastHeuristic = modelPredictions.heuristic[modelPredictions.heuristic.length - 1];
        const heuristicCorrect = (lastHeuristic.prediction === 'OVER 5' && isOver5) || 
                                  (lastHeuristic.prediction === 'WAIT' && !isOver5) ||
                                  (lastHeuristic.prediction !== 'OVER 5' && !isOver5);
        
        modelPredictions.heuristic.push({ correct: heuristicCorrect });
        if (modelPredictions.heuristic.length > 50) modelPredictions.heuristic.shift();
        
        const correctCount = modelPredictions.heuristic.filter(p => p.correct).length;
        modelAccuracies.heuristic = (correctCount / modelPredictions.heuristic.length) * 100;
    }
    
    // Update Bayesian accuracy
    if (modelPredictions.bayesian.length > 0) {
        const lastBayesian = modelPredictions.bayesian[modelPredictions.bayesian.length - 1];
        const bayesianCorrect = (lastBayesian.prediction > 50 && isOver5) || 
                                 (lastBayesian.prediction <= 50 && !isOver5);
        
        modelPredictions.bayesian.push({ correct: bayesianCorrect });
        if (modelPredictions.bayesian.length > 50) modelPredictions.bayesian.shift();
        
        const correctCount = modelPredictions.bayesian.filter(p => p.correct).length;
        modelAccuracies.bayesian = (correctCount / modelPredictions.bayesian.length) * 100;
    }
    
    // Update Markov accuracy
    if (modelPredictions.markov.length > 0) {
        const lastMarkov = modelPredictions.markov[modelPredictions.markov.length - 1];
        const markovCorrect = (lastMarkov.prediction > 50 && isOver5) || 
                               (lastMarkov.prediction <= 50 && !isOver5);
        
        modelPredictions.markov.push({ correct: markovCorrect });
        if (modelPredictions.markov.length > 50) modelPredictions.markov.shift();
        
        const correctCount = modelPredictions.markov.filter(p => p.correct).length;
        modelAccuracies.markov = (correctCount / modelPredictions.markov.length) * 100;
    }
    
    // Update PSF accuracy
    if (modelPredictions.psf.length > 0) {
        const lastPSF = modelPredictions.psf[modelPredictions.psf.length - 1];
        const psfCorrect = (lastPSF.prediction > 50 && isOver5) || 
                            (lastPSF.prediction <= 50 && !isOver5);
        
        modelPredictions.psf.push({ correct: psfCorrect });
        if (modelPredictions.psf.length > 50) modelPredictions.psf.shift();
        
        const correctCount = modelPredictions.psf.filter(p => p.correct).length;
        modelAccuracies.psf = (correctCount / modelPredictions.psf.length) * 100;
    }
    
    // Update LSTM accuracy
    if (modelPredictions.lstm.length > 0) {
        const lastLSTM = modelPredictions.lstm[modelPredictions.lstm.length - 1];
        const lstmCorrect = (lastLSTM.prediction > 50 && isOver5) || 
                             (lastLSTM.prediction <= 50 && !isOver5);
        
        modelPredictions.lstm.push({ correct: lstmCorrect });
        if (modelPredictions.lstm.length > 50) modelPredictions.lstm.shift();
        
        const correctCount = modelPredictions.lstm.filter(p => p.correct).length;
        modelAccuracies.lstm = (correctCount / modelPredictions.lstm.length) * 100;
    }
    
    updateModelPerformanceUI();
}

function updateModelPerformanceUI() {
    const heuristicEl = document.getElementById('heuristicPerf');
    const bayesianEl = document.getElementById('bayesianPerf');
    const markovEl = document.getElementById('markovPerf');
    const psfEl = document.getElementById('psfPerf');
    const lstmEl = document.getElementById('lstmPerf');
    
    if (modelAccuracies.heuristic > 0) {
        heuristicEl.innerHTML = `<span style="opacity:0.6">Heuristic</span><b style="color:#22c55e">${modelAccuracies.heuristic.toFixed(0)}%</b>`;
        heuristicEl.className = modelAccuracies.heuristic >= 55 ? 'model-perf-high' : (modelAccuracies.heuristic < 45 ? 'model-perf-low' : '');
    }
    
    if (modelAccuracies.bayesian > 0) {
        bayesianEl.innerHTML = `<span style="opacity:0.6">Bayesian</span><b style="color:#8b5cf6">${modelAccuracies.bayesian.toFixed(0)}%</b>`;
        bayesianEl.className = modelAccuracies.bayesian >= 55 ? 'model-perf-high' : (modelAccuracies.bayesian < 45 ? 'model-perf-low' : '');
    }
    
    if (modelAccuracies.markov > 0) {
        markovEl.innerHTML = `<span style="opacity:0.6">Markov</span><b style="color:#3b82f6">${modelAccuracies.markov.toFixed(0)}%</b>`;
        markovEl.className = modelAccuracies.markov >= 55 ? 'model-perf-high' : (modelAccuracies.markov < 45 ? 'model-perf-low' : '');
    }
    
    if (modelAccuracies.psf > 0) {
        psfEl.innerHTML = `<span style="opacity:0.6">PSF</span><b style="color:#f59e0b">${modelAccuracies.psf.toFixed(0)}%</b>`;
        psfEl.className = modelAccuracies.psf >= 55 ? 'model-perf-high' : (modelAccuracies.psf < 45 ? 'model-perf-low' : '');
    }
    
    if (modelAccuracies.lstm > 0) {
        lstmEl.innerHTML = `<span style="opacity:0.6">LSTM</span><b style="color:#ec4899">${modelAccuracies.lstm.toFixed(0)}%</b>`;
        lstmEl.className = modelAccuracies.lstm >= 55 ? 'model-perf-high' : (modelAccuracies.lstm < 45 ? 'model-perf-low' : '');
    }
}

// ============ DIGIT ANALYZER ============
function addDigitToAnalyzer(digit) {
  digit = smoothOutliers(digit, digitHistory);
  
  digitHistory.unshift(digit);
  if (digitHistory.length > 100) digitHistory.pop();
  
  extendedHistory.unshift(digit);
  if (extendedHistory.length > 5000) extendedHistory.pop();
  
  if (extendedHistory.length % 100 === 0) {
    localStorage.setItem('extended_history_v11', JSON.stringify(extendedHistory));
  }
  
  const isOver5 = digit > 5;
  updateBayesianModel(isOver5);
  updateMarkovModel(digit);
  
  if (digitHistory.length > 1) {
    updateModelAccuracies(digit);
  }
  
  volatilityWindow.unshift(digit);
  if (volatilityWindow.length > 100) volatilityWindow.pop();
  
  updateDigitStatisticsDisplay();
  evaluateMarketZone();
  
  updateAnalyzerDisplay();
  if (isAutoRunning && !isCycleCooldown) checkAndAutoTrade();
}

function checkAndAutoTrade() {
    if (currentContractId !== null) return;
    
    const zone = evaluateMarketZone();
    if (zone === 'danger') {
        addLog("‚ö†Ô∏è DANGER ZONE - Skipping trade", "warn");
        return;
    }
    
    if (currentConfidenceMode === 'pattern') {
        const now = Date.now();
        const cooldownMs = parseInt(document.getElementById('cooldown').value) * 1000;
        if (now - lastTradeTime < Math.max(cooldownMs, 1000)) return;
        
        if (detectedPattern && detectedPattern.nextDigit !== null && detectedPattern.nextDigit !== undefined) {
            const targetDigits = [
                parseInt(document.getElementById('pattern1').value),
                parseInt(document.getElementById('pattern2').value),
                parseInt(document.getElementById('pattern3').value),
                parseInt(document.getElementById('pattern4').value),
                parseInt(document.getElementById('pattern5').value)
            ];
            
            if (targetDigits.includes(detectedPattern.nextDigit)) {
                const maxNextLikely = parseInt(document.getElementById('patternEnsembleMax').value) || 0;
                const minNextLikely = parseInt(document.getElementById('patternEnsembleMin').value) || 0;
                const currentNextLikely = Math.round(detectedPattern.confidence);
                
                let activeFilters = 0;
                if (maxNextLikely > 0) activeFilters++;
                if (minNextLikely > 0) activeFilters++;
                if (isSpecificEnsembleActive) activeFilters++;
                
                if (activeFilters > 1) {
                    addLog(`Pattern Match! But CONFLICT: Multiple filters active (${activeFilters}). Only ONE allowed!`, "error");
                    return;
                }
                
                if (activeFilters === 0) {
                    addLog(`Pattern Match! Next Likely: ${detectedPattern.nextDigit} (${currentNextLikely}%) | Occ: ${detectedPattern.occurrences} - Trading NOW!`, "success");
                    lastTradeTime = now;
                    placeTrade();
                    return;
                }
                
                if (maxNextLikely > 0) {
                    if (currentNextLikely <= maxNextLikely) {
                        addLog(`Pattern Match! Next Likely: ${detectedPattern.nextDigit} (${currentNextLikely}%) ‚â§ ${maxNextLikely}% ‚úì | Occ: ${detectedPattern.occurrences} - Trading NOW!`, "success");
                        lastTradeTime = now;
                        placeTrade();
                    } else {
                        addLog(`Pattern Match! Next Likely: ${detectedPattern.nextDigit} (${currentNextLikely}%) > ${maxNextLikely}% ‚úó - SKIPPED (too high)`, "warn");
                    }
                    return;
                }
                
                if (minNextLikely > 0) {
                    if (currentNextLikely >= minNextLikely) {
                        addLog(`Pattern Match! Next Likely: ${detectedPattern.nextDigit} (${currentNextLikely}%) ‚â• ${minNextLikely}% ‚úì | Occ: ${detectedPattern.occurrences} - Trading NOW!`, "success");
                        lastTradeTime = now;
                        placeTrade();
                    } else {
                        addLog(`Pattern Match! Next Likely: ${detectedPattern.nextDigit} (${currentNextLikely}%) < ${minNextLikely}% ‚úó - SKIPPED (too low)`, "warn");
                    }
                    return;
                }
                
                if (isSpecificEnsembleActive) {
                    const specificTargets = [
                        parseInt(document.getElementById('specEns1').value),
                        parseInt(document.getElementById('specEns2').value),
                        parseInt(document.getElementById('specEns3').value),
                        parseInt(document.getElementById('specEns4').value),
                        parseInt(document.getElementById('specEns5').value)
                    ].filter(v => !isNaN(v) && v >= 0 && v <= 100);
                    
                    if (specificTargets.includes(currentNextLikely)) {
                        addLog(`Pattern Match! Next Likely: ${detectedPattern.nextDigit} (${currentNextLikely}%) = Target ‚úì | Occ: ${detectedPattern.occurrences} - Trading NOW!`, "success");
                        lastTradeTime = now;
                        placeTrade();
                    } else {
                        addLog(`Pattern Match! Next Likely: ${detectedPattern.nextDigit} (${currentNextLikely}%) ‚â† Targets [${specificTargets.join(',')}] ‚úó - SKIPPED`, "warn");
                    }
                    return;
                }
            }
        }
        return;
    }
    
    if (!isSignalWindowOpen) return;

    const now = Date.now();
    const cooldownMs = parseInt(document.getElementById('cooldown').value) * 1000;
    if (now - lastTradeTime < Math.max(cooldownMs, 1000)) return;

    const mode = currentConfidenceMode;
    let isConfidenceMet = false;
    const currentConf = Math.round(lastPredictionConfidence);
    const prevConf = Math.round(previousPredictionConfidence);

    if (mode === 'range') {
        let minConf = parseFloat(document.getElementById('minConfidence').value);
        let maxConf = parseFloat(document.getElementById('maxConfidence').value);
        
        const adjustment = calculateAdaptiveThreshold();
        minConf += adjustment;
        
        if (currentConf >= minConf && currentConf <= maxConf) isConfidenceMet = true;
    } 
    else if (mode === 'specific') {
        const targets = [
            parseInt(document.getElementById('spec1').value),
            parseInt(document.getElementById('spec2').value),
            parseInt(document.getElementById('spec3').value),
            parseInt(document.getElementById('spec4').value),
            parseInt(document.getElementById('spec5').value)
        ];
        if (targets.includes(currentConf)) isConfidenceMet = true;
    }
    else if (mode === 'sequence') {
        const s1_p1 = parseInt(document.getElementById('s1_p1_min').value);
        const s1_p2_min = parseInt(document.getElementById('s1_p2_min').value);
        const s1_p2_max = parseInt(document.getElementById('s1_p2_max').value);
        
        const s2_p1 = parseInt(document.getElementById('s2_p1_min').value);
        const s2_p2_min = parseInt(document.getElementById('s2_p2_min').value);
        const s2_p2_max = parseInt(document.getElementById('s2_p2_max').value);

        const s3_p1 = parseInt(document.getElementById('s3_p1_min').value);
        const s3_p2_min = parseInt(document.getElementById('s3_p2_min').value);
        const s3_p2_max = parseInt(document.getElementById('s3_p2_max').value);

        const match1 = (prevConf >= s1_p1 && currentConf >= s1_p2_min && currentConf <= s1_p2_max);
        const match2 = (prevConf >= s2_p1 && currentConf >= s2_p2_min && currentConf <= s2_p2_max);
        const match3 = (prevConf >= s3_p1 && currentConf >= s3_p2_min && currentConf <= s3_p2_max);

        if (match1 || match2 || match3) isConfidenceMet = true;
    }

    if (lastPredictionType === 'OVER 5' && isConfidenceMet) {
        lastTradeTime = now;
        placeTrade();
    }
}

function updateAnalyzerDisplay() {
  const container = document.getElementById('digitDisplay');
  container.innerHTML = '';
  const displayLimit = Math.min(50, digitHistory.length);
  
  for (let i = 0; i < displayLimit; i++) {
    const digit = digitHistory[i];
    const box = document.createElement('div');
    box.className = 'digit-box ' + (digit > 5 ? 'digit-over' : 'digit-under');
    box.textContent = digit;
    container.appendChild(box);
  }
  
  const overCount = digitHistory.filter(d => d > 5).length;
  document.getElementById('overCount').textContent = overCount;
  document.getElementById('totalCount').textContent = digitHistory.length;
  document.getElementById('overPercent').textContent = (digitHistory.length > 0 ? ((overCount / digitHistory.length) * 100).toFixed(1) : 0) + '%';
  
  predictNextDigit();
}

function predictNextDigit() {
  if (digitHistory.length < 20) {
    document.getElementById('patternMatch').textContent = 'Collecting data... need 20+ ticks';
    detectedPattern = null;
    return;
  }
  
  previousPredictionConfidence = lastPredictionConfidence;

  const last20 = digitHistory.slice(0, 20);
  let weightedUnderScore = 0;
  last20.forEach((digit, index) => {
      const weight = (20 - index) / 20; 
      if (digit <= 5) weightedUnderScore += weight;
  });
  const weightedFreq = (weightedUnderScore / 10.5) * 100;
  
  const minStreak = parseInt(document.getElementById('minStreakCount').value) || 3;
  const maxStreak = parseInt(document.getElementById('maxStreakCount').value) || 7;
  
  let overGap = 0;
  for (let d of digitHistory) {
      if (d <= 5) overGap++;
      else break;
  }
  
  const volatility = calculateVolatility(volatilityWindow, 50);
  const maxVolThreshold = parseFloat(document.getElementById('maxVolatilityThreshold').value) || 2.5;
  
  let volatilityLabel = 'Low';
  let volatilityPenalty = 0;
  
  if (volatility > 3.0) {
      volatilityLabel = 'Extreme';
      volatilityPenalty = -20;
  } else if (volatility > maxVolThreshold) {
      volatilityLabel = 'High';
      volatilityPenalty = -15;
  } else if (volatility > 1.8) {
      volatilityLabel = 'Medium';
      volatilityPenalty = -5;
  }
  
  document.getElementById('volatilityScore').textContent = volatilityLabel;
  
  let gravityBonus = 0;
  let trendLabel = 'Stable';
  if (digitHistory.length >= 3) {
      if (digitHistory[0] > digitHistory[1] && digitHistory[1] > digitHistory[2]) {
          gravityBonus = 15;
          trendLabel = 'Rising';
      } else if (digitHistory[0] < digitHistory[1] && digitHistory[1] < digitHistory[2]) {
          gravityBonus = -10;
          trendLabel = 'Falling';
      } else if (digitHistory.length >= 4) {
          const diff1 = Math.abs(digitHistory[0] - digitHistory[1]);
          const diff2 = Math.abs(digitHistory[2] - digitHistory[3]);
          if (diff1 > diff2 * 1.5) {
              gravityBonus += 8;
              trendLabel = 'Engulfing';
          }
      }
  }
  
  // Bayesian
  const bayesianProb = updateBayesianModel(digitHistory[0] > 5);
  document.getElementById('bayesianProb').textContent = bayesianProb.toFixed(0) + '%';
  
  // Markov
  const markovProb = calculateMarkovPrediction();
  document.getElementById('markovProb').textContent = markovProb.toFixed(0) + '%';
  
  // PSF (NEW v4)
  const psfResult = calculatePSFPrediction();
  document.getElementById('psfProb').textContent = psfResult.prediction.toFixed(0) + '%';
  
  // LSTM (NEW v4)
  const lstmResult = calculateLSTMPrediction();
  document.getElementById('lstmProb').textContent = lstmResult.prediction.toFixed(0) + '%';
  
  const percentages = calculateDigitPercentages();
  const minDigit69 = parseFloat(document.getElementById('minDigit69Percent').value) || 54;
  const rsi = calculateRSI(digitHistory, 14);
  
  let heuristicConf = 0;
  let predText = 'WAIT';
  
  if (overGap >= minStreak && overGap <= maxStreak) {
      predText = 'OVER 5';
      heuristicConf = 40 + (overGap * 9) + (weightedFreq * 0.1) + gravityBonus + volatilityPenalty;
      
      if (percentages.digit69 >= minDigit69) {
          heuristicConf += 10;
          addLog(`Digit 6-9% (${percentages.digit69.toFixed(1)}%) >= threshold (${minDigit69}%) - Bonus applied`, "info");
      }
      
      if (rsi < 30) {
          heuristicConf += 10;
          addLog(`RSI (${rsi}) oversold - Potential rebound bonus applied`, "info");
      }
      
      if (percentages.even > 60 && overGap >= minStreak) {
          heuristicConf += 5;
          addLog(`Even bias detected (${percentages.even.toFixed(1)}%) - Bonus for digits 6,8`, "info");
      }
      
  } else if (overGap > maxStreak) {
      addLog(`Streak (${overGap}) exceeds max cap (${maxStreak}) - Skipping to avoid overconfidence`, "warn");
  } else if (weightedFreq > 70) {
      predText = 'OVER 5';
      heuristicConf = 45 + (weightedFreq - 70) + gravityBonus + volatilityPenalty;
      
      if (percentages.digit69 >= minDigit69) {
          heuristicConf += 10;
      }
  }
  
  if (volatility > maxVolThreshold) {
      addLog(`High volatility (${volatility.toFixed(2)} > ${maxVolThreshold}) - Reducing confidence`, "warn");
  }
  
  // Store predictions for accuracy tracking
  modelPredictions.heuristic.push({ prediction: predText });
  modelPredictions.bayesian.push({ prediction: bayesianProb });
  modelPredictions.markov.push({ prediction: markovProb });
  modelPredictions.psf.push({ prediction: psfResult.prediction });
  modelPredictions.lstm.push({ prediction: lstmResult.prediction });
  
  // Calculate ensemble with all 5 models
  const ensembleScore = calculateEnsemblePrediction(
      Math.max(0, heuristicConf), 
      bayesianProb, 
      markovProb,
      psfResult.prediction,
      lstmResult.prediction,
      volatility
  );
  
  document.getElementById('ensembleScore').textContent = ensembleScore.toFixed(0) + '%';
  
  lastPredictionConfidence = Math.min(98, Math.max(0, ensembleScore));
  lastPredictionType = predText;
  
  const confAdj = calculateAdaptiveThreshold();
  document.getElementById('confAdj').textContent = (confAdj >= 0 ? '+' : '') + confAdj + '%';
  
  document.getElementById('nextDigitPrediction').textContent = predText;
  document.getElementById('nextDigitPrediction').style.color = predText === 'OVER 5' ? '#22c55e' : '#f59e0b';
  document.getElementById('predictionConfidence').textContent = `${lastPredictionConfidence.toFixed(0)}% (Ensemble) | ${trendLabel}`;
  document.getElementById('freqScore').textContent = weightedFreq.toFixed(0) + '%';
  document.getElementById('cycleScore').textContent = overGap;
  
  // Enhanced pattern detection
  const pattern = detectPatterns();
  detectedPattern = pattern;
  
  if (pattern) {
      const fuzzyText = pattern.fuzzy ? ` (${pattern.method}, dist=${pattern.distance})` : '';
      const occText = ` [${pattern.occurrences}x seen]`;
      const classText = ` | Class: ${pattern.nextDigitClass}`;
      document.getElementById('patternMatch').textContent = `Pattern: [${pattern.pattern}]${fuzzyText}${occText}${classText} ‚Üí Next likely: ${pattern.nextDigit} (${pattern.confidence.toFixed(0)}%)`;
  } else {
      document.getElementById('patternMatch').textContent = `No high-confidence patterns (need ${MIN_PATTERN_OCCURRENCES}+ occurrences, len ${MIN_PATTERN_LENGTH}+). Using ML ensemble.`;
  }
}

// ============ TRADING FUNCTIONS ============
function placeTrade() {
  if (!isConnected || isCycleCooldown) return;
  
  const stakeValue = parseFloat(document.getElementById('stake').value);
  const tickValue = parseInt(document.getElementById('duration').value);
  const marketValue = currentMarketValue;
  const type = isReverseTradeActive ? 'DIGITUNDER' : 'DIGITOVER';
  
  if (isCurrentlyVirtualMode()) {
      addLog(`üéÆ VIRTUAL TRADE SIMULATED (Not placing real trade)`, "warn");
      
      setTimeout(() => {
          const simulatedWin = Math.random() > 0.5;
          const simulatedProfit = simulatedWin ? stakeValue * 0.95 : -stakeValue;
          
          handleVirtualTradeResult(simulatedWin);
          
          stats.trades++;
          if (simulatedWin) stats.wins++; else stats.losses++;
          stats.profit += simulatedProfit;
          
          recentWinRates.push(simulatedWin ? 1 : 0);
          if (recentWinRates.length > 20) recentWinRates.shift();
          
          updateStats();
          addToHistory(stats.trades, simulatedWin ? 'Win (Virtual)' : 'Loss (Virtual)', simulatedProfit, marketValue);
          
          addLog(`üéÆ VIRTUAL ${simulatedWin ? 'WIN' : 'LOSS'} | P/L: ${simulatedProfit.toFixed(2)}`, simulatedWin ? 'success' : 'error');
          
          localStorage.setItem('trade_stats_v11', JSON.stringify(stats));
          localStorage.setItem('trade_history_v11', document.getElementById('history').innerHTML);
          
          checkRiskManagement();
      }, 2000);
      
      return;
  }
  
  let confidenceMsg = '';
  if (currentConfidenceMode === 'pattern' && detectedPattern) {
      const maxNextLikely = parseInt(document.getElementById('patternEnsembleMax').value) || 0;
      const minNextLikely = parseInt(document.getElementById('patternEnsembleMin').value) || 0;
      const nextLikelyPercent = Math.round(detectedPattern.confidence);
      
      if (maxNextLikely === 0 && minNextLikely === 0 && !isSpecificEnsembleActive) {
          confidenceMsg = `Pattern: [${detectedPattern.pattern}] ‚Üí ${detectedPattern.nextDigit} (${nextLikelyPercent}%) | Occ: ${detectedPattern.occurrences} | Filters: OFF`;
      } else if (maxNextLikely > 0) {
          confidenceMsg = `Pattern: [${detectedPattern.pattern}] ‚Üí ${detectedPattern.nextDigit} | Next Likely: ${nextLikelyPercent}% ‚â§ ${maxNextLikely}% | Occ: ${detectedPattern.occurrences}`;
      } else if (minNextLikely > 0) {
          confidenceMsg = `Pattern: [${detectedPattern.pattern}] ‚Üí ${detectedPattern.nextDigit} | Next Likely: ${nextLikelyPercent}% ‚â• ${minNextLikely}% | Occ: ${detectedPattern.occurrences}`;
      } else if (isSpecificEnsembleActive) {
          confidenceMsg = `Pattern: [${detectedPattern.pattern}] ‚Üí ${detectedPattern.nextDigit} | Next Likely: ${nextLikelyPercent}% = Target | Occ: ${detectedPattern.occurrences}`;
      }
  } else {
      confidenceMsg = `${lastPredictionConfidence.toFixed(0)}% confidence (PSF+LSTM Enhanced)`;
  }
  
  addLog(`üî¥ LIVE: Executing ${type} trade with ${confidenceMsg}`, "info");
  
  sendAPIRequest({
    buy: 1, 
    price: stakeValue,
    parameters: { 
        contract_type: type, 
        symbol: marketValue, 
        duration: tickValue, 
        duration_unit: 't', 
        barrier: '5', 
        amount: stakeValue,
        basis: 'stake', 
        currency: 'USD' 
    }
  });
}

function toggleAuto() {
  if (!isConnected) return;
  isAutoRunning = !isAutoRunning;
  const btn = document.getElementById('autoBtn');
  const shutdownUI = document.getElementById('shutdownDisplay');

  if (isAutoRunning) {
    autoStartTime = Date.now();
    localStorage.setItem('isAutoRunning', 'true');
    localStorage.setItem('autoStartTime', autoStartTime);
    shutdownUI.style.display = 'block';
    addLog("ML Auto-Trade v4 Enabled (PSF + LSTM + DTW Enhanced).", "success");
    btn.textContent = 'Stop Auto'; btn.style.background = '#ef4444';
  } else {
    autoStartTime = null;
    localStorage.removeItem('isAutoRunning');
    localStorage.removeItem('autoStartTime');
    shutdownUI.style.display = 'none';
    addLog("Auto-Trade Stopped.", "warn");
    btn.textContent = 'Start Auto'; btn.style.background = '#22c55e';
  }
}

function toggleMarketCycle() {
    isMarketCycleActive = !isMarketCycleActive;
    const btn = document.getElementById('cycleBtn');
    if (isMarketCycleActive) {
        btn.classList.add('active');
        currentMarketIndex = marketSequence.indexOf(currentMarketValue);
        if(currentMarketIndex === -1) currentMarketIndex = 0;
        btn.textContent = `Auto Market Cycle: ON (${marketSequence[currentMarketIndex]})`;
        addLog(`Market Cycle Sequence Started at ${marketSequence[currentMarketIndex]}.`, "info");
    } else {
        btn.classList.remove('active');
        btn.textContent = "Auto Market Cycle: OFF";
        addLog(`Market Cycle Sequence Disabled.`, "warn");
    }
}

function toggleCooldownLoop() {
    isCooldownLoopActive = !isCooldownLoopActive;
    const btn = document.getElementById('cooldownBtn');
    if (isCooldownLoopActive) {
        btn.classList.add('active');
        btn.textContent = "Cycle Cooldown Loop: ON";
        addLog(`Cycle Cooldown Loop Enabled: Will wait after full sequence.`, "info");
    } else {
        btn.classList.remove('active');
        btn.textContent = "Cycle Cooldown Loop: OFF";
        addLog(`Cycle Cooldown Loop Disabled.`, "warn");
    }
}

function startCycleCooldown() {
    isCycleCooldown = true;
    let waitMinutes = parseInt(document.getElementById('cycleWaitTime').value);
    let secondsLeft = waitMinutes * 60;
    const timerDisplay = document.getElementById('cycleTimerDisplay');
    timerDisplay.style.display = 'block';
    addLog(`Sequence Complete. Cycle Cooldown Loop active: waiting ${waitMinutes}m...`, "warn");

    if (cycleTimerId) clearInterval(cycleTimerId);
    cycleTimerId = setInterval(() => {
        secondsLeft--;
        const mins = Math.floor(secondsLeft / 60);
        const secs = secondsLeft % 60;
        timerDisplay.textContent = `Next Loop in: ${mins.toString().padStart(2,'0')}:${secs.toString().padStart(2,'0')}`;

        if (secondsLeft <= 0) {
            clearInterval(cycleTimerId);
            isCycleCooldown = false;
            timerDisplay.style.display = 'none';
            currentMarketIndex = 0;
            const nextMarket = marketSequence[currentMarketIndex];
            currentMarketValue = nextMarket;
            selectMarket(nextMarket);
            document.getElementById('cycleBtn').textContent = `Auto Market Cycle: ON (${nextMarket})`;
            addLog(`Cooldown finished. Restarting Cycle at ${nextMarket}.`, "success");
            subscribeToTicks();
        }
    }, 1000);
}

function handleTradeResult(contract) {
  const isWin = contract.status === 'won';
  const profitLoss = parseFloat(contract.profit || 0);
  
  const tradeMode = isCurrentlyVirtualMode() ? "VIRTUAL" : "LIVE";
  addLog(`${tradeMode} RESULT: ${isWin ? 'WIN' : 'LOSS'} | P/L: ${profitLoss.toFixed(2)}`, isWin ? 'success' : 'error');
  
  handleVirtualTradeResult(isWin);
  
  stats.trades++; 
  if (isWin) stats.wins++; else stats.losses++; 
  stats.profit += profitLoss;
  
  recentWinRates.push(isWin ? 1 : 0);
  if (recentWinRates.length > 20) recentWinRates.shift();
  
  updateStats();
  
  const historyLabel = isCurrentlyVirtualMode() ? `${isWin ? 'Win' : 'Loss'} (Virtual)` : (isWin ? 'Win' : 'Loss');
  addToHistory(stats.trades, historyLabel, profitLoss, contract.display_name || 'Market');
  localStorage.setItem('trade_stats_v11', JSON.stringify(stats));
  localStorage.setItem('trade_history_v11', document.getElementById('history').innerHTML);

  const tp = parseFloat(document.getElementById('takeprofit').value);
  if (isMarketCycleActive && stats.profit >= tp) {
      if (currentMarketIndex < marketSequence.length - 1) {
          currentMarketIndex++;
          const nextMarket = marketSequence[currentMarketIndex];
          addLog(`Target reached! Switching Market: ${marketSequence[currentMarketIndex-1]} -> ${nextMarket}...`, "success");
          resetStats(); 
          currentMarketValue = nextMarket;
          selectMarket(nextMarket);
          document.getElementById('cycleBtn').textContent = `Auto Market Cycle: ON (${nextMarket})`;
          subscribeToTicks();
          return; 
      } else {
          addLog("Final Market Sequence Finished Successfully.", "success");
          resetStats();
          if (isCooldownLoopActive) {
              startCycleCooldown();
          } else {
              if (isAutoRunning) toggleAuto();
              isMarketCycleActive = false;
              document.getElementById('cycleBtn').classList.remove('active');
              document.getElementById('cycleBtn').textContent = "Auto Market Cycle: OFF";
          }
      }
  }
  checkRiskManagement();
}

function toggleReverseTrade() {
    isReverseTradeActive = !isReverseTradeActive;
    const btn = document.getElementById('reverseBtn');
    if (isReverseTradeActive) {
        btn.classList.add('active');
        btn.textContent = "Reverse Trade: ON (Digit Under 5)";
        addLog("Reverse Mode Activated: Now trading Digit Under 5", "warn");
    } else {
        btn.classList.remove('active');
        btn.textContent = "Reverse Trade: OFF";
        addLog("Normal Mode Activated: Now trading Digit Over 5", "info");
    }
}

// ============ API COMMUNICATION ============
function sendAPIRequest(data) { 
    if (ws && ws.readyState === WebSocket.OPEN) { 
        const now = Date.now();
        if (now - lastRequestTime < 300) {
            setTimeout(() => sendAPIRequest(data), 300);
            return false;
        }
        lastRequestTime = now;
        ws.send(JSON.stringify(data)); 
        return true; 
    } 
    return false; 
}

function subscribeToTicks() {
  const market = currentMarketValue;
  sendAPIRequest({ forget_all: "ticks" });
  digitHistory = [];
  document.getElementById('digitDisplay').innerHTML = '';
  addLog(`Watching ${market}...`, "info");
  sendAPIRequest({ ticks: market, subscribe: 1 });
}

// ============ UI UPDATE FUNCTIONS ============
function updateStatus(text, className) { 
    const s = document.getElementById('status'); 
    s.textContent = text; 
    s.className = 'status ' + className; 
}

function updateBalance() { 
    document.getElementById('balanceDisplay').style.display = 'block'; 
    document.getElementById('balance').textContent = parseFloat(accountBalance).toFixed(2); 
}

function updateStats() {
  document.getElementById('trades').textContent = stats.trades;
  document.getElementById('wins').textContent = stats.wins;
  document.getElementById('losses').textContent = stats.losses;
  const p = document.getElementById('profit');
  p.textContent = stats.profit.toFixed(2);
  p.style.color = stats.profit > 0 ? '#22c55e' : (stats.profit < 0 ? '#ef4444' : '#e5e7eb');
}

function startSessionTimer() {
    if (timerIntervalId) clearInterval(timerIntervalId);
    sessionStartTime = Date.now(); 
    timerIntervalId = setInterval(() => {
        updateSignalWindowTimer();
        const now = Date.now();
        const s = Math.floor((now - sessionStartTime) / 1000);
        document.getElementById('sessionTimer').textContent = `Session: ${Math.floor(s/3600).toString().padStart(2,'0')}:${Math.floor((s%3600)/60).toString().padStart(2,'0')}:${(s%60).toString().padStart(2,'0')}`;
        
        if (isAutoRunning && autoStartTime) {
            const limitHours = parseFloat(document.getElementById('autoDurationHrs').value) || 0;
            if (limitHours <= 0) {
                document.getElementById('shutdownDisplay').textContent = `Shutdown in: Unlimited`;
                return;
            }
            const limitMs = limitHours * 3600000;
            const elapsedMs = now - autoStartTime;
            const remainingMs = limitMs - elapsedMs;
            if (remainingMs <= 0) {
                addLog("Trade Duration Elapsed. Auto-Shutdown triggered.", "warn");
                toggleAuto();
            } else {
                const remS = Math.floor(remainingMs / 1000);
                const h = Math.floor(remS / 3600).toString().padStart(2, '0');
                const m = Math.floor((remS % 3600) / 60).toString().padStart(2, '0');
                const sec = (remS % 60).toString().padStart(2, '0');
                document.getElementById('shutdownDisplay').textContent = `Shutdown in: ${h}:${m}:${sec}`;
            }
        }
    }, 1000);
}

function checkRiskManagement() {
  const sl = parseFloat(document.getElementById('stoploss').value);
  const tp = parseFloat(document.getElementById('takeprofit').value);
  
  if (stats.profit <= -sl) { 
    if (isAutoRunning) toggleAuto(); 
    addLog("Stop Loss Met. Trading stopped.", "error"); 
  }
  
  if (!isMarketCycleActive && stats.profit >= tp) {
    if (isAutoRunning) toggleAuto();
    addLog("Take Profit achieved! Trading stopped.", "success");
  }
}

function addToHistory(n, res, pl, m) {
  const row = document.getElementById('history').insertRow(0);
  const cls = res.includes('Win') ? 'win' : 'loss';
  row.innerHTML = `<td>${n}</td><td class="${cls}">${res}</td><td class="${cls}">${pl.toFixed(2)}</td><td>${m}</td>`;
}

function resetStats() { 
    stats = { trades: 0, wins: 0, losses: 0, profit: 0 }; 
    recentWinRates = [];
    
    virtualLossStreak = 0;
    hasSwatchedToLive = false;
    updateVirtualTradeUI();
    
    modelAccuracies = {
        heuristic: 0,
        bayesian: 0,
        markov: 0,
        psf: 0,
        lstm: 0
    };
    modelPredictions = {
        heuristic: [],
        bayesian: [],
        markov: [],
        psf: [],
        lstm: []
    };
    
    updateStats(); 
    updateModelPerformanceUI();
    document.getElementById('history').innerHTML = ''; 
    localStorage.removeItem('trade_stats_v11');
    localStorage.removeItem('trade_history_v11');
    addLog("All stats reset.", "info");
    
    saveSettings();
}

function manualTrade() { 
    if (isConnected) {
        placeTrade(); 
    } else {
        addLog("Not connected. Please login first.", "error");
    }
}

// ============ INITIALIZATION ============
window.onload = async () => {
  addLog("Initializing ML Enhanced Trading Bot v4 (PSF + LSTM + DTW)...", "info");
  loadSettings();
  
  // Try to load saved LSTM model
  await loadLSTMModel();
  
  const ensembleMaxInput = document.getElementById('patternEnsembleMax');
  const ensembleMinInput = document.getElementById('patternEnsembleMin');
  const specEnsInputs = ['specEns1', 'specEns2', 'specEns3', 'specEns4', 'specEns5'];
  
  if (ensembleMaxInput) {
      ensembleMaxInput.addEventListener('input', updateEnsembleFilterStatus);
      ensembleMaxInput.addEventListener('change', updateEnsembleFilterStatus);
  }
  
  if (ensembleMinInput) {
      ensembleMinInput.addEventListener('input', updateEnsembleFilterStatus);
      ensembleMinInput.addEventListener('change', updateEnsembleFilterStatus);
  }
  
  specEnsInputs.forEach(id => {
      const input = document.getElementById(id);
      if (input) {
          input.addEventListener('input', saveSettings);
          input.addEventListener('change', saveSettings);
      }
  });
  
  const virtualThresholdInput = document.getElementById('virtualLossThreshold');
  if (virtualThresholdInput) {
      virtualThresholdInput.addEventListener('input', () => {
          updateVirtualTradeUI();
          saveSettings();
      });
      virtualThresholdInput.addEventListener('change', () => {
          updateVirtualTradeUI();
          saveSettings();
      });
  }
  
  updateEnsembleFilterStatus();
  
  const savedToken = sessionStorage.getItem('derivToken');
  if (savedToken) { 
      document.getElementById('token').value = savedToken; 
      setTimeout(connect, 1000); 
  }
  
  addLog("‚úÖ ML v4 Enhancements Applied:", "success");
  addLog("- PSF (Pattern Sequence-Based Forecasting) with K-nearest neighbors", "info");
  addLog("- LSTM (Long Short-Term Memory) neural network for sequence prediction", "info");
  addLog("- DTW (Dynamic Time Warping) for fuzzy pattern matching", "info");
  addLog("- Enhanced pattern detection (length 6-15) with frequent pattern mining", "info");
  addLog("- Multi-step prediction with recurrence analysis", "info");
  addLog("- Data augmentation with noise injection for robust training", "info");
  addLog("- Dynamic ensemble weighting based on model performance", "info");
  addLog("- Exponential weighting for recent patterns", "info");
  addLog("- Adaptive confidence adjustments based on win rates", "info");
  addLog("- All original v3 features preserved (digit %, RSI, volatility, etc.)", "info");
  addLog("- üéÆ Virtual Trade Mode with auto-switch", "success");
  
  if (isLSTMTrained) {
      addLog("üß† LSTM model loaded and ready!", "success");
  } else {
      addLog("‚ö†Ô∏è No LSTM model found. Train it with the button above for enhanced predictions.", "warn");
  }
  
  addLog("Ready to trade with advanced ML algorithms!", "success");
};

document.getElementById('logoutBtn').addEventListener('click', () => { 
    isExplicitLogout = true; 
    localStorage.removeItem('isAutoRunning');
    localStorage.removeItem('autoStartTime');
    if (ws) ws.close(); 
    sessionStorage.removeItem('derivToken'); 
    addLog("Logging out...", "info");
    setTimeout(() => location.reload(), 500);
});
</script>
</body>
</html>