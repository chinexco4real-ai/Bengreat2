<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ben Scalper - Deriv Trading Bot</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            padding: 10px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: #0f1419;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            overflow: hidden;
            border: 1px solid #1f2937;
        }

        .header {
            background: linear-gradient(135deg, #1f2937 0%, #111827 100%);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            border-bottom: 2px solid #374151;
        }

        .header h1 {
            font-size: 24px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 15px;
            background: rgba(255,255,255,0.05);
            border-radius: 20px;
            font-size: 14px;
            transition: all 0.3s;
            border: 1px solid #374151;
        }

        .connection-status.reconnecting {
            background: rgba(255, 165, 0, 0.1);
            color: #fbbf24;
            border: 1px solid #fbbf24;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ef4444;
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: #10b981;
        }

        .status-dot.reconnecting {
            background: #fbbf24;
            animation: ping 1s cubic-bezier(0, 0, 0.2, 1) infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes ping {
            75%, 100% { transform: scale(2); opacity: 0; }
        }

        .main-content {
            padding: 20px;
        }

        .login-card {
            background: #1a1f2e;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            border: 1px solid #2d3748;
        }

        .login-card h2 {
            margin-bottom: 15px;
            color: #e2e8f0;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .login-form {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 15px;
            align-items: end;
        }

        .input-group {
            text-align: left;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            color: #cbd5e0;
            font-weight: 600;
            font-size: 14px;
        }

        .input-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #2d3748;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
            background: #0f1419;
            color: #e2e8f0;
        }

        .input-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .checkbox-group {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-top: 10px;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
        }

        .checkbox-group label {
            margin: 0;
            cursor: pointer;
            font-size: 14px;
            color: #cbd5e0;
        }

        /* Toggle Switch Styling */
        .toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 10px;
            background: #0f1419;
            border-radius: 8px;
            border: 1px solid #2d3748;
        }

        .toggle-label {
            font-size: 14px;
            font-weight: 600;
            color: #cbd5e0;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #4a5568;
            transition: .4s;
            border-radius: 20px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #667eea;
        }

        input:checked + .slider:before {
            transform: translateX(20px);
        }

        /* Radio Button Styling */
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .radio-option {
            display: flex;
            align-items: center;
            padding: 10px;
            background: #0f1419;
            border: 2px solid #2d3748;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .radio-option:hover {
            border-color: #667eea;
            background: #1a1f2e;
        }

        .radio-option input[type="radio"] {
            margin-right: 10px;
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #667eea;
        }

        .radio-option label {
            cursor: pointer;
            color: #cbd5e0;
            font-size: 14px;
            flex: 1;
        }

        .radio-option input[type="radio"]:checked + label {
            color: #667eea;
            font-weight: 600;
        }


        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .btn-sm {
            padding: 8px 15px;
            font-size: 13px;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-success {
            background: #10b981;
            color: white;
        }

        .btn-danger {
            background: #ef4444;
            color: white;
        }

        .btn-secondary {
            background: #4a5568;
            color: white;
        }

        .btn-warning {
            background: #f59e0b;
            color: white;
        }

        .btn-info {
            background: #3b82f6;
            color: white;
        }

        .account-info {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto auto;
            gap: 15px 30px;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .info-item {
            display: flex;
            flex-direction: column;
        }

        .info-item.right-align {
            align-items: flex-end;
            text-align: right;
        }

        .info-label {
            font-size: 12px;
            opacity: 0.8;
            margin-bottom: 2px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-value {
            font-size: 20px;
            font-weight: 700;
        }

        .grid-3 {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .card {
            background: #1a1f2e;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            height: 100%;
            border: 1px solid #2d3748;
        }

        .card h3 {
            margin-bottom: 15px;
            color: #e2e8f0;
            font-size: 18px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #cbd5e0;
            font-weight: 600;
            font-size: 14px;
        }

        .form-group select,
        .form-group input {
            width: 100%;
            padding: 10px;
            border: 2px solid #2d3748;
            border-radius: 6px;
            font-size: 14px;
            background: #0f1419;
            color: #e2e8f0;
        }

        .form-group select:focus,
        .form-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .control-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .control-buttons .btn {
            flex: 1;
            min-width: 150px;
            justify-content: center;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: #1a1f2e;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            border-left: 4px solid #667eea;
            border: 1px solid #2d3748;
            border-left: 4px solid #667eea;
        }

        .stat-label {
            font-size: 12px;
            color: #9ca3af;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #e2e8f0;
        }

        .stat-card.profit {
            border-left-color: #10b981;
        }

        .stat-card.loss {
            border-left-color: #ef4444;
        }

        .trade-signal-card {
            background: #1a1f2e;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            border: 3px solid #667eea;
        }

        .trade-signal-card h3 {
            margin-bottom: 15px;
            color: #e2e8f0;
            font-size: 18px;
        }

        .signal-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .signal-item {
            background: #0f1419;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #2d3748;
        }

        .signal-label {
            font-size: 14px;
            color: #9ca3af;
            margin-bottom: 8px;
        }

        .signal-value {
            font-size: 28px;
            font-weight: bold;
            color: #667eea;
        }

        .signal-status {
            margin-top: 15px;
            padding: 15px;
            background: rgba(16, 185, 129, 0.1);
            border-radius: 8px;
            border-left: 4px solid #10b981;
            font-size: 15px;
            font-weight: 600;
            color: #e2e8f0;
            line-height: 1.6;
        }

        .signal-status.no-signal {
            background: rgba(245, 158, 11, 0.1);
            border-left-color: #f59e0b;
            color: #fbbf24;
        }

        .signal-status.buy-signal {
            background: rgba(16, 185, 129, 0.1);
            border-left-color: #10b981;
            color: #6ee7b7;
        }

        .signal-status.sell-signal {
            background: rgba(239, 68, 68, 0.1);
            border-left-color: #ef4444;
            color: #fca5a5;
        }

        .indicator-status {
            background: #1a1f2e;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            border: 1px solid #2d3748;
        }

        .indicator-status h4 {
            margin-bottom: 10px;
            color: #e2e8f0;
        }

        .indicator-item {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            background: #0f1419;
            margin-bottom: 5px;
            border-radius: 5px;
            font-size: 14px;
            color: #cbd5e0;
            border: 1px solid #2d3748;
        }

        .indicator-value {
            font-weight: bold;
            color: #667eea;
        }

        .trade-history {
            background: #1a1f2e;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #2d3748;
        }

        .trade-history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .trade-history h3 {
            margin-bottom: 0;
            color: #e2e8f0;
        }

        .history-table {
            width: 100%;
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        table th {
            background: #111827;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }

        table td {
            padding: 12px;
            border-bottom: 1px solid #2d3748;
            color: #cbd5e0;
        }

        table tr:hover {
            background: #0f1419;
        }

        .result-win {
            color: #10b981;
            font-weight: bold;
        }

        .result-loss {
            color: #ef4444;
            font-weight: bold;
        }

        .log-panel {
            background: #0a0e14;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 10px;
            height: 250px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            border: 1px solid #2d3748;
            line-height: 1.6;
        }

        .log-entry {
            margin-bottom: 8px;
            padding: 6px;
            border-left: 3px solid #667eea;
            padding-left: 12px;
        }

        .log-entry.error {
            border-left-color: #ef4444;
            color: #fca5a5;
        }

        .log-entry.success {
            border-left-color: #10b981;
            color: #6ee7b7;
        }

        .log-entry.info {
            border-left-color: #3b82f6;
            color: #93c5fd;
        }

        .scroll-container {
            max-height: 380px; /* FIXED: Limits to ~10 rows visible, rest scrollable */
            overflow-y: auto;
            position: relative;
        }
        
        /* FIXED: Add fade effect at bottom to indicate more content */
        .scroll-container::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 30px;
            background: linear-gradient(to bottom, transparent, rgba(15, 20, 25, 0.95));
            pointer-events: none;
        }

        .scroll-container::-webkit-scrollbar,
        .log-panel::-webkit-scrollbar {
            width: 8px;
        }

        .scroll-container::-webkit-scrollbar-track,
        .log-panel::-webkit-scrollbar-track {
            background: #1a1f2e;
            border-radius: 10px;
        }

        .scroll-container::-webkit-scrollbar-thumb,
        .log-panel::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 10px;
        }

        .live-price {
            font-size: 16px;
            color: #10b981;
            font-weight: bold;
            margin-top: 5px;
        }

        /* Virtual Badge Styles */
        .virtual-badge {
            display: none;
            background: rgba(245, 158, 11, 0.1);
            color: #fbbf24;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            border: 1px solid #fbbf24;
            margin-left: 10px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Strategy Selector Styles */
        .strategy-card {
            background: #1a1f2e;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            border: 3px solid #10b981;
        }

        .strategy-card h3 {
            margin-bottom: 15px;
            color: #e2e8f0;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 8px;
            border-bottom: 2px solid #10b981;
            padding-bottom: 10px;
        }

        .strategy-description {
            background: #0f1419;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
            border-left: 4px solid #10b981;
            font-size: 13px;
            color: #cbd5e0;
            line-height: 1.6;
        }

        .strategy-description strong {
            color: #10b981;
            display: block;
            margin-top: 8px;
            margin-bottom: 4px;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 18px;
            }

            .grid-3 {
                grid-template-columns: 1fr;
            }

            .account-info {
                gap: 10px;
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .control-buttons {
                flex-direction: column;
            }

            .control-buttons .btn {
                width: 100%;
            }

            .login-form {
                grid-template-columns: 1fr;
            }

            .container {
                border-radius: 0;
            }

            table {
                font-size: 12px;
            }

            table th,
            table td {
                padding: 8px 4px;
            }

            .signal-content {
                grid-template-columns: 1fr;
            }

            .market-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 0;
            }

            .header {
                padding: 15px;
            }

            .main-content {
                padding: 10px;
            }

            .card {
                padding: 15px;
            }

            .stat-value {
                font-size: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>
                <span>üìä</span>
                Ben Scalper Bot
            </h1>
            <div class="header-controls">
                <div class="connection-status">
                    <div class="status-dot" id="statusDot"></div>
                    <span id="statusText">Disconnected</span>
                </div>
                <div id="virtualBadge" class="virtual-badge">
                    <span>üß™ Virtual Mode Active</span>
                </div>
                <button id="logoutBtn" class="btn btn-danger btn-sm" style="display: none;">Logout</button>
            </div>
        </div>

        <div class="main-content">
            <div id="topSection">
                <div class="login-card" id="loginCard">
                    <h2>üîê Deriv API Connection</h2>
                    <div class="login-form">
                        <div class="input-group">
                            <label>API Token</label>
                            <input type="password" id="apiToken" placeholder="Enter your Deriv API token">
                            <div class="checkbox-group">
                                <input type="checkbox" id="rememberToken">
                                <label for="rememberToken">Remember my token</label>
                            </div>
                        </div>
                        <button class="btn btn-primary" id="loginBtn">
                            <span>üöÄ</span> Connect
                        </button>
                    </div>
                    <div style="margin-top: 15px; font-size: 13px; color: #9ca3af;">
                        <a href="https://app.deriv.com/account/api-token" target="_blank" style="color: #667eea; text-decoration: none;">Get Token ‚Üí</a>
                    </div>
                </div>

                <div class="account-info" id="accountInfo" style="display: none;">
                    <div class="info-item">
                        <div class="info-label">Account Type</div>
                        <div class="info-value" id="accountType">-</div>
                    </div>
                    <div class="info-item right-align">
                        <div class="info-label">Balance</div>
                        <div class="info-value" id="accountBalance">0.00</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Currency</div>
                        <div class="info-value" id="accountCurrency">-</div>
                    </div>
                    <div class="info-item right-align">
                        <div class="info-label">Session Time</div>
                        <div class="info-value" id="sessionTimer">00:00:00</div>
                    </div>
                </div>
            </div>

            <!-- Strategy Selector Card -->
            <div class="strategy-card" id="strategyCard">
                <h3>üéØ Strategy Selector</h3>
                <div class="form-group">
                    <label>Select Trading Strategy</label>
                    <div class="radio-group">
                        <div class="radio-option">
                            <input type="radio" id="strategyBounce" name="strategy" value="bounce" checked>
                            <label for="strategyBounce">The Bounce Strategy</label>
                        </div>
                        <div class="radio-option">
                            <input type="radio" id="strategyBreakout" name="strategy" value="breakout">
                            <label for="strategyBreakout">The Breakout Strategy</label>
                        </div>
                    </div>
                </div>
                <div class="strategy-description" id="strategyDescription">
                    <strong>The Bounce Strategy - Trend Continuation (1m Candles)</strong><br>
                    <strong>BUY (Long):</strong> Uptrend - Price touches trendline support + Bullish candlestick pattern (Hammer, Bullish Engulfing)<br>
                    <strong>SELL (Short):</strong> Downtrend - Price touches trendline resistance + Bearish candlestick pattern (Shooting Star, Bearish Engulfing)
                </div>

                <!-- Timeframe Selector -->
                <div class="form-group" style="margin-top: 20px; padding-top: 20px; border-top: 2px solid #10b981;">
                    <label>Analysis Timeframe</label>
                    <div class="radio-group">
                        <div class="radio-option">
                            <input type="radio" id="timeframe1min" name="timeframe" value="1min" checked>
                            <label for="timeframe1min">1 Minute Candles</label>
                        </div>
                        <div class="radio-option">
                            <input type="radio" id="timeframe30sec" name="timeframe" value="30sec">
                            <label for="timeframe30sec">30 Second Candles</label>
                        </div>
                    </div>
                    <div style="font-size: 11px; color: #9ca3af; margin-top: 8px;">
                        Select which candle timeframe to use for strategy analysis
                    </div>
                </div>
            </div>


            <div class="grid-3" id="tradingSettings">
                <div class="card">
                    <h3>‚öôÔ∏è Trading Settings</h3>
                    <!-- Single Market Selection -->
                    <div class="form-group">
                        <label>Market</label>
                        <div class="radio-group" id="marketRadioGroup">
                            <div class="radio-option">
                                <input type="radio" id="market_R_10" name="market" value="R_10" checked>
                                <label for="market_R_10">Volatility 10 Index</label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="market_R_25" name="market" value="R_25">
                                <label for="market_R_25">Volatility 25 Index</label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="market_R_50" name="market" value="R_50">
                                <label for="market_R_50">Volatility 50 Index</label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="market_R_75" name="market" value="R_75">
                                <label for="market_R_75">Volatility 75 Index</label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="market_R_100" name="market" value="R_100">
                                <label for="market_R_100">Volatility 100 Index</label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="market_stpRNG" name="market" value="stpRNG">
                                <label for="market_stpRNG">Step Index 100</label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="market_stpRNG2" name="market" value="stpRNG2">
                                <label for="market_stpRNG2">Step Index 200</label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="market_stpRNG3" name="market" value="stpRNG3">
                                <label for="market_stpRNG3">Step Index 300</label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="market_stpRNG4" name="market" value="stpRNG4">
                                <label for="market_stpRNG4">Step Index 400</label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="market_stpRNG5" name="market" value="stpRNG5">
                                <label for="market_stpRNG5">Step Index 500</label>
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Stake Amount</label>
                        <input type="number" id="stakeAmount" value="1" min="0.35" step="0.01">
                    </div>
                    <div class="form-group">
                        <label>Duration Type</label>
                        <div class="radio-group">
                            <div class="radio-option">
                                <input type="radio" id="durationTicks" name="durationType" value="t" checked>
                                <label for="durationTicks">Ticks</label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="durationSeconds" name="durationType" value="s">
                                <label for="durationSeconds">Seconds</label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="durationMinutes" name="durationType" value="m">
                                <label for="durationMinutes">Minutes</label>
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Duration Value</label>
                        <input type="number" id="durationValue" value="10" min="1">
                    </div>
                    <div class="form-group">
                        <label>Cooldown Timer (seconds)</label>
                        <input type="number" id="cooldownTimer" value="30" min="1" step="1">
                    </div>
                    <div class="toggle-container">
                        <div class="toggle-label">Alternator Mode</div>
                        <label class="switch">
                            <input type="checkbox" id="alternatorMode">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div style="font-size: 11px; color: #9ca3af; margin-bottom: 10px;">
                        Alternates between Buy and Sell trades automatically.
                    </div>
                    <div class="toggle-container">
                        <div class="toggle-label">Reverse Mode</div>
                        <label class="switch">
                            <input type="checkbox" id="reverseMode">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div style="font-size: 11px; color: #9ca3af; margin-bottom: 10px;">
                        Reverses signals: Buy becomes Sell, Sell becomes Buy.
                    </div>
                    <div class="toggle-container">
                        <div class="toggle-label">One Entry Per Setup</div>
                        <label class="switch">
                            <input type="checkbox" id="oneEntryMode">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div style="font-size: 11px; color: #9ca3af;">
                        Allows only one trade per pattern/setup detection.
                    </div>
                </div>

                <div class="card">
                    <h3>üéØ Risk Management</h3>
                    <div class="form-group">
                        <label>Stop Loss ($)</label>
                        <input type="number" id="stopLoss" value="10" min="0" step="0.01">
                    </div>
                    <div class="form-group">
                        <label>Take Profit ($)</label>
                        <input type="number" id="takeProfit" value="20" min="0" step="0.01">
                    </div>
                    <div style="padding: 15px; background: rgba(16, 185, 129, 0.1); border-radius: 8px; margin-top: 15px; border: 1px solid #2d3748;">
                        <div style="font-size: 12px; color: #10b981; margin-bottom: 5px;">üí° Active Strategy</div>
                        <div style="font-size: 11px; color: #6ee7b7;" id="activeStrategyDisplay">The Bounce Strategy</div>
                    </div>
                </div>

                <!-- ===== ADVANCED FILTERS CARD (FINAL - with Live Summary) ===== -->
                <div class="card">
                    <h3>üõ°Ô∏è Advanced Filters</h3>
                    
                    <!-- Preset Buttons -->
                    <div style="display: flex; gap: 8px; margin-bottom: 18px; flex-wrap: wrap;">
                        <button onclick="applyFilterPreset('aggressive')" 
                                class="btn btn-warning btn-sm" 
                                style="flex: 1; min-width: 110px;">
                            ‚ö° Aggressive
                        </button>
                        <button onclick="applyFilterPreset('balanced')" 
                                class="btn btn-primary btn-sm" 
                                style="flex: 1; min-width: 110px;">
                            ‚öñÔ∏è Balanced
                        </button>
                        <button onclick="applyFilterPreset('conservative')" 
                                class="btn btn-success btn-sm" 
                                style="flex: 1; min-width: 110px;">
                            üõ°Ô∏è Conservative
                        </button>
                        <button onclick="applyFilterPreset('reset')" 
                                class="btn btn-secondary btn-sm" 
                                style="flex: 1; min-width: 110px;">
                            üîÑ Reset All
                        </button>
                    </div>

                    <div style="font-size: 12px; color: #9ca3af; margin-bottom: 15px;">
                        Presets are quick setups ‚Ä¢ All toggles remain fully independent
                    </div>

                    <!-- ADX Filter -->
                    <div class="toggle-container">
                        <div class="toggle-label">ADX Trend Strength <span style="color:#667eea;">(Best for Breakout)</span></div>
                        <label class="switch">
                            <input type="checkbox" id="filterADX">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div style="font-size: 11px; color: #9ca3af; margin-bottom: 12px;">
                        Requires ADX ‚â• 25 + DI difference ‚â• 7 + correct direction
                    </div>

                    <!-- RSI Filter -->
                    <div class="toggle-container">
                        <div class="toggle-label">RSI Overbought/Oversold Filter</div>
                        <label class="switch">
                            <input type="checkbox" id="filterRSI">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div style="font-size: 11px; color: #9ca3af; margin-bottom: 12px;">
                        Blocks BUY above 78, SELL below 22
                    </div>

                    <!-- Candle Body Filter -->
                    <div class="toggle-container">
                        <div class="toggle-label">Strong Candle Body Filter</div>
                        <label class="switch">
                            <input type="checkbox" id="filterCandleBody">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div style="font-size: 11px; color: #9ca3af; margin-bottom: 12px;">
                        Rejects candles where body < 65% of range
                    </div>

                    <!-- Volatility Contraction -->
                    <div class="toggle-container">
                        <div class="toggle-label">Volatility Contraction (Tight Range)</div>
                        <label class="switch">
                            <input type="checkbox" id="filterVolatility">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div style="font-size: 11px; color: #9ca3af; margin-bottom: 12px;">
                        Only breakouts from compressed ranges (very powerful)
                    </div>

                    <!-- Momentum Filter -->
                    <div class="toggle-container">
                        <div class="toggle-label">Strong Momentum Filter</div>
                        <label class="switch">
                            <input type="checkbox" id="filterMomentum">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div style="font-size: 11px; color: #9ca3af; margin-bottom: 12px;">
                        Requires price move ‚â• 0.6 √ó ATR
                    </div>

                    <!-- Smart Filter -->
                    <div class="toggle-container">
                        <div class="toggle-label">Smart Filter</div>
                        <label class="switch">
                            <input type="checkbox" id="filterSmart">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div style="font-size: 11px; color: #9ca3af; margin-bottom: 12px;">
                        Auto-toggles reverse mode on profit/loss targets. Starts with virtual trade.
                    </div>

                    <div class="form-group">
                        <label>Smart Target Profit ($)</label>
                        <input type="number" id="smartTargetProfit" value="5" min="0" step="0.01">
                    </div>
                    <div class="form-group">
                        <label>Smart Target Loss ($)</label>
                        <input type="number" id="smartTargetLoss" value="5" min="0" step="0.01">
                    </div>

                    <!-- ===== LIVE ACTIVE FILTERS SUMMARY ===== -->
                    <div id="activeFiltersSummary" style="margin-top: 20px; background: #0f1419; padding: 14px; border-radius: 10px; border: 1px solid #2d3748;">
                        <div style="font-size: 13px; color: #9ca3af; margin-bottom: 10px; display: flex; align-items: center; gap: 6px;">
                            üìä <strong>Currently Active Filters</strong>
                        </div>
                        <div id="activeFiltersList" style="display: flex; flex-wrap: wrap; gap: 6px; min-height: 28px;"></div>
                    </div>
                </div>
            </div>

            <div class="trade-signal-card" id="tradeSignalCard">
                <h3>üéØ Trade Signal Monitor</h3>
                <div class="signal-content">
                    <div class="signal-item">
                        <div class="signal-label">Current Market</div>
                        <div class="signal-value" id="currentMarket">-</div>
                        <div class="live-price" id="currentPrice">0.00</div>
                    </div>
                    <div class="signal-item">
                        <div class="signal-label">Signal Status</div>
                        <div class="signal-value" id="signalStatus">Waiting</div>
                    </div>
                </div>
                <div class="signal-status no-signal" id="signalMessage">
                    ‚è≥ Waiting for connection...
                </div>
            </div>

            <!-- Single Market Signal -->
            <div id="singleMarketSignal">

            <div class="indicator-status" id="indicatorStatus">
                <h4>üìà Live Strategy Indicators</h4>
                <div id="indicatorDisplay">
                    <div class="indicator-item">
                        <span>Loading indicators...</span>
                        <span class="indicator-value">Waiting...</span>
                    </div>
                </div>
            </div>
            </div>
            <!-- End of singleMarketSignal -->

            <div class="control-buttons" id="controlButtons">
                <button class="btn btn-success" id="buyBtn" disabled>
                    <span>üìà</span> Buy (Rise)
                </button>
                <button class="btn btn-danger" id="sellBtn" disabled>
                    <span>üìâ</span> Sell (Fall)
                </button>
                <button class="btn btn-primary" id="autoTradeBtn" disabled>
                    <span>ü§ñ</span> Start Auto Trade
                </button>
                <button class="btn btn-secondary" id="stopAutoTradeBtn" style="display: none;" disabled>
                    <span>‚è∏Ô∏è</span> Stop Auto Trade
                </button>
            </div>

            <div class="stats-grid" id="statsGrid">
                <div class="stat-card">
                    <div class="stat-label">Total Trades</div>
                    <div class="stat-value" id="totalTrades">0</div>
                </div>
                <div class="stat-card profit">
                    <div class="stat-label">Wins</div>
                    <div class="stat-value" id="winCount">0</div>
                </div>
                <div class="stat-card loss">
                    <div class="stat-label">Losses</div>
                    <div class="stat-value" id="lossCount">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">P/L</div>
                    <div class="stat-value" id="profitLoss">0.00</div>
                </div>
            </div>

            <div class="trade-history" id="tradeHistory">
                <div class="trade-history-header">
                    <h3>üìú Trade History <span id="tradeCount" style="font-size: 14px; color: #667eea; font-weight: normal;">(0)</span></h3>
                    <button id="clearHistoryBtn" class="btn btn-secondary btn-sm">Clear History</button>
                </div>
                <div class="scroll-container">
                    <div class="history-table">
                        <table>
                            <thead>
                                <tr>
                                    <th>S/N</th>
                                    <th>Time</th>
                                    <th>Market</th>
                                    <th>Type</th>
                                    <th>Stake</th>
                                    <th>Result</th>
                                </tr>
                            </thead>
                            <tbody id="tradeHistoryBody">
                                <tr>
                                    <td colspan="6" style="text-align: center; color: #9ca3af;">No trades yet</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- Virtual Trade History -->
            <div class="trade-history" id="virtualTradeHistory" style="display: none;">
                <div class="trade-history-header">
                    <h3>üß™ Virtual Trade History <span id="virtualTradeCount" style="font-size: 14px; color: #667eea; font-weight: normal;">(0)</span></h3>
                </div>
                <div class="scroll-container">
                    <div class="history-table">
                        <table>
                            <thead>
                                <tr>
                                    <th>S/N</th>
                                    <th>Time</th>
                                    <th>Market</th>
                                    <th>Type</th>
                                    <th>Stake</th>
                                    <th>Result</th>
                                </tr>
                            </thead>
                            <tbody id="virtualTradeHistoryBody">
                                <tr>
                                    <td colspan="6" style="text-align: center; color: #9ca3af;">No virtual trades yet</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div class="card" id="logCard">
                <h3>üìã Activity Log</h3>
                <div class="log-panel" id="logPanel">
                    <div class="log-entry info">System initialized. Waiting for login...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global Variables
        let ws = null;
        let accountData = null;
        let sessionStartTime = null;
        let sessionTimerInterval = null;
        let isAutoTrading = false;
        let isExplicitLogout = false;
        let sessionToken = null;
        let lastTradeTime = 0; 
        let tickHistory = [];
        let candle30SecHistory = [];
        let candle1MinHistory = [];
        let candle5MinHistory = [];
        let currentMarketSymbol = '';
        let currentPrice = 0;
        let currentStrategy = 'bounce';
        let currentTimeframe = '1min'; // New: Selected timeframe for analysis
        let lastExecutedTradeType = null;
        let nextTradeType = 'BUY';
        let lastSetupDetectedTime = 0;
        let currentSetupId = null;
        let stats = {
            total: 0,
            wins: 0,
            losses: 0,
            profitLoss: 0
        };

        let tradeHistory = JSON.parse(localStorage.getItem('benScalperTradeHistory')) || [];
        let virtualTradeHistory = JSON.parse(localStorage.getItem('benScalperVirtualTradeHistory')) || [];

        // Contract settlement tracking (NEW)
        let activeContracts = new Map(); // contractId -> {details, startTime}
        let contractTimeouts = new Map(); // contractId -> timeoutId
        let portfolioCheckInterval = null;
        const CONTRACT_TIMEOUT_MS = 90000; // 90 seconds
        const PORTFOLIO_CHECK_MS = 30000; // 30 seconds
        let isProcessingTrade = false; // FIXED: Prevent multiple simultaneous trades

        // Smart Filter Variables
        let smartFilterEnabled = false;
        let smartTargetProfit = 5;
        let smartTargetLoss = 5;
        let isVirtualMode = false;
        let smartPL = 0;
        let isFirstSmartTrade = true;
        let smartReverseActive = false;
        let virtualEntryPrice = 0;
        let virtualTradeType = '';
        let virtualStartTime = 0;
        let virtualDurationMs = 0;
        let virtualStake = 0;
        let virtualTimeout = null;
        let virtualProfit = 0;
        let virtualTickCount = 0;
        let isVirtualProposal = false;

        const availableMarkets = [
            { value: 'R_10', name: 'Volatility 10' },
            { value: 'R_25', name: 'Volatility 25' },
            { value: 'R_50', name: 'Volatility 50' },
            { value: 'R_75', name: 'Volatility 75' },
            { value: 'R_100', name: 'Volatility 100' },
            { value: 'stpRNG', name: 'Step Index 100' },
            { value: 'stpRNG2', name: 'Step Index 200' },
            { value: 'stpRNG3', name: 'Step Index 300' },
            { value: 'stpRNG4', name: 'Step Index 400' },
            { value: 'stpRNG5', name: 'Step Index 500' }
        ];

        // Strategy-specific indicators
        let strategyIndicators = {
            rsi: 0,
            adx: 0,
            plusDI: 0,
            minusDI: 0
        };

        // Candle data for different timeframes
        let currentCandle30Sec = { open: 0, high: 0, low: 0, close: 0, ticks: 0, timestamp: 0, volume: 0 };
        let currentCandle1Min = { open: 0, high: 0, low: 0, close: 0, ticks: 0, timestamp: 0, volume: 0 };
        let currentCandle5Min = { open: 0, high: 0, low: 0, close: 0, ticks: 0, timestamp: 0, volume: 0 };
        
        const CANDLE_30SEC_MS = 30000;
        const CANDLE_1MIN_MS = 60000;
        const CANDLE_5MIN_MS = 300000;


        // Load saved settings
        function loadSettings() {
            const savedToken = localStorage.getItem('derivApiToken');
            const rememberToken = localStorage.getItem('rememberToken') === 'true';
            
            if (savedToken && rememberToken) {
                document.getElementById('apiToken').value = savedToken;
                document.getElementById('rememberToken').checked = true;
            }

            const settingsToLoad = [
                'stakeAmount', 'durationValue', 
                'stopLoss', 'takeProfit', 'cooldownTimer'
            ];

            settingsToLoad.forEach(setting => {
                const saved = localStorage.getItem(setting);
                if (saved) document.getElementById(setting).value = saved;
            });

            // Load market radio button
            const savedMarket = localStorage.getItem('market');
            if (savedMarket) {
                const marketRadio = document.getElementById(`market_${savedMarket}`);
                if (marketRadio) marketRadio.checked = true;
            }

            // Load duration type radio button
            const savedDurationType = localStorage.getItem('durationType');
            if (savedDurationType) {
                const durationRadio = document.getElementById(
                    savedDurationType === 't' ? 'durationTicks' :
                    savedDurationType === 's' ? 'durationSeconds' :
                    'durationMinutes'
                );
                if (durationRadio) durationRadio.checked = true;
            }

            const savedStrategy = localStorage.getItem('currentStrategy');
            if (savedStrategy) {
                currentStrategy = savedStrategy;
                const strategyRadioId = 
                    savedStrategy === 'bounce' ? 'strategyBounce' :
                    savedStrategy === 'breakout' ? 'strategyBreakout' :
                    'strategyBounce'; // default
                const strategyRadio = document.getElementById(strategyRadioId);
                if (strategyRadio) strategyRadio.checked = true;
                updateStrategyDescription();
            }

            const savedAlternator = localStorage.getItem('alternatorMode') === 'true';
            const savedReverse = localStorage.getItem('reverseMode') === 'true';
            const savedOneEntry = localStorage.getItem('oneEntryMode') === 'true';
            const savedNextTradeType = localStorage.getItem('nextTradeType') || 'BUY';

            document.getElementById('alternatorMode').checked = savedAlternator;
            document.getElementById('reverseMode').checked = savedReverse;
            document.getElementById('oneEntryMode').checked = savedOneEntry;
            nextTradeType = savedNextTradeType;

            // Load filter settings
            const filterIds = ['filterADX', 'filterRSI', 'filterCandleBody', 'filterVolatility', 'filterMomentum', 'filterSmart'];
            filterIds.forEach(id => {
                const saved = localStorage.getItem(id) === 'true';
                const el = document.getElementById(id);
                if (el) el.checked = saved;
            });
            
            // Load smart filter settings
            const savedSmartFilter = localStorage.getItem('filterSmart') === 'true';
            document.getElementById('filterSmart').checked = savedSmartFilter;
            smartFilterEnabled = savedSmartFilter;
            
            const savedSmartProfit = localStorage.getItem('smartTargetProfit');
            if (savedSmartProfit) {
                document.getElementById('smartTargetProfit').value = savedSmartProfit;
                smartTargetProfit = parseFloat(savedSmartProfit);
            }
            
            const savedSmartLoss = localStorage.getItem('smartTargetLoss');
            if (savedSmartLoss) {
                document.getElementById('smartTargetLoss').value = savedSmartLoss;
                smartTargetLoss = parseFloat(savedSmartLoss);
            }
            
            updateActiveFiltersSummary();

            updateTradeHistoryTable();
            
            // Load virtual trade history
            virtualTradeHistory = JSON.parse(localStorage.getItem('benScalperVirtualTradeHistory')) || [];
        }

        function saveSettings() {
            const token = document.getElementById('apiToken').value;
            const remember = document.getElementById('rememberToken').checked;

            if (remember) {
                localStorage.setItem('derivApiToken', token);
                localStorage.setItem('rememberToken', 'true');
            } else {
                localStorage.removeItem('derivApiToken');
                localStorage.setItem('rememberToken', 'false');
            }

            const settingsToSave = [
                'stakeAmount', 'durationValue',
                'stopLoss', 'takeProfit', 'cooldownTimer'
            ];

            settingsToSave.forEach(setting => {
                localStorage.setItem(setting, document.getElementById(setting).value);
            });

            // Save market radio button selection
            const selectedMarket = document.querySelector('input[name="market"]:checked');
            if (selectedMarket) localStorage.setItem('market', selectedMarket.value);

            // Save duration type radio button selection
            const selectedDuration = document.querySelector('input[name="durationType"]:checked');
            if (selectedDuration) localStorage.setItem('durationType', selectedDuration.value);

            localStorage.setItem('currentStrategy', currentStrategy);
            localStorage.setItem('alternatorMode', document.getElementById('alternatorMode').checked);
            localStorage.setItem('reverseMode', document.getElementById('reverseMode').checked);
            localStorage.setItem('oneEntryMode', document.getElementById('oneEntryMode').checked);
            localStorage.setItem('nextTradeType', nextTradeType);

            // Save filter settings
            const filterIds = ['filterADX', 'filterRSI', 'filterCandleBody', 'filterVolatility', 'filterMomentum', 'filterSmart'];
            filterIds.forEach(id => {
                const el = document.getElementById(id);
                if (el) localStorage.setItem(id, el.checked);
            });
            
            // Save smart filter settings
            localStorage.setItem('smartTargetProfit', document.getElementById('smartTargetProfit').value);
            localStorage.setItem('smartTargetLoss', document.getElementById('smartTargetLoss').value);
        }

        // Add event listeners for all settings
        const settingIds = [
            'stakeAmount', 'durationValue', 'stopLoss', 'takeProfit',
            'cooldownTimer', 'alternatorMode', 'reverseMode', 'oneEntryMode'
        ];

        settingIds.forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.addEventListener('change', () => {
                    saveSettings();
                    addLog(`Setting changed: ${id} = ${element.type === 'checkbox' ? element.checked : element.value}`, 'info');
                });
            }
        });

        // Add event listeners for filters
        const filterIds = ['filterADX', 'filterRSI', 'filterCandleBody', 'filterVolatility', 'filterMomentum'];
        filterIds.forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('change', () => {
                    const filterName = id.replace('filter', '');
                    const status = el.checked ? 'ENABLED' : 'DISABLED';
                    addLog(`üõ°Ô∏è Filter ${filterName} ‚Üí ${status}`, el.checked ? 'success' : 'warning');
                    saveSettings();
                    updateActiveFiltersSummary();
                });
            }
        });

        // Smart filter event listener
        document.getElementById('filterSmart').addEventListener('change', (e) => {
            smartFilterEnabled = e.target.checked;
            const status = smartFilterEnabled ? 'ENABLED' : 'DISABLED';
            addLog(`üõ°Ô∏è Smart Filter ‚Üí ${status}`, e.target.checked ? 'success' : 'warning');
            if (smartFilterEnabled) {
                isFirstSmartTrade = true;
                isVirtualMode = true;
                smartPL = 0;
                smartReverseActive = false;
                document.getElementById('reverseMode').checked = false;
                updateVirtualBadge(true);
                document.getElementById('virtualTradeHistory').style.display = 'block';
                updateVirtualHistoryTable();
                addLog('üß™ Smart Filter: Starting in VIRTUAL mode for first trade', 'info');
            } else {
                isVirtualMode = false;
                updateVirtualBadge(false);
                document.getElementById('virtualTradeHistory').style.display = 'none';
                if (smartReverseActive) {
                    document.getElementById('reverseMode').checked = false;
                    smartReverseActive = false;
                }
                resetVirtualVars();
            }
            saveSettings();
            updateActiveFiltersSummary();
        });

        // Smart target event listeners
        ['smartTargetProfit', 'smartTargetLoss'].forEach(id => {
            document.getElementById(id).addEventListener('change', () => {
                smartTargetProfit = parseFloat(document.getElementById('smartTargetProfit').value);
                smartTargetLoss = parseFloat(document.getElementById('smartTargetLoss').value);
                addLog(`üí∞ Smart targets updated: Profit $${smartTargetProfit}, Loss $${smartTargetLoss}`, 'info');
                saveSettings();
            });
        });

        // Market change listener for radio buttons
        document.addEventListener('change', function(e) {
            if (e.target.name === 'market') {
                const newMarket = e.target.value;
                const marketName = e.target.nextElementSibling.textContent;
                if (ws && ws.readyState === WebSocket.OPEN) {
                    subscribeToTicks(newMarket);
                    updateTradeSignalDisplay();
                    addLog(`Market changed to: ${marketName}`, 'info');
                }
            }
        });

        // Strategy change listener for radio button
        document.addEventListener('change', function(e) {
            if (e.target.name === 'strategy') {
                currentStrategy = e.target.value;
                saveSettings();
                updateStrategyDescription();
                resetStrategyIndicators();
                const strategyName = e.target.nextElementSibling.textContent;
                addLog(`Strategy changed to: ${strategyName}`, 'success');
                document.getElementById('activeStrategyDisplay').textContent = strategyName;
            }
        });

        function updateStrategyDescription() {
            const timeframeDisplay = currentTimeframe === '1min' ? '1m' : '30s';
            
            const descriptions = {
                bounce: `<strong>The Bounce Strategy - Trend Continuation (${timeframeDisplay} Candles)</strong><br>
                    <strong>BUY (Long):</strong> Uptrend - Price touches trendline support + Bullish candlestick pattern (Hammer, Bullish Engulfing)<br>
                    <strong>SELL (Short):</strong> Downtrend - Price touches trendline resistance + Bearish candlestick pattern (Shooting Star, Bearish Engulfing)`,
                breakout: `<strong>The Breakout Strategy - Trend Reversal (${timeframeDisplay} Candles)</strong><br>
                    <strong>BUY (Long):</strong> Downtrend ends - Price closes above resistance line + High volume confirmation<br>
                    <strong>SELL (Short):</strong> Uptrend ends - Price closes below support line + High volume confirmation`
            };
            
            document.getElementById('strategyDescription').innerHTML = descriptions[currentStrategy] || descriptions.bounce;
        }

        // ==================== FILTER PRESET FUNCTION ====================
        function applyFilterPreset(preset) {
            const filterIds = ['filterADX', 'filterRSI', 'filterCandleBody', 'filterVolatility', 'filterMomentum'];
            
            switch(preset) {
                case 'aggressive':
                    // Only momentum - allows most trades
                    filterIds.forEach(id => document.getElementById(id).checked = false);
                    document.getElementById('filterMomentum').checked = true;
                    addLog('‚ö° Aggressive preset applied: Momentum only', 'success');
                    break;
                    
                case 'balanced':
                    // ADX + Candle Body - good balance
                    filterIds.forEach(id => document.getElementById(id).checked = false);
                    document.getElementById('filterADX').checked = true;
                    document.getElementById('filterCandleBody').checked = true;
                    addLog('‚öñÔ∏è Balanced preset applied: ADX + Candle Body', 'success');
                    break;
                    
                case 'conservative':
                    // All filters ON - very selective
                    filterIds.forEach(id => document.getElementById(id).checked = true);
                    addLog('üõ°Ô∏è Conservative preset applied: All filters active', 'success');
                    break;
                    
                case 'reset':
                    // All filters OFF
                    filterIds.forEach(id => document.getElementById(id).checked = false);
                    addLog('üîÑ All filters reset to OFF', 'warning');
                    break;
            }
            
            saveSettings();
            updateActiveFiltersSummary();
        }

        // ==================== LIVE ACTIVE FILTERS SUMMARY ====================
        function updateActiveFiltersSummary() {
            const container = document.getElementById('activeFiltersList');
            if (!container) return;
            
            container.innerHTML = '';
            
            const filters = [
                { id: 'filterADX',         name: 'ADX',         color: '#667eea' },
                { id: 'filterRSI',         name: 'RSI',         color: '#10b981' },
                { id: 'filterCandleBody',  name: 'Candle',      color: '#f59e0b' },
                { id: 'filterVolatility',  name: 'Volatility',  color: '#ec4899' },
                { id: 'filterMomentum',    name: 'Momentum',    color: '#8b5cf6' },
                { id: 'filterSmart',       name: 'Smart',       color: '#3b82f6' }
            ];
            
            let activeCount = 0;
            
            filters.forEach(f => {
                const el = document.getElementById(f.id);
                if (el && el.checked) {
                    const badge = document.createElement('div');
                    badge.style.cssText = `
                        background: rgba(102, 126, 234, 0.12);
                        color: ${f.color};
                        padding: 5px 12px;
                        border-radius: 999px;
                        font-size: 12.5px;
                        font-weight: 700;
                        border: 1px solid ${f.color}33;
                        display: inline-flex;
                        align-items: center;
                        gap: 4px;
                    `;
                    badge.innerHTML = `‚úÖ ${f.name}`;
                    container.appendChild(badge);
                    activeCount++;
                }
            });
            
            if (activeCount === 0) {
                const none = document.createElement('div');
                none.style.cssText = 'color: #6b7280; font-style: italic; padding: 6px 0; font-size: 13px;';
                none.textContent = 'No filters active ‚Äî all strategy signals are allowed';
                container.appendChild(none);
            }
        }

        // ==================== SMART FILTER HELPER FUNCTIONS ====================
        function updateVirtualBadge(show) {
            const badge = document.getElementById('virtualBadge');
            if (badge) {
                badge.style.display = show ? 'flex' : 'none';
            }
        }

        function toggleSmartReverse(enable) {
            smartReverseActive = enable;
            document.getElementById('reverseMode').checked = enable;
            addLog(`üîÅ Smart Reverse: ${enable ? 'ENABLED' : 'DISABLED'}`, 'info');
        }

        function resetVirtualVars() {
            if (virtualTimeout) {
                clearTimeout(virtualTimeout);
                virtualTimeout = null;
            }
            virtualEntryPrice = 0;
            virtualTradeType = '';
            virtualStartTime = 0;
            virtualDurationMs = 0;
            virtualStake = 0;
            virtualProfit = 0;
            virtualTickCount = 0;
            isVirtualProposal = false;
        }

        function endVirtualTrade() {
            const endPrice = currentPrice;
            let isWin = false;
            if (virtualTradeType === 'BUY') {
                isWin = endPrice > virtualEntryPrice;
            } else {
                isWin = endPrice < virtualEntryPrice;
            }
            
            // Use real proposal profit or stake loss
            const payout = isWin ? virtualProfit : -virtualStake;
            smartPL = payout;
            
            // Add to virtual trade history
            addVirtualTradeToHistory({
                time: new Date().toLocaleTimeString(),
                market: currentMarketSymbol || 'Unknown',
                type: virtualTradeType === 'BUY' ? 'RISE' : 'FALL',
                stake: virtualStake,
                result: payout,
                isWin: isWin
            });
            
            addLog(`üß™ Virtual trade ended: ${isWin ? 'WIN' : 'LOSS'} - P/L: $${payout.toFixed(2)}`, isWin ? 'success' : 'error');
            addLog(`   Entry: ${virtualEntryPrice.toFixed(5)} ‚Üí Exit: ${endPrice.toFixed(5)}`, 'info');
            
            // Check if target achieved
            const absPL = Math.abs(smartPL);
            const targetHit = (isWin && smartPL >= smartTargetProfit) || (!isWin && absPL >= smartTargetLoss);
            
            if (targetHit) {
                addLog(`üéØ Virtual target hit! Switching to LIVE trades and enabling reverse mode`, 'success');
                isVirtualMode = false;
                updateVirtualBadge(false);
                toggleSmartReverse(true);
                smartPL = 0;
            } else {
                addLog(`‚ùå Virtual target not hit. Waiting for next signal in virtual mode.`, 'warning');
            }
            
            resetVirtualVars();
        }

        function resetStrategyIndicators() {
            strategyIndicators = {
                rsi: 0,
                adx: 0,
                plusDI: 0,
                minusDI: 0
            };
            candle30SecHistory = [];
            candle1MinHistory = [];
            candle5MinHistory = [];
            currentCandle30Sec = { open: 0, high: 0, low: 0, close: 0, ticks: 0, timestamp: 0, volume: 0 };
            currentCandle1Min = { open: 0, high: 0, low: 0, close: 0, ticks: 0, timestamp: 0, volume: 0 };
            currentCandle5Min = { open: 0, high: 0, low: 0, close: 0, ticks: 0, timestamp: 0, volume: 0 };
            currentSetupId = null;
            lastSetupDetectedTime = 0;
            addLog('Strategy indicators reset', 'info');
        }

        function addLog(message, type = 'info') {
            const logPanel = document.getElementById('logPanel');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.textContent = `[${timestamp}] ${message}`;
            logPanel.appendChild(logEntry);
            logPanel.scrollTop = logPanel.scrollHeight;
            
            // Keep only last 100 log entries
            while (logPanel.children.length > 100) {
                logPanel.removeChild(logPanel.firstChild);
            }
        }

        function updateConnectionStatus(status) {
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            const logoutBtn = document.getElementById('logoutBtn');
            const connectionBox = document.querySelector('.connection-status');
            
            statusDot.classList.remove('connected', 'reconnecting');
            connectionBox.classList.remove('reconnecting');

            if (status === 'connected') {
                statusDot.classList.add('connected');
                statusText.textContent = 'Connected';
                logoutBtn.style.display = 'inline-block';
                addLog('Successfully connected to Deriv API', 'success');
            } else if (status === 'reconnecting') {
                statusDot.classList.add('reconnecting');
                connectionBox.classList.add('reconnecting');
                statusText.textContent = 'Reconnecting...';
                logoutBtn.style.display = 'none';
                addLog('Connection lost. Attempting to reconnect...', 'error');
            } else {
                statusText.textContent = 'Disconnected';
                logoutBtn.style.display = 'none';
                addLog('Disconnected from Deriv API', 'error');
            }
        }

        function updateTradeSignalDisplay() {
            const selectedMarket = document.querySelector('input[name="market"]:checked');
            const marketName = selectedMarket ? selectedMarket.nextElementSibling.textContent : 'Unknown';
            document.getElementById('currentMarket').textContent = marketName;
            document.getElementById('currentPrice').textContent = currentPrice.toFixed(2);
        }

        function enableTradeButtons() {
            document.getElementById('buyBtn').disabled = false;
            document.getElementById('sellBtn').disabled = false;
            document.getElementById('autoTradeBtn').disabled = false;
            
            // FIXED: Enable stop button if auto-trading is active
            if (isAutoTrading) {
                document.getElementById('stopAutoTradeBtn').disabled = false;
            }
            
            addLog('Trade buttons enabled', 'info');
        }

        function disableTradeButtons() {
            document.getElementById('buyBtn').disabled = true;
            document.getElementById('sellBtn').disabled = true;
            document.getElementById('autoTradeBtn').disabled = true;
            
            // FIXED: Don't disable stop button if auto-trading is active
            if (!isAutoTrading) {
                document.getElementById('stopAutoTradeBtn').disabled = true;
            }
            
            addLog('Trade buttons disabled', 'info');
        }

        function connectToDerivAPI(apiToken) {
            return new Promise((resolve, reject) => {
                const appId = 1089;
                ws = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${appId}`);
                isExplicitLogout = false;

                ws.onopen = () => {
                    addLog('WebSocket connection opened', 'info');
                    ws.send(JSON.stringify({ authorize: apiToken }));
                };

                ws.onmessage = (msg) => {
                    const data = JSON.parse(msg.data);
                    
                    if (data.error) {
                        if (data.error.code !== 'AlreadySubscribed') {
                            addLog(`Error: ${data.error.message}`, 'error');
                        }
                        if (data.msg_type === 'authorize') {
                             reject(data.error);
                        }
                        return;
                    }

                    if (data.msg_type === 'authorize') {
                        accountData = data.authorize;
                        sessionToken = apiToken;
                        updateAccountInfo(data.authorize);
                        updateConnectionStatus('connected');
                        startSessionTimer();
                        
                        updateUIForLogin();
                        
                        const selectedMarket = document.querySelector('input[name="market"]:checked');
                        const market = selectedMarket ? selectedMarket.value : 'R_10';
                        subscribeToTicks(market);
                        
                        // NEW: Start portfolio monitoring
                        startPortfolioMonitoring();
                        
                        resolve(data.authorize);
                    }

                    if (data.msg_type === 'balance') {
                        updateBalance(data.balance);
                    }

                    if (data.msg_type === 'buy') {
                        handleBuyResponse(data);
                    }

                    if (data.msg_type === 'proposal_open_contract') {
                        handleContractUpdate(data);
                    }

                    // NEW: Handle portfolio response for stuck contract detection
                    if (data.msg_type === 'portfolio') {
                        const openContracts = data.portfolio.contracts || [];
                        activeContracts.forEach((tracked, contractId) => {
                            const stillOpen = openContracts.find(c => c.contract_id === contractId);
                            if (!stillOpen) {
                                addLog(`‚ö†Ô∏è Contract ${contractId} not in portfolio - may have settled`, 'warning');
                                forceContractCheck(contractId);
                            }
                        });
                    }

                    // Virtual Trade Proposal Handling
                    if (data.msg_type === 'proposal' && isVirtualProposal) {
                        isVirtualProposal = false;
                        if (data.error) {
                            addLog(`Virtual proposal error: ${data.error.message}`, 'error');
                            isProcessingTrade = false;
                            return;
                        }
                        
                        virtualProfit = data.proposal.payout - data.proposal.ask_price;
                        addLog(`üß™ Virtual proposal received - Potential profit: $${virtualProfit.toFixed(2)}`, 'info');
                        
                        // Now start the simulation
                        virtualEntryPrice = currentPrice;
                        virtualTradeType = data.proposal.contract_type === 'CALL' ? 'BUY' : 'SELL';
                        virtualStartTime = Date.now();
                        virtualStake = data.proposal.ask_price;
                        
                        const selectedDuration = document.querySelector('input[name="durationType"]:checked');
                        const durationType = selectedDuration ? selectedDuration.value : 't';
                        const durationValue = parseInt(document.getElementById('durationValue').value);
                        
                        if (durationType !== 't') {
                            // Time-based: calculate ms
                            if (durationType === 's') {
                                virtualDurationMs = durationValue * 1000;
                            } else if (durationType === 'm') {
                                virtualDurationMs = durationValue * 60000;
                            }
                            virtualTimeout = setTimeout(() => {
                                endVirtualTrade();
                            }, virtualDurationMs);
                            addLog(`‚è±Ô∏è Virtual trade will end in ${(virtualDurationMs/1000).toFixed(0)}s`, 'info');
                        } else {
                            // Tick-based: reset count
                            virtualTickCount = 0;
                            addLog(`‚è±Ô∏è Virtual trade will end after ${durationValue} ticks`, 'info');
                        }
                        
                        isProcessingTrade = false;
                        isFirstSmartTrade = false;
                    }

                    if (data.msg_type === 'tick') {
                        handleTickData(data);
                    }
                };

                ws.onerror = (error) => {
                    addLog('WebSocket error occurred', 'error');
                };

                ws.onclose = () => {
                    disableTradeButtons();
                    stopPortfolioMonitoring(); // NEW: Stop monitoring on disconnect
                    
                    if (!isExplicitLogout) {
                        updateConnectionStatus('reconnecting');
                        setTimeout(() => {
                            const tokenToUse = sessionToken || document.getElementById('apiToken').value;
                            if (tokenToUse) {
                                connectToDerivAPI(tokenToUse);
                            }
                        }, 5000);
                    } else {
                        updateConnectionStatus('disconnected');
                    }
                };
            });
        }

        window.addEventListener('online', () => {
            if (!isExplicitLogout && sessionToken) {
                addLog('Network detected. Reconnecting immediately...', 'info');
                connectToDerivAPI(sessionToken);
            }
        });

        function updateUIForLogin() {
            document.getElementById('loginCard').style.display = 'none';
            document.getElementById('accountInfo').style.display = 'grid';
            enableTradeButtons();
            document.getElementById('signalMessage').textContent = '‚è≥ Collecting market data...';
        }

        function updateAccountInfo(authData) {
            document.getElementById('accountType').textContent = authData.is_virtual ? 'Demo' : 'Real';
            document.getElementById('accountCurrency').textContent = authData.currency;
            document.getElementById('accountBalance').textContent = parseFloat(authData.balance).toFixed(2);
            ws.send(JSON.stringify({ balance: 1, subscribe: 1 }));
        }

        function updateBalance(balanceData) {
            document.getElementById('accountBalance').textContent = parseFloat(balanceData.balance).toFixed(2);
        }

        function startSessionTimer() {
            if (sessionTimerInterval) clearInterval(sessionTimerInterval); 
            sessionStartTime = Date.now();
            sessionTimerInterval = setInterval(() => {
                const elapsed = Date.now() - sessionStartTime;
                const hours = Math.floor(elapsed / 3600000);
                const minutes = Math.floor((elapsed % 3600000) / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                document.getElementById('sessionTimer').textContent = 
                    `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }, 1000);
        }

        // --- Indicator Calculations ---
        function calculateSMA(prices, period) {
            if (prices.length < period) return 0;
            return prices.slice(-period).reduce((a, b) => a + b, 0) / period;
        }

        function calculateEMA(prices, period) {
            if (prices.length < period) return 0;
            
            const k = 2 / (period + 1);
            let ema = calculateSMA(prices.slice(0, period), period);
            
            for (let i = period; i < prices.length; i++) {
                ema = (prices[i] * k) + (ema * (1 - k));
            }
            
            return ema;
        }

        function calculateRSI(prices, period = 14) {
            if (prices.length < period + 1) return 50;
            
            let gains = 0;
            let losses = 0;
            
            for (let i = prices.length - period; i < prices.length; i++) {
                const change = prices[i] - prices[i - 1];
                if (change > 0) gains += change;
                else losses -= change;
            }
            
            const avgGain = gains / period;
            const avgLoss = losses / period;
            
            if (avgLoss === 0) return 100;
            const rs = avgGain / avgLoss;
            return 100 - (100 / (1 + rs));
        }

        // NEW: Calculate ADX (Average Directional Index)
        function calculateADX(candles, period = 14) {
            if (candles.length < period + 1) return { adx: 0, plusDI: 0, minusDI: 0 };
            
            const trueRanges = [];
            const plusDMs = [];
            const minusDMs = [];
            
            // Calculate True Range, +DM, -DM
            for (let i = 1; i < candles.length; i++) {
                const high = candles[i].high;
                const low = candles[i].low;
                const prevHigh = candles[i - 1].high;
                const prevLow = candles[i - 1].low;
                const prevClose = candles[i - 1].close;
                
                // True Range
                const tr = Math.max(
                    high - low,
                    Math.abs(high - prevClose),
                    Math.abs(low - prevClose)
                );
                trueRanges.push(tr);
                
                // Directional Movement
                const upMove = high - prevHigh;
                const downMove = prevLow - low;
                
                const plusDM = (upMove > downMove && upMove > 0) ? upMove : 0;
                const minusDM = (downMove > upMove && downMove > 0) ? downMove : 0;
                
                plusDMs.push(plusDM);
                minusDMs.push(minusDM);
            }
            
            if (trueRanges.length < period) return { adx: 0, plusDI: 0, minusDI: 0 };
            
            // Calculate smoothed TR, +DM, -DM
            const smoothedTR = trueRanges.slice(-period).reduce((a, b) => a + b, 0);
            const smoothedPlusDM = plusDMs.slice(-period).reduce((a, b) => a + b, 0);
            const smoothedMinusDM = minusDMs.slice(-period).reduce((a, b) => a + b, 0);
            
            // Calculate +DI and -DI
            const plusDI = smoothedTR > 0 ? (smoothedPlusDM / smoothedTR) * 100 : 0;
            const minusDI = smoothedTR > 0 ? (smoothedMinusDM / smoothedTR) * 100 : 0;
            
            // Calculate DX
            const diSum = plusDI + minusDI;
            const diDiff = Math.abs(plusDI - minusDI);
            const dx = diSum > 0 ? (diDiff / diSum) * 100 : 0;
            
            // ADX is smoothed DX (simplified - just using current DX)
            const adx = dx;
            
            return { adx, plusDI, minusDI };
        }


        function detectHigherHighsHigherLows(candles) {
            if (candles.length < 4) return false;
            const recent = candles.slice(-4);
            return recent[3].high > recent[2].high && 
                   recent[2].high > recent[1].high &&
                   recent[3].low  > recent[2].low  && 
                   recent[2].low  > recent[1].low;
        }

        function detectLowerLowsLowerHighs(candles) {
            if (candles.length < 4) return false;
            const recent = candles.slice(-4);
            return recent[3].high < recent[2].high && 
                   recent[2].high < recent[1].high &&
                   recent[3].low  < recent[2].low  && 
                   recent[2].low  < recent[1].low;
        }

        function calculateATR(candles, period = 14) {
            if (candles.length < period + 1) return 0;
            
            let atrSum = 0;
            for (let i = candles.length - period; i < candles.length; i++) {
                const high = candles[i].high;
                const low = candles[i].low;
                const prevClose = i > 0 ? candles[i - 1].close : candles[i].close;
                
                const tr = Math.max(
                    high - low,
                    Math.abs(high - prevClose),
                    Math.abs(low - prevClose)
                );
                
                atrSum += tr;
            }
            
            return atrSum / period;
        }

        // --- Strategy Analysis Functions ---

        // ==================== PATCHED BOUNCE STRATEGY ====================
        function analyzeBounceStrategy() {
            // Use selected timeframe
            const candleHistory = currentTimeframe === '1min' ? candle1MinHistory : candle30SecHistory;
            const timeframeName = currentTimeframe === '1min' ? '1-min' : '30-sec';
            const requiredCandles = 10; // Same for both timeframes - 30sec just gets signals faster!
            
            if (candleHistory.length < requiredCandles) {
                return { signal: null, message: `Collecting ${timeframeName} candles... ${candleHistory.length}/${requiredCandles} needed` };
            }

            const recentCandles = candleHistory.slice(-requiredCandles);
            const lastCandle = recentCandles[recentCandles.length - 1];
            const prevCandle = recentCandles[recentCandles.length - 2];

            // === SIMPLIFIED TREND DETECTION (EMA only) ===
            const closes = recentCandles.map(c => c.close);
            const ema8  = calculateEMA(closes, 8);
            const ema21 = calculateEMA(closes, 21);
            
            const isUptrend   = ema8 > ema21;  // Simplified - just EMA crossover
            const isDowntrend = ema8 < ema21;

            // === DYNAMIC LEVELS ===
            const atr = calculateATR(recentCandles, 10);
            const support    = Math.min(...recentCandles.map(c => c.low));
            const resistance = Math.max(...recentCandles.map(c => c.high));
            const mid = (support + resistance) / 2;

            // More lenient - within 2 * ATR instead of 1.2 * ATR
            const nearSupport    = lastCandle.close <= support + (atr * 2);
            const nearResistance = lastCandle.close >= resistance - (atr * 2);
            const nearMid = Math.abs(lastCandle.close - mid) < atr;

            // === SIMPLIFIED PATTERNS - Just check candle direction ===
            const isBullishCandle = lastCandle.close > lastCandle.open;
            const isBearishCandle = lastCandle.close < lastCandle.open;
            
            // Check if price is moving in the right direction
            const movingUp = lastCandle.close > prevCandle.close;
            const movingDown = lastCandle.close < prevCandle.close;

            // === DISPLAY FOR DEBUGGING ===
            const displayData = {
                'Timeframe': currentTimeframe === '1min' ? '‚è±Ô∏è 1 Minute' : '‚ö° 30 Seconds',
                'Trend': isUptrend ? 'üìà Uptrend (EMA8 > EMA21)' : isDowntrend ? 'üìâ Downtrend (EMA8 < EMA21)' : '‚û°Ô∏è Neutral',
                'EMA8': ema8.toFixed(5),
                'EMA21': ema21.toFixed(5),
                'Support': support.toFixed(5),
                'Resistance': resistance.toFixed(5),
                'Current Price': lastCandle.close.toFixed(5),
                'Near Support': nearSupport ? 'YES' : 'No',
                'Near Resistance': nearResistance ? 'YES' : 'No',
                'Candles': candleHistory.length
            };
            updateIndicatorDisplay(displayData);

            // === MORE GENEROUS SIGNALS ===
            // BUY: Uptrend + near support + bullish movement
            if (isUptrend && nearSupport && (isBullishCandle || movingUp)) {
                return { signal: 'BUY', message: `‚úÖ Uptrend bounce from support zone (${timeframeName})` };
            }

            // SELL: Downtrend + near resistance + bearish movement
            if (isDowntrend && nearResistance && (isBearishCandle || movingDown)) {
                return { signal: 'SELL', message: `‚úÖ Downtrend bounce from resistance zone (${timeframeName})` };
            }

            // ALTERNATIVE: Trade the middle range in strong trends
            if (isUptrend && nearMid && movingUp) {
                return { signal: 'BUY', message: `‚úÖ Mid-range BUY in uptrend (${timeframeName})` };
            }
            
            if (isDowntrend && nearMid && movingDown) {
                return { signal: 'SELL', message: `‚úÖ Mid-range SELL in downtrend (${timeframeName})` };
            }

            return { signal: null, message: 'Scanning for bounce setup...' };
        }

        // ==================== PATCHED BREAKOUT STRATEGY ====================
        function analyzeBreakoutStrategy() {
            // Use selected timeframe
            const candleHistory = currentTimeframe === '1min' ? candle1MinHistory : candle30SecHistory;
            const timeframeName = currentTimeframe === '1min' ? '1-min' : '30-sec';
            const requiredCandles = 12; // Same for both timeframes - 30sec just gets signals faster!
            
            if (candleHistory.length < requiredCandles) {
                return { signal: null, message: `Collecting ${timeframeName} candles... ${candleHistory.length}/${requiredCandles} needed` };
            }

            const recentCandles = candleHistory.slice(-requiredCandles);
            const lastCandle = recentCandles[recentCandles.length - 1];
            const prevCandles = recentCandles.slice(0, -1);

            // === SIMPLIFIED TREND DETECTION ===
            const closes = prevCandles.map(c => c.close);
            const ema8 = calculateEMA(closes, 8);
            const ema21 = calculateEMA(closes, 21);
            
            const wasDowntrend = ema8 < ema21;  // Simplified
            const wasUptrend   = ema8 > ema21;

            // === DYNAMIC RANGE ===
            const resistance = Math.max(...prevCandles.map(c => c.high));
            const support    = Math.min(...prevCandles.map(c => c.low));
            const range = resistance - support;
            const atr = calculateATR(recentCandles, 10);

            // === BREAKOUT DETECTION (more lenient) ===
            const breakoutAbove = lastCandle.close > resistance && lastCandle.close > lastCandle.open;
            const breakoutBelow = lastCandle.close < support && lastCandle.close < lastCandle.open;
            
            // Check momentum
            const priceChange = lastCandle.close - prevCandles[prevCandles.length - 1].close;
            const strongMomentum = Math.abs(priceChange) > atr * 0.5;

            // === VOLUME (optional confirmation) ===
            const avgTicks = prevCandles.reduce((sum, c) => sum + (c.ticks || 1), 0) / prevCandles.length;
            const highVolume = lastCandle.ticks > avgTicks * 1.3;  // Lowered from 1.6

            // === DISPLAY ===
            const displayData = {
                'Timeframe': currentTimeframe === '1min' ? '‚è±Ô∏è 1 Minute' : '‚ö° 30 Seconds',
                'Previous Trend': wasDowntrend ? 'üìâ Downtrend' : wasUptrend ? 'üìà Uptrend' : '‚û°Ô∏è Neutral',
                'Resistance': resistance.toFixed(5),
                'Support': support.toFixed(5),
                'Current Close': lastCandle.close.toFixed(5),
                'Range': range.toFixed(5),
                'Strong Momentum': strongMomentum ? 'YES' : 'No',
                'Volume': highVolume ? 'High üî•' : 'Normal',
                'Candles': candleHistory.length
            };
            updateIndicatorDisplay(displayData);

            // === MORE GENEROUS SIGNALS ===
            // BUY: Price breaks above resistance (trend reversal or continuation)
            if (breakoutAbove && (wasDowntrend || strongMomentum)) {
                return { 
                    signal: 'BUY', 
                    message: `‚úÖ Bullish breakout above ${resistance.toFixed(5)} ${highVolume ? '(volume!)' : ''} (${timeframeName})` 
                };
            }

            // SELL: Price breaks below support (trend reversal or continuation)
            if (breakoutBelow && (wasUptrend || strongMomentum)) {
                return { 
                    signal: 'SELL', 
                    message: `‚úÖ Bearish breakdown below ${support.toFixed(5)} ${highVolume ? '(volume!)' : ''} (${timeframeName})` 
                };
            }

            // ALTERNATIVE: Trade near breakout levels (anticipation)
            const nearResistance = lastCandle.close >= resistance - (atr * 0.5) && lastCandle.close < resistance;
            const nearSupport = lastCandle.close <= support + (atr * 0.5) && lastCandle.close > support;
            
            if (nearResistance && lastCandle.close > lastCandle.open && strongMomentum) {
                return { signal: 'BUY', message: `‚úÖ Approaching resistance with momentum (${timeframeName})` };
            }
            
            if (nearSupport && lastCandle.close < lastCandle.open && strongMomentum) {
                return { signal: 'SELL', message: `‚úÖ Approaching support with momentum (${timeframeName})` };
            }

            return { signal: null, message: 'Waiting for breakout...' };
        }


        function updateIndicatorDisplay(indicators) {
            const display = document.getElementById('indicatorDisplay');
            display.innerHTML = '';
            
            for (const [label, value] of Object.entries(indicators)) {
                const item = document.createElement('div');
                item.className = 'indicator-item';
                item.innerHTML = `
                    <span>${label}:</span>
                    <span class="indicator-value">${value}</span>
                `;
                display.appendChild(item);
            }
        }

        // ==================== APPLY ADVANCED FILTERS ====================
        function applyAdvancedFilters(signal, candleHistory) {
            if (!signal || signal === null) return signal;
            
            const lastCandle = candleHistory[candleHistory.length - 1];
            const recentCandles = candleHistory.slice(-10);
            
            // ==================== ADX FILTER (TIGHTENED + DI STRENGTH) ====================
            if (document.getElementById('filterADX')?.checked) {
                // TIGHTENED: 25 instead of 23 (sweet spot for synthetics)
                if (strategyIndicators.adx < 25) {
                    addLog(`üõ°Ô∏è ADX Filter BLOCKED: ADX ${strategyIndicators.adx.toFixed(1)} < 25 (weak trend)`, 'warning');
                    return null;
                }
                
                // TIGHTENED: DI difference now 7 instead of 5 (much cleaner direction)
                const diDiff = Math.abs(strategyIndicators.plusDI - strategyIndicators.minusDI);
                if (diDiff < 7) {
                    addLog(`üõ°Ô∏è ADX Filter BLOCKED: DI difference ${diDiff.toFixed(1)} < 7 (unclear direction)`, 'warning');
                    return null;
                }
                
                // NEW: Strict directional confirmation (this is the real killer feature)
                const correctDI = 
                    (signal === 'BUY'  && strategyIndicators.plusDI  > strategyIndicators.minusDI) ||
                    (signal === 'SELL' && strategyIndicators.minusDI > strategyIndicators.plusDI);
                
                if (!correctDI) {
                    addLog(`üõ°Ô∏è ADX Filter BLOCKED: Wrong DI direction (${signal} but ${strategyIndicators.plusDI.toFixed(1)}/+DI vs ${strategyIndicators.minusDI.toFixed(1)}/-DI)`, 'warning');
                    return null;
                }
            }
            
            // RSI Filter
            if (document.getElementById('filterRSI')?.checked) {
                if (signal === 'BUY' && strategyIndicators.rsi > 78) {
                    addLog(`üõ°Ô∏è RSI Filter BLOCKED BUY: RSI ${strategyIndicators.rsi.toFixed(1)} > 78 (overbought)`, 'warning');
                    return null;
                }
                if (signal === 'SELL' && strategyIndicators.rsi < 22) {
                    addLog(`üõ°Ô∏è RSI Filter BLOCKED SELL: RSI ${strategyIndicators.rsi.toFixed(1)} < 22 (oversold)`, 'warning');
                    return null;
                }
            }
            
            // Candle Body Filter
            if (document.getElementById('filterCandleBody')?.checked) {
                const body = Math.abs(lastCandle.close - lastCandle.open);
                const range = lastCandle.high - lastCandle.low;
                const bodyRatio = range > 0 ? body / range : 0;
                if (bodyRatio < 0.65) {
                    addLog(`üõ°Ô∏è Candle Body Filter BLOCKED: Body ratio ${(bodyRatio * 100).toFixed(1)}% < 65% (weak candle)`, 'warning');
                    return null;
                }
            }
            
            // Volatility Contraction Filter
            if (document.getElementById('filterVolatility')?.checked) {
                const atr = calculateATR(recentCandles, 10);
                const currentRange = lastCandle.high - lastCandle.low;
                const avgRange = recentCandles.reduce((sum, c) => sum + (c.high - c.low), 0) / recentCandles.length;
                if (currentRange > avgRange * 0.8) {
                    addLog(`üõ°Ô∏è Volatility Filter BLOCKED: Range not compressed (${(currentRange/avgRange*100).toFixed(0)}% of avg)`, 'warning');
                    return null;
                }
            }
            
            // Momentum Filter
            if (document.getElementById('filterMomentum')?.checked) {
                const atr = calculateATR(recentCandles, 10);
                const prevCandle = candleHistory[candleHistory.length - 2];
                const priceMove = Math.abs(lastCandle.close - prevCandle.close);
                if (priceMove < atr * 0.6) {
                    addLog(`üõ°Ô∏è Momentum Filter BLOCKED: Move ${priceMove.toFixed(5)} < ${(atr * 0.6).toFixed(5)} (weak momentum)`, 'warning');
                    return null;
                }
            }
            
            return signal;
        }

        // ==================== FIXED analyzeMarketSignals() ====================
        function analyzeMarketSignals() {
            let result = { signal: null, message: 'Waiting for data...' };

            // Run the selected strategy (now using the patched versions)
            switch (currentStrategy) {
                case 'bounce':
                    result = analyzeBounceStrategy();
                    break;
                case 'breakout':
                    result = analyzeBreakoutStrategy();
                    break;
            }

            let signal = result.signal;
            const originalSignal = signal;

            if (signal) {
                addLog(`üìä Raw Strategy Signal: ${signal} - ${result.message}`, 'info');
            }

            // ====================== APPLY ADVANCED FILTERS ======================
            const candleHistory = currentTimeframe === '1min' ? candle1MinHistory : candle30SecHistory;
            signal = applyAdvancedFilters(signal, candleHistory);
            if (signal === null && originalSignal !== null) {
                updateSignalUI('NONE', 'üõ°Ô∏è Signal blocked by active filters');
                return null;
            }

            // ====================== ONE ENTRY PER SETUP (NOW FIXED) ======================
            const oneEntryEnabled = document.getElementById('oneEntryMode').checked;
            if (oneEntryEnabled && signal) {
                const timeSinceLastSetup = Date.now() - lastSetupDetectedTime;
                
                // Block if we are still inside the same setup (2 minutes window)
                if (timeSinceLastSetup < 120000) {   // ‚Üê 120 seconds = 2 minutes
                    addLog(`üîí One Entry Per Setup: Blocked (same setup ${Math.round(timeSinceLastSetup/1000)}s ago)`, 'warning');
                    updateSignalUI('NONE', `One Entry: Waiting for new setup... (${Math.round((120000 - timeSinceLastSetup)/1000)}s left)`);
                    return null;
                }
                
                // New setup detected ‚Üí allow the trade and reset timer
                lastSetupDetectedTime = Date.now();
                addLog(`‚úÖ One Entry Per Setup: New setup accepted`, 'success');
            }

            // ====================== REVERSE MODE ======================
            const reverseModeEnabled = document.getElementById('reverseMode').checked;
            if (reverseModeEnabled && signal) {
                const before = signal;
                signal = signal === 'BUY' ? 'SELL' : 'BUY';
                result.message += ' (Reversed)';
                addLog(`üîÅ Reverse Mode: ${before} ‚Üí ${signal}`, 'info');
            }

            // ====================== ALTERNATOR MODE ======================
            const alternatorEnabled = document.getElementById('alternatorMode').checked;
            if (alternatorEnabled && signal) {
                if (lastExecutedTradeType !== null && signal === lastExecutedTradeType) {
                    const nextExpected = lastExecutedTradeType === 'BUY' ? 'SELL' : 'BUY';
                    addLog(`üîÑ Alternator: ${signal} blocked (waiting for ${nextExpected})`, 'warning');
                    updateSignalUI('NONE', `Alternator: Waiting for ${nextExpected}`);
                    return null;
                }
                addLog(`‚úÖ Alternator: ${signal} allowed`, 'info');
            }

            // ====================== FINAL SIGNAL ======================
            if (signal) {
                addLog(`üöÄ FINAL EXECUTION SIGNAL: ${signal}`, 'success');
                updateSignalUI(signal, result.message);
                return signal;
            }

            updateSignalUI('NONE', result.message);
            return null;
        }

        function updateSignalUI(type, message) {
            const signalMessage = document.getElementById('signalMessage');
            const signalStatus = document.getElementById('signalStatus');

            if (type === 'BUY') {
                signalMessage.className = 'signal-status buy-signal';
                signalMessage.innerHTML = `<strong>üìà BUY SIGNAL DETECTED</strong><br><small>${message}</small>`;
                signalStatus.textContent = 'BUY';
                signalStatus.style.color = '#10b981';
            } else if (type === 'SELL') {
                signalMessage.className = 'signal-status sell-signal';
                signalMessage.innerHTML = `<strong>üìâ SELL SIGNAL DETECTED</strong><br><small>${message}</small>`;
                signalStatus.textContent = 'SELL';
                signalStatus.style.color = '#ef4444';
            } else {
                signalMessage.className = 'signal-status no-signal';
                signalMessage.innerHTML = `<strong>‚è≥ No Signal</strong><br><small>${message}</small>`;
                signalStatus.textContent = 'No Signal';
                signalStatus.style.color = '#667eea';
            }
        }

        function handleTickData(data) {
            if (data.tick) {
                if (data.tick.symbol !== currentMarketSymbol) return;
                
                tickHistory.push(data.tick);
                currentPrice = data.tick.quote;
                document.getElementById('currentPrice').textContent = currentPrice.toFixed(2);
                
                if (tickHistory.length > 1000) tickHistory.shift();

                const now = Date.now();

                // Build 30-second candles (ALWAYS - needed for timeframe selection)
                if (currentCandle30Sec.ticks === 0) {
                    currentCandle30Sec.open = currentPrice;
                    currentCandle30Sec.high = currentPrice;
                    currentCandle30Sec.low = currentPrice;
                    currentCandle30Sec.close = currentPrice;
                    currentCandle30Sec.ticks = 1;
                    currentCandle30Sec.timestamp = now;
                    currentCandle30Sec.volume = 1;
                } else {
                    currentCandle30Sec.high = Math.max(currentCandle30Sec.high, currentPrice);
                    currentCandle30Sec.low = Math.min(currentCandle30Sec.low, currentPrice);
                    currentCandle30Sec.close = currentPrice;
                    currentCandle30Sec.ticks++;
                    currentCandle30Sec.volume++;

                    if (now - currentCandle30Sec.timestamp >= CANDLE_30SEC_MS) {
                        candle30SecHistory.push({ ...currentCandle30Sec });
                        // Memory management: Keep only last 200 candles (100 minutes of 30-sec data)
                        if (candle30SecHistory.length > 200) {
                            candle30SecHistory.shift();
                        }
                        currentCandle30Sec = { open: 0, high: 0, low: 0, close: 0, ticks: 0, timestamp: 0, volume: 0 };
                    }
                }

                // Build 1-minute candles (ALWAYS - needed for timeframe selection)
                if (currentCandle1Min.ticks === 0) {
                    currentCandle1Min.open = currentPrice;
                    currentCandle1Min.high = currentPrice;
                    currentCandle1Min.low = currentPrice;
                    currentCandle1Min.close = currentPrice;
                    currentCandle1Min.ticks = 1;
                    currentCandle1Min.timestamp = now;
                    currentCandle1Min.volume = 1;
                } else {
                    currentCandle1Min.high = Math.max(currentCandle1Min.high, currentPrice);
                    currentCandle1Min.low = Math.min(currentCandle1Min.low, currentPrice);
                    currentCandle1Min.close = currentPrice;
                    currentCandle1Min.ticks++;
                    currentCandle1Min.volume++;

                    if (now - currentCandle1Min.timestamp >= CANDLE_1MIN_MS) {
                        candle1MinHistory.push({ ...currentCandle1Min });
                        // Memory management: Keep only last 200 candles (200 minutes of 1-min data)
                        if (candle1MinHistory.length > 200) {
                            candle1MinHistory.shift();
                        }
                        currentCandle1Min = { open: 0, high: 0, low: 0, close: 0, ticks: 0, timestamp: 0, volume: 0 };
                    }
                }

                // Build 5-minute candles (only if needed)
                if (currentStrategy === 'multitime') {
                    if (currentCandle5Min.ticks === 0) {
                        currentCandle5Min.open = currentPrice;
                        currentCandle5Min.high = currentPrice;
                        currentCandle5Min.low = currentPrice;
                        currentCandle5Min.close = currentPrice;
                        currentCandle5Min.ticks = 1;
                        currentCandle5Min.timestamp = now;
                        currentCandle5Min.volume = 1;
                    } else {
                        currentCandle5Min.high = Math.max(currentCandle5Min.high, currentPrice);
                        currentCandle5Min.low = Math.min(currentCandle5Min.low, currentPrice);
                        currentCandle5Min.close = currentPrice;
                        currentCandle5Min.ticks++;
                        currentCandle5Min.volume++;

                        if (now - currentCandle5Min.timestamp >= CANDLE_5MIN_MS) {
                            candle5MinHistory.push({ ...currentCandle5Min });
                            currentCandle5Min = { open: 0, high: 0, low: 0, close: 0, ticks: 0, timestamp: 0, volume: 0 };
                        }
                    }
                }
                
                // NEW: Calculate ADX and RSI for filter usage (universal for all strategies)
                if (candle1MinHistory.length >= 15) {
                    const adxResult = calculateADX(candle1MinHistory, 14);
                    strategyIndicators.adx = adxResult.adx;
                    strategyIndicators.plusDI = adxResult.plusDI;
                    strategyIndicators.minusDI = adxResult.minusDI;
                    
                    const closes1Min = candle1MinHistory.map(c => c.close);
                    const rsi = calculateRSI(closes1Min, 14);
                    strategyIndicators.rsi = rsi;
                }
                
                const signal = analyzeMarketSignals();

                if (isAutoTrading && signal) {
                    // RACE CONDITION PROTECTION: Prevent overlapping trades
                    if (isProcessingTrade) {
                        addLog('‚ö†Ô∏è Trade already in progress, skipping signal', 'warning');
                        return;
                    }
                    
                    // RACE CONDITION PROTECTION: Check for active contracts
                    if (activeContracts.size > 0) {
                        addLog('‚ö†Ô∏è Active contract exists, waiting for settlement', 'warning');
                        return;
                    }
                    
                    const tradeNow = Date.now();
                    const cooldownSeconds = parseInt(document.getElementById('cooldownTimer').value) || 30;
                    const cooldownMs = cooldownSeconds * 1000;
                    
                    // ONE ENTRY PER SETUP: Already handled in analyzeMarketSignals()
                    // Signal has already been filtered if One Entry mode is active
                    
                    // COOLDOWN CHECK: Prevent trades too close together
                    if (tradeNow - lastTradeTime > cooldownMs) {
                        const reverseModeEnabled = document.getElementById('reverseMode').checked;
                        const alternatorEnabled = document.getElementById('alternatorMode').checked;
                        
                        // SIGNAL VALIDATION: Verify signal is valid
                        if (!signal || (signal !== 'BUY' && signal !== 'SELL')) {
                            addLog('‚ùå Invalid signal received, skipping trade', 'error');
                            return;
                        }
                        
                        addLog(`üéØ Executing Trade: ${signal}`, 'success');
                        if (reverseModeEnabled) {
                            addLog(`   ‚îî‚îÄ Reverse Mode: Active (signal was reversed from original)`, 'info');
                        }
                        if (alternatorEnabled) {
                            addLog(`   ‚îî‚îÄ Alternator Mode: Enforcing alternation (last: ${lastExecutedTradeType || 'None'})`, 'info');
                        }
                        
                        placeTrade(signal);
                        lastTradeTime = tradeNow;
                        lastExecutedTradeType = signal; // Track the final executed signal
                        
                        addLog(`‚è±Ô∏è Cooldown: ${cooldownSeconds}s started`, 'info');
                    } else {
                        const remainingCooldown = Math.ceil((cooldownMs - (tradeNow - lastTradeTime)) / 1000);
                        addLog(`‚è∏Ô∏è Cooldown active: ${remainingCooldown}s remaining`, 'warning');
                    }
                }
            }
            
            // ==================== VIRTUAL TICK COUNTING (Smart Filter) ====================
            if (smartFilterEnabled && isVirtualMode && virtualTradeType) {
                const selectedDuration = document.querySelector('input[name="durationType"]:checked');
                const durationType = selectedDuration ? selectedDuration.value : 't';
                
                if (durationType === 't') {
                    virtualTickCount++;
                    const targetTicks = parseInt(document.getElementById('durationValue').value);
                    if (virtualTickCount >= targetTicks) {
                        addLog(`üß™ Virtual trade: ${virtualTickCount}/${targetTicks} ticks completed`, 'info');
                        endVirtualTrade();
                    }
                }
            }
        }

        function subscribeToTicks(symbol) {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;
            ws.send(JSON.stringify({ forget_all: 'ticks' }));
            tickHistory = [];
            candle30SecHistory = [];
            candle1MinHistory = [];
            candle5MinHistory = [];
            currentCandle30Sec = { open: 0, high: 0, low: 0, close: 0, ticks: 0, timestamp: 0, volume: 0 };
            currentCandle1Min = { open: 0, high: 0, low: 0, close: 0, ticks: 0, timestamp: 0, volume: 0 };
            currentCandle5Min = { open: 0, high: 0, low: 0, close: 0, ticks: 0, timestamp: 0, volume: 0 };
            resetStrategyIndicators();
            currentMarketSymbol = symbol;
            ws.send(JSON.stringify({ ticks: symbol, subscribe: 1 }));
            updateTradeSignalDisplay();
            addLog(`Subscribed to ticks: ${symbol}`, 'info');
        }

        function placeTrade(tradeType) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                addLog('Not connected to Deriv API', 'error');
                return;
            }
            
            // FIXED: Prevent multiple simultaneous trade requests
            if (isProcessingTrade) {
                addLog('Trade already in progress, skipping...', 'warning');
                return;
            }
            
            isProcessingTrade = true;
            
            const selectedMarket = document.querySelector('input[name="market"]:checked');
            const market = selectedMarket ? selectedMarket.value : 'R_10';
            const stake = parseFloat(document.getElementById('stakeAmount').value);
            const selectedDuration = document.querySelector('input[name="durationType"]:checked');
            const durationType = selectedDuration ? selectedDuration.value : 't';
            const durationValue = parseInt(document.getElementById('durationValue').value);

            // ==================== VIRTUAL TRADE HANDLING (Smart Filter) ====================
            if (smartFilterEnabled && isVirtualMode) {
                // Send proposal for accurate payout
                isVirtualProposal = true;
                const proposal = {
                    proposal: 1, amount: stake, basis: 'stake',
                    contract_type: tradeType === 'BUY' ? 'CALL' : 'PUT',
                    currency: accountData.currency,
                    duration: durationValue, duration_unit: durationType, symbol: market
                };

                addLog(`üß™ Requesting proposal for virtual ${tradeType} - Stake: $${stake}, Duration: ${durationValue}${durationType}`, 'info');
                ws.send(JSON.stringify(proposal));
                
                // Handler moved to ws.onmessage for proposal
                return;
            }

            // ==================== NORMAL LIVE TRADE ====================
            const proposal = {
                proposal: 1, amount: stake, basis: 'stake',
                contract_type: tradeType === 'BUY' ? 'CALL' : 'PUT',
                currency: accountData.currency,
                duration: durationValue, duration_unit: durationType, symbol: market
            };

            addLog(`Placing ${tradeType} order for ${market} - Stake: $${stake}, Duration: ${durationValue}${durationType}`, 'info');
            ws.send(JSON.stringify(proposal));

            const proposalHandler = (msg) => {
                const data = JSON.parse(msg.data);
                if (data.msg_type === 'proposal') {
                    ws.removeEventListener('message', proposalHandler);
                    if (data.error) {
                        addLog(`Proposal error: ${data.error.message}`, 'error');
                        isProcessingTrade = false; // FIXED: Reset flag on error
                        return;
                    }
                    ws.send(JSON.stringify({ buy: data.proposal.id, price: stake }));
                    // Flag will be reset when we receive the 'buy' response
                }
            };
            ws.addEventListener('message', proposalHandler);
            setTimeout(() => { 
                ws.removeEventListener('message', proposalHandler); 
                isProcessingTrade = false; // FIXED: Reset flag after timeout
            }, 5000);
        }

        function handleBuyResponse(data) {
            if (data.buy) {
                const contractId = data.buy.contract_id;
                addLog(`Trade opened: Contract ID ${contractId}`, 'success');
                
                // FIXED: Reset processing flag after successful trade
                isProcessingTrade = false;
                
                // Subscribe to contract updates
                ws.send(JSON.stringify({ proposal_open_contract: 1, contract_id: contractId, subscribe: 1 }));
                
                // Track the contract (NEW)
                trackContract(contractId, {
                    buyPrice: data.buy.buy_price,
                    market: currentMarketSymbol,
                    type: data.buy.contract_type,
                    startTime: Date.now()
                });
            }
        }

        function handleContractUpdate(data) {
            const contract = data.proposal_open_contract;
            if (!contract) return;
            
            const contractId = contract.contract_id;
            
            // Update tracked contract status (NEW)
            if (activeContracts.has(contractId)) {
                const tracked = activeContracts.get(contractId);
                tracked.currentProfit = contract.profit;
                tracked.status = contract.status;
            }
            
            if (contract.status === 'sold' || contract.is_sold) {
                const profit = parseFloat(contract.profit);
                const isWin = profit > 0;
                stats.total++;
                stats.profitLoss += profit;
                if (isWin) stats.wins++; else stats.losses++;
                updateStatsDisplay();
                addTradeToHistory({
                    time: new Date().toLocaleTimeString(),
                    market: currentMarketSymbol || 'Unknown', // FIXED: Use currentMarketSymbol instead of non-existent element
                    type: contract.contract_type === 'CALL' ? 'RISE' : 'FALL',
                    stake: contract.buy_price,
                    result: profit,
                    isWin: isWin
                });
                addLog(`Trade closed: ${isWin ? 'WIN' : 'LOSS'} - P/L: ${profit.toFixed(2)}`, isWin ? 'success' : 'error');
                
                // Remove from tracking (NEW)
                removeContract(contractId);
                
                // ==================== SMART FILTER P/L TRACKING ====================
                if (smartFilterEnabled && !isVirtualMode) {
                    smartPL += profit;
                    
                    const absSmartPL = Math.abs(smartPL);
                    const isProfitHit = smartPL > 0 && smartPL >= smartTargetProfit;
                    const isLossHit = smartPL < 0 && absSmartPL >= smartTargetLoss;
                    
                    addLog(`üí∞ Smart P/L: $${smartPL.toFixed(2)} (Target: $${isProfitHit || isLossHit ? (isProfitHit ? smartTargetProfit : smartTargetLoss) : 'pending'})`, 'info');
                    
                    if (isProfitHit || isLossHit) {
                        toggleSmartReverse(!smartReverseActive); // Toggle on/off
                        smartPL = 0; // Reset for next cycle
                        addLog(`üéØ Smart target ${isProfitHit ? 'PROFIT' : 'LOSS'} hit! Toggling reverse mode and resetting smart P/L`, 'success');
                    }
                }
                
                checkRiskManagement();
            }
        }

        // NEW: Track contract with timeout protection
        function trackContract(contractId, details) {
            activeContracts.set(contractId, { ...details, startTime: Date.now() });
            addLog(`üìç Tracking contract: ${contractId}`, 'info');
            
            // Set timeout to force check if contract doesn't settle
            const timeoutId = setTimeout(() => {
                if (activeContracts.has(contractId)) {
                    addLog(`‚ö†Ô∏è Contract timeout: ${contractId} - Forcing check`, 'warning');
                    forceContractCheck(contractId);
                }
            }, CONTRACT_TIMEOUT_MS);
            
            contractTimeouts.set(contractId, timeoutId);
        }

        // NEW: Force check on potentially stuck contract
        function forceContractCheck(contractId) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    proposal_open_contract: 1,
                    contract_id: contractId
                }));
                addLog(`üîç Force checking contract: ${contractId}`, 'info');
            }
        }

        // NEW: Remove contract from tracking
        function removeContract(contractId) {
            if (contractTimeouts.has(contractId)) {
                clearTimeout(contractTimeouts.get(contractId));
                contractTimeouts.delete(contractId);
            }
            activeContracts.delete(contractId);
            addLog(`‚úÖ Contract removed from tracking: ${contractId}`, 'info');
        }

        // NEW: Start portfolio monitoring
        function startPortfolioMonitoring() {
            if (portfolioCheckInterval) return;
            
            portfolioCheckInterval = setInterval(() => {
                if (activeContracts.size > 0 && ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ portfolio: 1 }));
                    addLog(`üîÑ Portfolio check - Active: ${activeContracts.size} contracts`, 'info');
                }
            }, PORTFOLIO_CHECK_MS);
            
            addLog('üìä Portfolio monitoring started', 'info');
        }

        // NEW: Stop portfolio monitoring  
        function stopPortfolioMonitoring() {
            if (portfolioCheckInterval) {
                clearInterval(portfolioCheckInterval);
                portfolioCheckInterval = null;
                addLog('üìä Portfolio monitoring stopped', 'info');
            }
        }

        function checkRiskManagement() {
            const stopLoss = parseFloat(document.getElementById('stopLoss').value);
            const takeProfit = parseFloat(document.getElementById('takeProfit').value);
            
            if (stopLoss > 0 && Math.abs(stats.profitLoss) >= stopLoss && stats.profitLoss < 0) {
                addLog('Stop loss reached! Stopping auto trade.', 'error');
                stopAutoTrade();
            }
            if (takeProfit > 0 && stats.profitLoss >= takeProfit) {
                addLog('Take profit reached! Stopping auto trade.', 'success');
                stopAutoTrade();
            }
        }

        function addTradeToHistory(trade) {
            tradeHistory.unshift(trade);
            if (tradeHistory.length > 100) tradeHistory.pop();
            localStorage.setItem('benScalperTradeHistory', JSON.stringify(tradeHistory));
            updateTradeHistoryTable();
            addLog(`üìä Trade added to history: ${trade.type} on ${trade.market}`, 'info');
        }

        function addVirtualTradeToHistory(trade) {
            virtualTradeHistory.unshift(trade);
            if (virtualTradeHistory.length > 100) virtualTradeHistory.pop();
            localStorage.setItem('benScalperVirtualTradeHistory', JSON.stringify(virtualTradeHistory));
            updateVirtualHistoryTable();
            addLog(`üß™ Virtual trade added to history: ${trade.type} on ${trade.market}`, 'info');
        }

        function updateVirtualHistoryTable() {
            const tbody = document.getElementById('virtualTradeHistoryBody');
            if (!tbody) return;
            
            const countEl = document.getElementById('virtualTradeCount');
            if (countEl) countEl.textContent = `(${virtualTradeHistory.length})`;
            
            tbody.innerHTML = '';
            if (virtualTradeHistory.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #9ca3af;">No virtual trades yet</td></tr>';
                return;
            }
            
            virtualTradeHistory.slice(0, 50).forEach((trade, index) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${index + 1}</td>
                    <td>${trade.time || 'N/A'}</td>
                    <td>${trade.market || 'N/A'}</td>
                    <td>${trade.type || 'N/A'}</td>
                    <td>${parseFloat(trade.stake || 0).toFixed(2)}</td>
                    <td class="${trade.isWin ? 'result-win' : 'result-loss'}">
                        ${trade.isWin ? '+' : ''}${parseFloat(trade.result || 0).toFixed(2)}
                    </td>
                `;
                tbody.appendChild(row);
            });
        }

        function clearTradeHistory() {
            tradeHistory = [];
            localStorage.setItem('benScalperTradeHistory', JSON.stringify([]));
            
            // Clear virtual trade history too
            virtualTradeHistory = [];
            localStorage.setItem('benScalperVirtualTradeHistory', JSON.stringify([]));
            updateVirtualHistoryTable();
            
            stats.total = 0;
            stats.wins = 0;
            stats.losses = 0;
            stats.profitLoss = 0;
            
            updateStatsDisplay();
            updateTradeHistoryTable();
            addLog('Trade history and statistics cleared.', 'info');
        }

        function logout() {
            stopAutoTrade();
            stopPortfolioMonitoring(); // NEW
            
            // NEW: Clear all contract tracking
            activeContracts.forEach((_, contractId) => removeContract(contractId));
            activeContracts.clear();
            
            isExplicitLogout = true;
            sessionToken = null;
            if (ws) ws.close();
            
            localStorage.removeItem('derivApiToken');
            localStorage.removeItem('rememberToken');
            document.getElementById('rememberToken').checked = false;
            document.getElementById('apiToken').value = '';

            document.getElementById('accountInfo').style.display = 'none';
            disableTradeButtons();
            document.getElementById('loginCard').style.display = 'block';
            document.getElementById('signalMessage').textContent = '‚è≥ Waiting for connection...';

            const loginBtn = document.getElementById('loginBtn');
            loginBtn.disabled = false;
            loginBtn.innerHTML = '<span>üöÄ</span> Connect';
            
            updateConnectionStatus('disconnected');
            addLog('Logged out successfully.', 'success');
        }

        function updateStatsDisplay() {
            document.getElementById('totalTrades').textContent = stats.total;
            document.getElementById('winCount').textContent = stats.wins;
            document.getElementById('lossCount').textContent = stats.losses;
            document.getElementById('profitLoss').textContent = stats.profitLoss.toFixed(2);
            document.getElementById('profitLoss').style.color = stats.profitLoss >= 0 ? '#10b981' : '#ef4444';
        }

        function updateTradeHistoryTable() {
            const tbody = document.getElementById('tradeHistoryBody');
            if (!tbody) {
                console.error('Trade history table body not found!');
                return;
            }
            
            // FIXED: Update trade count display
            const tradeCountEl = document.getElementById('tradeCount');
            if (tradeCountEl) {
                tradeCountEl.textContent = `(${tradeHistory.length})`;
            }
            
            tbody.innerHTML = '';
            if (tradeHistory.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #9ca3af;">No trades yet</td></tr>';
                return;
            }
            
            try {
                tradeHistory.slice(0, 50).forEach((trade, index) => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${index + 1}</td>
                        <td>${trade.time || 'N/A'}</td>
                        <td>${trade.market || 'N/A'}</td>
                        <td>${trade.type || 'N/A'}</td>
                        <td>${parseFloat(trade.stake || 0).toFixed(2)}</td>
                        <td class="${trade.isWin ? 'result-win' : 'result-loss'}">
                            ${trade.isWin ? '+' : ''}${parseFloat(trade.result || 0).toFixed(2)}
                        </td>
                    `;
                    tbody.appendChild(row);
                });
            } catch (error) {
                console.error('Error updating trade history table:', error);
                tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #ef4444;">Error displaying trade history</td></tr>';
            }
        }

        function startAutoTrade() {
            if (isAutoTrading) return;
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                addLog('Cannot start auto trade: Not connected to Deriv API', 'error');
                return;
            }
            isAutoTrading = true;
            document.getElementById('autoTradeBtn').style.display = 'none';
            document.getElementById('stopAutoTradeBtn').style.display = 'inline-flex';
            document.getElementById('stopAutoTradeBtn').disabled = false;
            const cooldownSeconds = parseInt(document.getElementById('cooldownTimer').value) || 30;
            
            // Get strategy name from the checked radio button
            const strategyRadio = document.querySelector('input[name="strategy"]:checked');
            const strategyName = strategyRadio ? strategyRadio.nextElementSibling.textContent : currentStrategy;
            
            const alternatorEnabled = document.getElementById('alternatorMode').checked;
            const reverseModeEnabled = document.getElementById('reverseMode').checked;
            const oneEntryEnabled = document.getElementById('oneEntryMode').checked;
            
            addLog(`Auto trade started with ${strategyName} (Cooldown: ${cooldownSeconds}s)`, 'success');
            
            if (alternatorEnabled) {
                addLog(`üîÑ Alternator Mode: Active - Enforcing Buy-Sell alternation`, 'success');
            }
            if (reverseModeEnabled) {
                addLog(`üîÅ Reverse Mode: Active - Signals inverted (Buy‚ÜîSell)`, 'success');
            }
            if (oneEntryEnabled) {
                addLog(`üîí One Entry Per Setup: Active - Only one trade per pattern`, 'success');
            }
            
            
            if (!alternatorEnabled && !reverseModeEnabled && !oneEntryEnabled) {
                addLog(`‚ö†Ô∏è No filters active - Trading all strategy signals`, 'warning');
            }
        }

        function stopAutoTrade() {
            isAutoTrading = false;
            document.getElementById('autoTradeBtn').style.display = 'inline-flex';
            document.getElementById('stopAutoTradeBtn').style.display = 'none';
            
            // Reset smart filter when auto-trade stops
            if (smartFilterEnabled) {
                isFirstSmartTrade = true;
                isVirtualMode = true;
                smartPL = 0;
                resetVirtualVars();
                toggleSmartReverse(false);
                updateVirtualBadge(true);
                addLog('üß™ Smart Filter reset: Will start with virtual trade on next auto-trade', 'info');
            }
            
            addLog('Auto trade stopped', 'info');
        }

        // NEW: Periodic button state validator to fix stuck disabled state
        setInterval(() => {
            if (isAutoTrading) {
                const stopBtn = document.getElementById('stopAutoTradeBtn');
                // Ensure stop button is visible and enabled during auto-trading
                if (stopBtn.style.display === 'none' || stopBtn.disabled) {
                    stopBtn.style.display = 'inline-flex';
                    stopBtn.disabled = false;
                    addLog('üîß Stop button state corrected', 'warning');
                }
            }
        }, 5000); // Check every 5 seconds

        // Integrity check function
        function performIntegrityCheck() {
            const checks = [];
            
            // Check strategy selector
            checks.push(`‚úì Strategies: 2 available - Bounce, Breakout (Current: ${currentStrategy})`);

            // Check critical settings
            const criticalSettings = [
                'stakeAmount', 'durationValue', 
                'cooldownTimer', 'stopLoss', 'takeProfit',
                'alternatorMode', 'reverseMode', 'oneEntryMode'
            ];

            let settingsOK = 0;
            criticalSettings.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    settingsOK++;
                } else {
                    checks.push(`‚úó ${id}: MISSING`);
                }
            });
            checks.push(`‚úì Settings: ${settingsOK}/${criticalSettings.length} present`);

            // Check buttons
            const buttons = ['buyBtn', 'sellBtn', 'autoTradeBtn', 'stopAutoTradeBtn', 
                           'logoutBtn', 'clearHistoryBtn'];
            let buttonCount = 0;
            buttons.forEach(id => {
                if (document.getElementById(id)) {
                    buttonCount++;
                }
            });
            checks.push(`‚úì Buttons: ${buttonCount}/${buttons.length} present`);

            // Check system state
            checks.push(ws && ws.readyState === WebSocket.OPEN ? '‚úì WebSocket: Connected' : '‚úì WebSocket: Disconnected');
            checks.push(isAutoTrading ? '‚úì Auto-trading: Active' : '‚úì Auto-trading: Inactive');
            checks.push(`‚úì Trade History: ${tradeHistory.length} records`);
            checks.push(`‚úì Tick History: ${tickHistory.length} ticks (Max: 1000)`);
            checks.push(`‚úì 30-Sec Candles: ${candle30SecHistory.length} (Unlimited)`);
            checks.push(`‚úì 1-Min Candles: ${candle1MinHistory.length} (Unlimited)`);
            checks.push(`‚úì 5-Min Candles: ${candle5MinHistory.length} (Unlimited)`);
            checks.push(`‚úì Alternator Mode: ${document.getElementById('alternatorMode').checked ? 'ON' : 'OFF'}`);
            checks.push(`‚úì Reverse Mode: ${document.getElementById('reverseMode').checked ? 'ON' : 'OFF'}`);
            checks.push(`‚úì One Entry Per Setup: ${document.getElementById('oneEntryMode').checked ? 'ON' : 'OFF'}`);
            checks.push(`‚úì Last Trade Type: ${lastExecutedTradeType || 'None'}`);
            checks.push(`‚úì Fast Candle Collection: ACTIVE (Real-time tick processing)`);
            checks.push(`‚úì Signal Status Display: ENHANCED (Bright & Readable)`);
            checks.push(`‚úì Active Strategies: Bounce, Breakout`);
            checks.push(`‚úì Double-Click Protection: Enabled for Logout & Clear History`);

            console.log('=== INTEGRITY CHECK ===');
            checks.forEach(check => console.log(check));
            console.log('======================');

            return checks;
        }

        // Event Listeners
        document.getElementById('loginBtn').addEventListener('click', async () => {
            const apiToken = document.getElementById('apiToken').value.trim();
            if (!apiToken) {
                addLog('Please enter your API token', 'error');
                return;
            }
            const loginBtn = document.getElementById('loginBtn');
            loginBtn.disabled = true;
            loginBtn.textContent = 'Connecting...';
            addLog('Attempting to connect to Deriv API...', 'info');
            try {
                await connectToDerivAPI(apiToken);
                saveSettings();
                addLog('Login successful! Ready to trade.', 'success');
            } catch (error) {
                addLog('Login failed.', 'error');
                loginBtn.disabled = false;
                loginBtn.innerHTML = '<span>üöÄ</span> Connect';
            }
        });

        document.getElementById('buyBtn').addEventListener('click', () => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                placeTrade('BUY');
                lastExecutedTradeType = 'BUY';
                addLog('Manual BUY button clicked', 'info');
            } else {
                addLog('Cannot place trade: Not connected to Deriv API', 'error');
            }
        });

        document.getElementById('sellBtn').addEventListener('click', () => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                placeTrade('SELL');
                lastExecutedTradeType = 'SELL';
                addLog('Manual SELL button clicked', 'info');
            } else {
                addLog('Cannot place trade: Not connected to Deriv API', 'error');
            }
        });

        document.getElementById('autoTradeBtn').addEventListener('click', () => {
            startAutoTrade();
            addLog('Auto Trade button clicked', 'info');
        });

        document.getElementById('stopAutoTradeBtn').addEventListener('click', () => {
            stopAutoTrade();
            addLog('Stop Auto Trade button clicked', 'info');
        });

        // Timeframe Selection
        document.querySelectorAll('input[name="timeframe"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                currentTimeframe = e.target.value;
                const timeframeName = currentTimeframe === '1min' ? '1 Minute' : '30 Second';
                addLog(`‚è±Ô∏è Timeframe changed to: ${timeframeName} candles`, 'success');
                
                // Update strategy description to reflect new timeframe
                updateStrategyDescription();
            });
        });

        // NEW: Event listeners for mode toggles with logging
        document.getElementById('alternatorMode').addEventListener('change', (e) => {
            if (e.target.checked) {
                addLog('üîÑ Alternator Mode: ENABLED - Will enforce BUY/SELL alternation', 'success');
                if (lastExecutedTradeType) {
                    const nextExpected = lastExecutedTradeType === 'BUY' ? 'SELL' : 'BUY';
                    addLog(`   ‚îî‚îÄ Last trade: ${lastExecutedTradeType} | Next allowed: ${nextExpected}`, 'info');
                }
            } else {
                addLog('üîÑ Alternator Mode: DISABLED', 'warning');
            }
        });

        document.getElementById('reverseMode').addEventListener('change', (e) => {
            if (e.target.checked) {
                addLog('üîÅ Reverse Mode: ENABLED - All signals will be inverted (BUY‚ÜîSELL)', 'success');
            } else {
                addLog('üîÅ Reverse Mode: DISABLED', 'warning');
            }
        });

        document.getElementById('oneEntryMode').addEventListener('change', (e) => {
            if (e.target.checked) {
                addLog('üîí One Entry Per Setup: ENABLED - Only one trade per pattern', 'success');
            } else {
                addLog('üîí One Entry Per Setup: DISABLED', 'warning');
            }
        });

        // Single Market Radio Changes
        document.querySelectorAll('input[name="market"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    subscribeToMarket(e.target.value);
                }
            });
        });

        // Double-click logout with visual feedback
        let logoutClickCount = 0;
        let logoutClickTimer = null;
        document.getElementById('logoutBtn').addEventListener('click', () => {
            logoutClickCount++;
            
            const logoutBtn = document.getElementById('logoutBtn');
            
            if (logoutClickCount === 1) {
                // First click - change appearance and show warning
                logoutBtn.style.background = 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)';
                logoutBtn.textContent = 'Are you sure?';
                addLog('Logout: Click again to confirm', 'warning');
                
                // Reset after 3 seconds
                logoutClickTimer = setTimeout(() => {
                    logoutClickCount = 0;
                    logoutBtn.style.background = '';
                    logoutBtn.textContent = 'Logout';
                }, 3000);
            } else if (logoutClickCount === 2) {
                // Second click - execute logout
                clearTimeout(logoutClickTimer);
                logoutClickCount = 0;
                logoutBtn.style.background = '';
                logoutBtn.textContent = 'Logout';
                addLog('Logout confirmed', 'info');
                logout();
            }
        });

        // Double-click clear history with visual feedback
        let clearClickCount = 0;
        let clearClickTimer = null;
        document.getElementById('clearHistoryBtn').addEventListener('click', () => {
            clearClickCount++;
            
            const clearBtn = document.getElementById('clearHistoryBtn');
            
            if (clearClickCount === 1) {
                // First click - change appearance and show warning
                clearBtn.style.background = 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)';
                clearBtn.textContent = 'Are you sure?';
                addLog('Clear History: Click again to confirm', 'warning');
                
                // Reset after 3 seconds
                clearClickTimer = setTimeout(() => {
                    clearClickCount = 0;
                    clearBtn.style.background = '';
                    clearBtn.textContent = 'Clear History';
                }, 3000);
            } else if (clearClickCount === 2) {
                // Second click - execute clear
                clearTimeout(clearClickTimer);
                clearClickCount = 0;
                clearBtn.style.background = '';
                clearBtn.textContent = 'Clear History';
                addLog('Clear history confirmed', 'info');
                clearTradeHistory();
            }
        });

        // Initialize on load
        window.addEventListener('load', async () => {
            loadSettings();
            updateStrategyDescription();
            
            // Initialize virtual trade history
            updateVirtualHistoryTable();
            if (smartFilterEnabled) {
                document.getElementById('virtualTradeHistory').style.display = 'block';
            }
            
            addLog('Ben Scalper Bot initialized', 'success');
            addLog('‚úÖ Contract Settlement Monitoring: ENABLED', 'success');
            addLog('‚úÖ Timeout Protection: 90 seconds', 'info');
            addLog('‚úÖ Portfolio Fallback Checks: Every 30 seconds', 'info');
            addLog('‚úÖ 2 Professional Trading Strategies loaded', 'success');
            addLog('  1. The Bounce Strategy (Trend Continuation)', 'info');
            addLog('  2. The Breakout Strategy (Trend Reversal)', 'info');
            addLog('‚úÖ Timeframe Selection: 1-Minute or 30-Second candles', 'success');
            addLog('üìä Memory-Managed Candle Storage: 200 candles max per timeframe', 'info');
            addLog('Fast data processing active - Real-time tick processing', 'info');

            const savedToken = localStorage.getItem('derivApiToken');
            const rememberToken = localStorage.getItem('rememberToken') === 'true';

            if (savedToken && rememberToken) {
                addLog('Auto-login: Connecting with saved token...', 'info');
                const loginBtn = document.getElementById('loginBtn');
                loginBtn.disabled = true;
                loginBtn.textContent = 'Connecting...';
                
                try {
                    await connectToDerivAPI(savedToken);
                    addLog('Auto-login successful!', 'success');
                } catch (error) {
                    addLog('Auto-login failed. Please connect manually.', 'error');
                    loginBtn.disabled = false;
                    loginBtn.innerHTML = '<span>üöÄ</span> Connect';
                }
            }

            // Run integrity check after initialization
            setTimeout(() => {
                const checks = performIntegrityCheck();
                addLog('=== INTEGRITY CHECK COMPLETE ===', 'success');
                addLog(`Total checks: ${checks.length}`, 'info');
                addLog(`Strategy: ${currentStrategy}`, 'info');
                addLog(`Available Strategies: 2 (Bounce, Breakout)`, 'info');
                addLog(`Markets configured: ${availableMarkets.length}`, 'info');
                addLog(`Alternator Mode: ${document.getElementById('alternatorMode').checked ? 'ON' : 'OFF'}`, 'info');
                addLog(`Reverse Mode: ${document.getElementById('reverseMode').checked ? 'ON' : 'OFF'}`, 'info');
                addLog(`One Entry Per Setup: ${document.getElementById('oneEntryMode').checked ? 'ON' : 'OFF'}`, 'info');
                addLog(`Candle Memory Management: 200 candles per timeframe (prevents memory leaks)`, 'info');
                addLog(`Signal Display: ENHANCED (Bright & Clear)`, 'success');
                addLog(`All systems operational`, 'success');
                addLog('================================', 'success');
            }, 2000);
        });

        window.addEventListener('beforeunload', () => {
            addLog('Window closing - Cleaning up connections', 'info');
            if (ws) ws.close();
            if (sessionTimerInterval) clearInterval(sessionTimerInterval);
        });

        // Final initialization log
        addLog('=== BOT CONFIGURATION ===', 'success');
        addLog('Strategy System: 2 Strategies Available', 'info');
        addLog('  ‚Ä¢ The Bounce Strategy (Trend Continuation)', 'info');
        addLog('  ‚Ä¢ The Breakout Strategy (Trend Reversal)', 'info');
        addLog('Risk Management: Enabled', 'info');
        addLog('Alternator Mode: Available', 'info');
        addLog('Reverse Mode: Available', 'info');
        addLog('One Entry Per Setup: Available', 'info');
        addLog('Auto-Trade: Available', 'info');
        addLog('Manual Trading: Available', 'info');
        addLog('Candle Collection: UNLIMITED', 'info');
        addLog('Fast Processing: REAL-TIME (Every tick)', 'info');
        addLog('Signal Display: ENHANCED & READABLE', 'info');
        addLog('Double-Click Protection: Logout & Clear History', 'info');
        addLog('Activity Logging: Enhanced', 'info');
        addLog('=========================', 'success');

        // Show live filter summary on startup
        setTimeout(() => {
            updateActiveFiltersSummary();
        }, 800);
    </script>
</body>
</html>