<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Deriv Digit Over 5 Pro - Advanced ML Edition</title>
<style>
/* --- STYLES PRESERVED --- */
body { background: #020617; color: #e5e7eb; font-family: system-ui, -apple-system, sans-serif; margin: 0; padding: 0; }
.app { max-width: 420px; margin: auto; padding: 15px; }
.card { background: #0f172a; padding: 12px; border-radius: 12px; margin-bottom: 12px; border: 1px solid #1e293b; }
h2, h3 { text-align: center; margin-bottom: 8px; margin-top: 8px; }
h2 { color: #22c55e; }
label { font-size: 13px; opacity: 0.8; display: block; margin-top: 8px; }
input, select, button { width: 100%; padding: 10px; margin: 5px 0 10px; border-radius: 8px; border: none; box-sizing: border-box; }
input, select { background: #1e293b; color: #e5e7eb; border: 1px solid #334155; }
input:focus, select:focus { outline: none; border-color: #22c55e; }
button { background: #22c55e; color: #020617; font-weight: 700; cursor: pointer; transition: all 0.2s; }
button:hover { background: #16a34a; transform: translateY(-1px); }
button:active { transform: translateY(0); }
button:disabled { background: #374151; cursor: not-allowed; opacity: 0.5; }
.buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 12px; }
.status-container { display: flex; gap: 5px; margin-bottom: 10px; }
.status { flex: 2; text-align: center; padding: 8px; border-radius: 8px; font-weight: 600; }
.account-type { flex: 1.5; text-align: center; padding: 8px; border-radius: 8px; font-weight: 700; font-size: 11px; display: none; text-transform: uppercase; align-self: center; }
.demo-badge { background: #f59e0b; color: #020617; }
.live-badge { background: #22c55e; color: #020617; }
.connected { background: #16a34a; color: white; }
.disconnected { background: #dc2626; color: white; }
.stats { display: grid; grid-template-columns: repeat(4, 1fr); text-align: center; gap: 10px; }
.stats > div { display: flex; flex-direction: column; gap: 5px; }
.stats span { font-size: 12px; opacity: 0.7; }
.stats b { font-size: 16px; color: #22c55e; }
.table-container { overflow-x: auto; max-height: 300px; overflow-y: auto; }
table { width: 100%; font-size: 13px; border-collapse: collapse; }
thead { position: sticky; top: 0; background: #1e293b; }
th { padding: 8px; text-align: left; font-weight: 600; border-bottom: 2px solid #334155; }
td { padding: 8px; border-bottom: 1px solid #1e293b; }
tbody tr:hover { background: #1e293b; }
.win { color: #22c55e; }
.loss { color: #ef4444; }
.balance-display { text-align: center; padding: 10px; background: #0f172a; border-radius: 8px; margin-bottom: 10px; border: 1px solid #1e293b; }
.balance-display span { opacity: 0.7; font-size: 14px; }
.balance-display b { color: #22c55e; font-size: 18px; margin: 0 5px; }
.session-timer { margin-top: 8px; font-size: 12px; color: #f59e0b; font-weight: 600; }
.shutdown-timer { font-size: 12px; color: #ef4444; font-weight: 700; margin-top: 4px; display: none; }
.reset-button-permanent { background: #f59e0b !important; width: 100%; margin-bottom: 12px; font-size: 15px; display: block; }
.reset-button-permanent:hover { background: #d97706 !important; }
.analyzer-grid { display: grid; grid-template-columns: repeat(10, 1fr); gap: 5px; margin: 10px 0; }
.digit-box { aspect-ratio: 1; display: flex; align-items: center; justify-content: center; border-radius: 6px; font-weight: 700; font-size: 14px; border: 2px solid transparent; }
.digit-over { background: #22c55e; color: #020617; }
.digit-under { background: #ef4444; color: white; }
.analyzer-stats { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; text-align: center; margin-top: 10px; }
.analyzer-stats > div { background: #1e293b; padding: 8px; border-radius: 6px; }
.analyzer-stats span { font-size: 11px; opacity: 0.7; display: block; }
.analyzer-stats b { font-size: 18px; display: block; margin-top: 3px; }
.log-container { background: #020617; border: 1px solid #1e293b; border-radius: 6px; height: 120px; overflow-y: auto; padding: 8px; font-family: 'Courier New', monospace; font-size: 11px; margin-top: 10px; }
.log-entry { margin-bottom: 4px; border-bottom: 1px solid #1e293b; padding-bottom: 2px; }
.log-time { color: #94a3b8; margin-right: 5px; }
.log-msg-info { color: #3b82f6; }
.log-msg-success { color: #22c55e; }
.log-msg-error { color: #ef4444; }
.log-msg-warn { color: #f59e0b; }
.btn-cycle { background: #3b82f6; color: white; margin-bottom: 5px; font-size: 14px; }
.btn-cycle.active { background: #8b5cf6; border: 2px solid #fff; }
.btn-cooldown { background: #475569; color: white; margin-bottom: 5px; font-size: 14px; }
.btn-cooldown.active { background: #f59e0b; color: #020617; border: 2px solid #020617; }
.btn-reverse { background: #334155; color: white; margin-bottom: 12px; font-size: 14px; }
.btn-reverse.active { background: #f43f5e; }
.cycle-timer-display { color: #f59e0b; font-size: 13px; font-weight: bold; text-align: center; margin-bottom: 10px; display: none; padding: 8px; border: 2px dashed #f59e0b; border-radius: 8px; background: rgba(245, 158, 11, 0.1); }
.specific-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; margin-bottom: 10px; }
.specific-grid input { text-align: center; padding: 8px 0; margin: 0; }
.window-timer { margin-top: 10px; font-size: 12px; text-align: center; font-weight: 800; padding: 8px; border-radius: 6px; background: #020617; border: 2px solid #334155; transition: all 0.3s; }

/* Sequence UI Styles */
.sequence-slot { background: #1e293b; border: 1px solid #334155; border-radius: 8px; padding: 10px; margin-bottom: 10px; }
.sequence-slot-title { font-size: 11px; font-weight: 700; color: #3b82f6; margin-bottom: 5px; text-transform: uppercase; }
.seq-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px; }
.seq-grid input { font-size: 11px; padding: 5px; margin: 0; }

/* ML Enhancement Styles */
.ml-indicator { display: inline-block; padding: 3px 8px; border-radius: 4px; font-size: 10px; font-weight: 700; margin-left: 5px; }
.ml-learning { background: #8b5cf6; color: white; }
.ml-active { background: #22c55e; color: #020617; }
.advanced-stats { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-top: 8px; font-size: 10px; }
.advanced-stats > div { background: #020617; padding: 5px; border-radius: 4px; text-align: center; }
</style>
</head>
<body>
<div class="app">

<h2>Deriv Digit Over 5 Pro <span class="ml-indicator ml-active">ML Enhanced</span></h2>

<div class="status-container">
    <div id="status" class="status disconnected">Disconnected</div>
    <div id="accountType" class="account-type"></div>
</div>

<div id="balanceDisplay" class="balance-display" style="display:none;">
  <span>Balance:</span>
  <b id="balance">0.00</b>
  <span id="balanceCurrency">USD</span>
  <div id="sessionTimer" class="session-timer">Session: 00:00:00</div>
  <div id="shutdownDisplay" class="shutdown-timer">Shutdown in: --:--:--</div>
</div>

<div class="card">
  <input id="token" type="password" placeholder="Deriv API Token" required>
  <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <button onclick="connect()">Login</button>
    <button id="logoutBtn" style="background: #ef4444;">Logout</button>
  </div>
</div>

<div class="card">
  <h3>ðŸ“Š Advanced ML Analyzer</h3>
  <div class="analyzer-grid" id="digitDisplay"></div>
  <div class="analyzer-stats">
    <div><span>Over 5</span><b id="overCount" style="color: #22c55e;">0</b></div>
    <div><span>Total Ticks</span><b id="totalCount" style="color: #e5e7eb;">0</b></div>
    <div><span>Over %</span><b id="overPercent" style="color: #22c55e;">0%</b></div>
  </div>
  
  <div style="margin-top: 10px; padding: 12px; background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%); border-radius: 8px; border: 2px solid #22c55e;">
    <div style="font-size: 14px; font-weight: 700; margin-bottom: 10px; color: #22c55e;">ðŸ”® ML Prediction Engine</div>
    
    <div id="signalTimerDisplay" class="window-timer">SYNCING CLOCK...</div>

    <div style="background: #0f172a; padding: 10px; border-radius: 6px; margin-bottom: 8px; margin-top: 8px;">
      <div style="font-size: 11px; opacity: 0.7; margin-bottom: 5px;">Next Digit Prediction:</div>
      <div style="font-size: 24px; font-weight: 700; text-align: center;" id="nextDigitPrediction">-</div>
      <div style="font-size: 11px; text-align: center; margin-top: 5px;" id="predictionConfidence">-</div>
    </div>
    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; font-size: 11px;">
      <div style="background: #1e293b; padding: 6px; border-radius: 4px; text-align: center;"><div>Freq Bias</div><b id="freqScore" style="color: #22c55e;">0%</b></div>
      <div style="background: #1e293b; padding: 6px; border-radius: 4px; text-align: center;"><div>Gap Count</div><b id="cycleScore" style="color: #3b82f6;">0</b></div>
      <div style="background: #1e293b; padding: 6px; border-radius: 4px; text-align: center;"><div>Volatility</div><b id="volatilityScore" style="color: #f59e0b;">Low</b></div>
    </div>
    
    <div class="advanced-stats">
      <div><span style="opacity:0.6">Bayesian Prob</span><b id="bayesianProb" style="color:#8b5cf6">50%</b></div>
      <div><span style="opacity:0.6">Markov Pred</span><b id="markovProb" style="color:#3b82f6">50%</b></div>
      <div><span style="opacity:0.6">Ensemble</span><b id="ensembleScore" style="color:#22c55e">50%</b></div>
      <div><span style="opacity:0.6">Confidence Adj</span><b id="confAdj" style="color:#f59e0b">0%</b></div>
    </div>
    
    <div style="margin-top: 8px; font-size: 11px; opacity: 0.7; text-align: center;" id="patternMatch">Analyzing patterns...</div>
    
    <div style="margin-top: 15px; border-top: 1px solid #334155; padding-top: 10px;">
        <div style="font-size: 12px; font-weight: 600; color: #94a3b8; display: flex; justify-content: space-between;">
            <span>SYSTEM & TRADE LOG</span>
            <span style="cursor:pointer; color:#3b82f6" onclick="document.getElementById('logContainer').innerHTML=''">Clear</span>
        </div>
        <div class="log-container" id="logContainer">
            <div class="log-entry"><span class="log-time">[System]</span> <span class="log-msg-success">ML Engine Ready.</span></div>
        </div>
    </div>
  </div>
</div>

<div class="card">
  <h3>Trade Settings</h3>
  <label>Stake ($)</label>
  <input id="stake" class="save-setting" type="number" value="1" min="0.35" step="0.01">
  <label>Duration (Ticks)</label>
  <input id="duration" class="save-setting" type="number" value="1" min="1" max="10">
  <label>Cooldown (seconds)</label>
  <input id="cooldown" class="save-setting" type="number" value="2" min="1">
  
  <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <div>
      <label>Window: Closing (Sec)</label>
      <input id="closingSec" class="save-setting" type="number" value="10" min="1" max="59">
    </div>
    <div>
      <label>Window: Opening (Sec)</label>
      <input id="openingSec" class="save-setting" type="number" value="10" min="1" max="59">
    </div>
  </div>

  <label>Confidence Selection Mode</label>
  <select id="confidenceMode" class="save-setting" onchange="toggleConfidenceUI()">
      <option value="range">Mode 1: Range (Min-Max)</option>
      <option value="specific">Mode 2: Specific Numbers (Pick 5)</option>
      <option value="sequence">Mode 3: Sequence Pattern (3 Slots)</option>
  </select>

  <div id="rangeUI">
      <label>Confidence Range (Min - Max %)</label>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
        <input id="minConfidence" class="save-setting" type="number" value="55" min="0" max="100" placeholder="Min">
        <input id="maxConfidence" class="save-setting" type="number" value="70" min="0" max="100" placeholder="Max">
      </div>
  </div>

  <div id="specificUI" style="display:none;">
      <label>Specific Target Numbers</label>
      <div class="specific-grid">
          <input id="spec1" class="save-setting" type="number" value="10" min="0" max="100">
          <input id="spec2" class="save-setting" type="number" value="25" min="0" max="100">
          <input id="spec3" class="save-setting" type="number" value="49" min="0" max="100">
          <input id="spec4" class="save-setting" type="number" value="50" min="0" max="100">
          <input id="spec5" class="save-setting" type="number" value="65" min="0" max="100">
      </div>
  </div>

  <div id="sequenceUI" style="display:none;">
      <label>Sequence Slots Logic</label>
      
      <div class="sequence-slot">
          <div class="sequence-slot-title">Slot 1</div>
          <div class="seq-grid">
              <div><span style="font-size:9px">1st Pred >=</span><input id="s1_p1_min" class="save-setting" type="number" value="40"></div>
              <div><span style="font-size:9px">2nd Pred >=</span><input id="s1_p2_min" class="save-setting" type="number" value="50"></div>
              <div><span style="font-size:9px">2nd Pred <=</span><input id="s1_p2_max" class="save-setting" type="number" value="98"></div>
          </div>
      </div>

      <div class="sequence-slot">
          <div class="sequence-slot-title">Slot 2</div>
          <div class="seq-grid">
              <div><span style="font-size:9px">1st Pred >=</span><input id="s2_p1_min" class="save-setting" type="number" value="15"></div>
              <div><span style="font-size:9px">2nd Pred >=</span><input id="s2_p2_min" class="save-setting" type="number" value="60"></div>
              <div><span style="font-size:9px">2nd Pred <=</span><input id="s2_p2_max" class="save-setting" type="number" value="98"></div>
          </div>
      </div>

      <div class="sequence-slot">
          <div class="sequence-slot-title">Slot 3</div>
          <div class="seq-grid">
              <div><span style="font-size:9px">1st Pred >=</span><input id="s3_p1_min" class="save-setting" type="number" value="50"></div>
              <div><span style="font-size:9px">2nd Pred >=</span><input id="s3_p2_min" class="save-setting" type="number" value="50"></div>
              <div><span style="font-size:9px">2nd Pred <=</span><input id="s3_p2_max" class="save-setting" type="number" value="98"></div>
          </div>
      </div>
  </div>

  <label>Market</label>
  <select id="market" class="save-setting">
    <option value="R_10">R_10</option>
    <option value="R_25">R_25</option>
    <option value="R_50">R_50</option>
    <option value="R_75">R_75</option>
    <option value="R_100">R_100</option>
  </select>
</div>

<div class="card">
  <h3>Risk Management</h3>
  <label>Stop Loss ($)</label>
  <input id="stoploss" class="save-setting" type="number" value="10" min="1">
  <label>Take Profit ($)</label>
  <input id="takeprofit" class="save-setting" type="number" value="10" min="1">
  <label>Auto Trade Duration (Hours) - [0 = Unlimited]</label>
  <input id="autoDurationHrs" class="save-setting" type="number" value="1" min="0" step="0.01">
</div>

<button onclick="toggleMarketCycle()" id="cycleBtn" class="btn-cycle">Auto Market Cycle: OFF</button>
<button onclick="toggleCooldownLoop()" id="cooldownBtn" class="btn-cooldown">Cycle Cooldown Loop: OFF</button>
<div id="cycleTimerDisplay" class="cycle-timer-display">Next Loop in: --:--</div>

<div class="card" style="margin-top: 0;">
  <label>Wait Time (Minutes)</label>
  <input id="cycleWaitTime" class="save-setting" type="number" value="5" min="1">
</div>

<button onclick="toggleReverseTrade()" id="reverseBtn" class="btn-reverse">Reverse Trade: OFF</button>

<div class="buttons">
  <button onclick="manualTrade()" id="manualBtn">Manual Trade</button>
  <button onclick="toggleAuto()" id="autoBtn">Start Auto</button>
</div>

<button onclick="resetStats()" class="reset-button-permanent">ðŸ”„ Reset All Stats</button>

<div class="card stats">
  <div><span>Trades</span><b id="trades">0</b></div>
  <div><span>Wins</span><b id="wins">0</b></div>
  <div><span>Losses</span><b id="losses">0</b></div>
  <div><span>P/L</span><b id="profit">0.00</b></div>
</div>

<div class="card">
<h3>Trade History</h3>
<div class="table-container">
<table>
<thead><tr><th>#</th><th>Result</th><th>P/L</th><th>Market</th></tr></thead>
<tbody id="history"></tbody>
</table>
</div>
</div>

</div>

<script>
// ============ CORE VARIABLES ============
let ws = null;
let isConnected = false;
let isAutoRunning = false;
let currentContractId = null;
let accountBalance = 0;
let stats = { trades: 0, wins: 0, losses: 0, profit: 0 };
let digitHistory = [];
let sessionStartTime = null;
let autoStartTime = null; 
let timerIntervalId = null;
let isExplicitLogout = false;
let lastPredictionConfidence = 0; 
let previousPredictionConfidence = 0;
let lastPredictionType = '-';
let lastTradeTime = 0;
let lastRequestTime = 0; 

let isMarketCycleActive = false;
let isCooldownLoopActive = false;
let isCycleCooldown = false;
const marketSequence = ["R_10", "R_25", "R_50", "R_75", "R_100"];
let currentMarketIndex = 0;
let isReverseTradeActive = false;
let cycleTimerId = null;
let isSignalWindowOpen = false;

// ============ ML ENHANCEMENT VARIABLES ============
let bayesianAlpha = 1; // Prior for over-5
let bayesianBeta = 1;  // Prior for under-5
let markovTransitionMatrix = {}; // State transitions
let recentWinRates = []; // For adaptive thresholds
let extendedHistory = []; // Store up to 1000 digits
let patternCache = {}; // Cache for pattern recognition
let volatilityWindow = []; // For volatility calculation

// ============ UTILITY FUNCTIONS ============
function addLog(msg, type = 'info') {
    const container = document.getElementById('logContainer');
    const time = new Date().toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
    const entry = document.createElement('div');
    entry.className = 'log-entry';
    entry.innerHTML = `<span class="log-time">[${time}]</span> <span class="log-msg-${type}">${msg}</span>`;
    container.appendChild(entry);
    container.scrollTop = container.scrollHeight;
}

function updateSignalWindowTimer() {
    const now = new Date();
    const sec = now.getSeconds();
    const timerEl = document.getElementById('signalTimerDisplay');
    
    const closeWindowSize = parseInt(document.getElementById('closingSec').value) || 10;
    const openWindowSize = parseInt(document.getElementById('openingSec').value) || 10;
    
    const inClosingWindow = (sec >= (60 - closeWindowSize));
    const inOpeningWindow = (sec <= openWindowSize);
    
    if (inClosingWindow || inOpeningWindow) {
        isSignalWindowOpen = true;
        if (timerEl) {
            timerEl.style.color = "#22c55e";
            timerEl.style.borderColor = "#22c55e";
            timerEl.style.background = "rgba(34, 197, 94, 0.1)";
            timerEl.innerHTML = `SCANNING SIGNAL... (${sec}s)`;
        }
    } else {
        isSignalWindowOpen = false;
        const nextWindowIn = (60 - closeWindowSize) - sec;
        if (timerEl) {
            timerEl.style.color = "#f59e0b";
            timerEl.style.borderColor = "#334155";
            timerEl.style.background = "#020617";
            timerEl.innerHTML = `WAITING FOR WINDOW: ${nextWindowIn}s`;
        }
    }
}

function toggleConfidenceUI() {
    const mode = document.getElementById('confidenceMode').value;
    document.getElementById('rangeUI').style.display = (mode === 'range') ? 'block' : 'none';
    document.getElementById('specificUI').style.display = (mode === 'specific') ? 'block' : 'none';
    document.getElementById('sequenceUI').style.display = (mode === 'sequence') ? 'block' : 'none';
    addLog(`Confidence Mode: ${mode}`, "info");
}

function saveSettings() {
    const settings = {};
    document.querySelectorAll('.save-setting').forEach(el => settings[el.id] = el.value);
    localStorage.setItem('bot_settings_v8_ml', JSON.stringify(settings));
}

function loadSettings() {
    const saved = localStorage.getItem('bot_settings_v8_ml');
    if (saved) {
        const settings = JSON.parse(saved);
        for (const id in settings) {
            const el = document.getElementById(id);
            if (el) el.value = settings[id];
        }
    }
    toggleConfidenceUI();
    
    // Load extended history
    const savedExtHistory = localStorage.getItem('extended_history_v8');
    if(savedExtHistory) {
        extendedHistory = JSON.parse(savedExtHistory);
        addLog(`Loaded ${extendedHistory.length} historical ticks for ML`, "success");
    }
    
    // Restore trade history
    const savedHistory = localStorage.getItem('trade_history_v8');
    if(savedHistory) document.getElementById('history').innerHTML = savedHistory;
    
    const savedStats = localStorage.getItem('trade_stats_v8');
    if(savedStats) { 
        stats = JSON.parse(savedStats); 
        updateStats(); 
    }
    
    // Load ML parameters
    const savedBayesian = localStorage.getItem('bayesian_params_v8');
    if(savedBayesian) {
        const params = JSON.parse(savedBayesian);
        bayesianAlpha = params.alpha || 1;
        bayesianBeta = params.beta || 1;
    }
}

document.querySelectorAll('.save-setting').forEach(el => {
    el.addEventListener('input', saveSettings);
    el.addEventListener('change', saveSettings);
});

// ============ WEBSOCKET CONNECTION ============
function connect() {
  const token = document.getElementById('token').value.trim();
  if (!token) { addLog("Error: API Token missing.", "error"); return; }
  if (ws) ws.close();
  sessionStorage.setItem('derivToken', token);
  isExplicitLogout = false;
  updateStatus('Connecting...', 'disconnected');
  ws = new WebSocket('wss://ws.derivws.com/websockets/v3?app_id=1089');
  ws.onopen = () => { addLog("WebSocket Connected.", "info"); sendAPIRequest({ authorize: token }); };
  ws.onmessage = (msg) => handleMessage(JSON.parse(msg.data));
  ws.onclose = () => {
    isConnected = false;
    updateStatus('Disconnected', 'disconnected');
    document.getElementById('accountType').style.display = 'none';
    if (!isExplicitLogout) { 
        addLog("Connection lost. Reconnecting in 5s...", "warn"); 
        setTimeout(connect, 5000); 
    }
  };
  ws.onerror = (error) => {
    addLog("WebSocket error occurred", "error");
    console.error("WebSocket error:", error);
  };
}

function handleMessage(data) {
  if (data.error) { 
    addLog(`API ERROR: ${data.error.message}`, "error"); 
    console.error("API Error:", data.error);
    return; 
  }
  
  if (data.authorize) {
    isConnected = true;
    updateStatus('Connected', 'connected');
    const accTypeEl = document.getElementById('accountType');
    const isVirtual = data.authorize.is_virtual === 1 || data.authorize.loginid.includes('VRTC');
    accTypeEl.textContent = isVirtual ? 'Demo Account' : 'Live Account';
    accTypeEl.className = 'account-type' + (isVirtual ? 'demo-badge' : 'live-badge');
    accTypeEl.style.display = 'block';
    addLog(`Authorized: ${data.authorize.email}`, "success");
    sendAPIRequest({ balance: 1, subscribe: 1 });
    subscribeToTicks();
    startSessionTimer();
    
    const persistedAuto = localStorage.getItem('isAutoRunning') === 'true';
    if(persistedAuto && !isAutoRunning) {
        resumeAutoTrade();
    }
  }
  
  if (data.balance) { 
    accountBalance = data.balance.balance; 
    updateBalance(); 
  }
  
  if (data.tick) {
    const lastDigit = parseInt(data.tick.quote.toString().slice(-1));
    addDigitToAnalyzer(lastDigit);
  }
  
  if (data.buy) {
    currentContractId = data.buy.contract_id;
    addLog(`Trade Placed (ID: ${currentContractId})`, "success");
    sendAPIRequest({ proposal_open_contract: 1, contract_id: currentContractId, subscribe: 1 });
  }
  
  if (data.proposal_open_contract) {
    const contract = data.proposal_open_contract;
    if (contract.is_settled === 1 || ['won', 'lost', 'sold'].includes(contract.status)) {
      handleTradeResult(contract);
      currentContractId = null;
      if (data.subscription) sendAPIRequest({ forget: data.subscription.id });
    }
  }
}

function resumeAutoTrade() {
    isAutoRunning = true;
    const btn = document.getElementById('autoBtn');
    const shutdownUI = document.getElementById('shutdownDisplay');
    autoStartTime = parseInt(localStorage.getItem('autoStartTime')) || Date.now();
    shutdownUI.style.display = 'block';
    btn.textContent = 'Stop Auto'; 
    btn.style.background = '#ef4444';
    addLog("Resuming Persistent Auto-Trade...", "success");
}

// ============ ML ENHANCEMENT FUNCTIONS ============

function calculateVolatility(data, windowSize = 50) {
    if (data.length < windowSize) return 0;
    const recent = data.slice(0, windowSize);
    const mean = recent.reduce((a, b) => a + b, 0) / recent.length;
    const variance = recent.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / recent.length;
    return Math.sqrt(variance);
}

function updateBayesianModel(isOver5) {
    // Bayesian updating with Beta distribution
    if (isOver5) {
        bayesianAlpha += 1;
    } else {
        bayesianBeta += 1;
    }
    
    // Save parameters
    localStorage.setItem('bayesian_params_v8', JSON.stringify({
        alpha: bayesianAlpha,
        beta: bayesianBeta
    }));
    
    // Calculate posterior mean
    const posteriorMean = bayesianAlpha / (bayesianAlpha + bayesianBeta);
    return posteriorMean * 100;
}

function updateMarkovModel(currentDigit) {
    if (digitHistory.length < 2) return;
    
    const prevDigit = digitHistory[1];
    const key = `${prevDigit}->${currentDigit}`;
    
    if (!markovTransitionMatrix[prevDigit]) {
        markovTransitionMatrix[prevDigit] = Array(10).fill(0);
    }
    markovTransitionMatrix[prevDigit][currentDigit]++;
}

function calculateMarkovPrediction() {
    if (digitHistory.length < 1 || !markovTransitionMatrix[digitHistory[0]]) {
        return 50; // Default neutral probability
    }
    
    const transitions = markovTransitionMatrix[digitHistory[0]];
    const totalTransitions = transitions.reduce((a, b) => a + b, 0);
    
    if (totalTransitions === 0) return 50;
    
    // Calculate probability of over-5 based on transitions
    const over5Transitions = transitions.slice(6, 10).reduce((a, b) => a + b, 0);
    return (over5Transitions / totalTransitions) * 100;
}

function detectPatterns() {
    if (digitHistory.length < 10) return null;
    
    // Look for repeating patterns (length 3-5)
    for (let len = 3; len <= 5; len++) {
        const pattern = digitHistory.slice(0, len).join(',');
        const cacheKey = `pattern_${len}_${pattern}`;
        
        if (patternCache[cacheKey]) {
            patternCache[cacheKey].count++;
            patternCache[cacheKey].lastSeen = Date.now();
        } else {
            patternCache[cacheKey] = { count: 1, lastSeen: Date.now() };
        }
        
        // Check if pattern repeats in history
        for (let i = len; i <= digitHistory.length - len; i++) {
            const comparePattern = digitHistory.slice(i, i + len).join(',');
            if (comparePattern === pattern) {
                // Pattern found - check what came next
                if (i + len < digitHistory.length) {
                    const nextDigit = digitHistory[i + len];
                    return {
                        pattern: pattern,
                        nextDigit: nextDigit,
                        confidence: Math.min(95, 60 + (len * 5))
                    };
                }
            }
        }
    }
    return null;
}

function calculateAdaptiveThreshold() {
    if (recentWinRates.length < 5) return 0;
    
    const recentAvg = recentWinRates.slice(-10).reduce((a, b) => a + b, 0) / Math.min(10, recentWinRates.length);
    
    // If win rate is low, increase threshold (be more conservative)
    if (recentAvg < 0.45) {
        return 10; // Increase confidence requirement by 10%
    } else if (recentAvg > 0.60) {
        return -5; // Can be slightly more aggressive
    }
    return 0;
}

function calculateEnsemblePrediction(heuristicConf, bayesianProb, markovProb, volatility) {
    // Weight different models based on their historical performance
    let weights = {
        heuristic: 0.40,
        bayesian: 0.25,
        markov: 0.25,
        pattern: 0.10
    };
    
    // Adjust weights based on volatility
    if (volatility > 2.5) {
        // High volatility - trust Bayesian more
        weights.bayesian += 0.10;
        weights.heuristic -= 0.10;
    }
    
    const pattern = detectPatterns();
    const patternBonus = pattern ? 5 : 0;
    
    const ensemble = (
        heuristicConf * weights.heuristic +
        bayesianProb * weights.bayesian +
        markovProb * weights.markov +
        patternBonus
    );
    
    return Math.min(98, Math.max(0, ensemble));
}

// ============ DIGIT ANALYZER ============
function addDigitToAnalyzer(digit) {
  digitHistory.unshift(digit);
  if (digitHistory.length > 50) digitHistory.pop();
  
  // Extended history for ML (up to 1000)
  extendedHistory.unshift(digit);
  if (extendedHistory.length > 1000) extendedHistory.pop();
  
  // Save extended history periodically
  if (extendedHistory.length % 50 === 0) {
    localStorage.setItem('extended_history_v8', JSON.stringify(extendedHistory));
  }
  
  // Update ML models
  const isOver5 = digit > 5;
  updateBayesianModel(isOver5);
  updateMarkovModel(digit);
  
  // Update volatility window
  volatilityWindow.unshift(digit);
  if (volatilityWindow.length > 100) volatilityWindow.pop();
  
  updateAnalyzerDisplay();
  if (isAutoRunning && !isCycleCooldown) checkAndAutoTrade();
}

function checkAndAutoTrade() {
    if (currentContractId !== null) return;
    if (!isSignalWindowOpen) return;

    const now = Date.now();
    const cooldownMs = parseInt(document.getElementById('cooldown').value) * 1000;
    if (now - lastTradeTime < Math.max(cooldownMs, 1000)) return;

    const mode = document.getElementById('confidenceMode').value;
    let isConfidenceMet = false;
    const currentConf = Math.round(lastPredictionConfidence);
    const prevConf = Math.round(previousPredictionConfidence);

    if (mode === 'range') {
        let minConf = parseFloat(document.getElementById('minConfidence').value);
        let maxConf = parseFloat(document.getElementById('maxConfidence').value);
        
        // Apply adaptive threshold adjustment
        const adjustment = calculateAdaptiveThreshold();
        minConf += adjustment;
        
        if (currentConf >= minConf && currentConf <= maxConf) isConfidenceMet = true;
    } 
    else if (mode === 'specific') {
        const targets = [
            parseInt(document.getElementById('spec1').value),
            parseInt(document.getElementById('spec2').value),
            parseInt(document.getElementById('spec3').value),
            parseInt(document.getElementById('spec4').value),
            parseInt(document.getElementById('spec5').value)
        ];
        if (targets.includes(currentConf)) isConfidenceMet = true;
    }
    else if (mode === 'sequence') {
        // Mode 3 Sequence Logic
        const s1_p1 = parseInt(document.getElementById('s1_p1_min').value);
        const s1_p2_min = parseInt(document.getElementById('s1_p2_min').value);
        const s1_p2_max = parseInt(document.getElementById('s1_p2_max').value);
        
        const s2_p1 = parseInt(document.getElementById('s2_p1_min').value);
        const s2_p2_min = parseInt(document.getElementById('s2_p2_min').value);
        const s2_p2_max = parseInt(document.getElementById('s2_p2_max').value);

        const s3_p1 = parseInt(document.getElementById('s3_p1_min').value);
        const s3_p2_min = parseInt(document.getElementById('s3_p2_min').value);
        const s3_p2_max = parseInt(document.getElementById('s3_p2_max').value);

        const match1 = (prevConf >= s1_p1 && currentConf >= s1_p2_min && currentConf <= s1_p2_max);
        const match2 = (prevConf >= s2_p1 && currentConf >= s2_p2_min && currentConf <= s2_p2_max);
        const match3 = (prevConf >= s3_p1 && currentConf >= s3_p2_min && currentConf <= s3_p2_max);

        if (match1 || match2 || match3) isConfidenceMet = true;
    }

    if (lastPredictionType === 'OVER 5' && isConfidenceMet) {
        lastTradeTime = now;
        placeTrade();
    }
}

function updateAnalyzerDisplay() {
  const container = document.getElementById('digitDisplay');
  container.innerHTML = '';
  digitHistory.forEach(digit => {
    const box = document.createElement('div');
    box.className = 'digit-box ' + (digit > 5 ? 'digit-over' : 'digit-under');
    box.textContent = digit;
    container.appendChild(box);
  });
  
  const overCount = digitHistory.filter(d => d > 5).length;
  document.getElementById('overCount').textContent = overCount;
  document.getElementById('totalCount').textContent = digitHistory.length;
  document.getElementById('overPercent').textContent = (digitHistory.length > 0 ? ((overCount / digitHistory.length) * 100).toFixed(1) : 0) + '%';
  
  predictNextDigit();
}

function predictNextDigit() {
  if (digitHistory.length < 20) {
    document.getElementById('patternMatch').textContent = 'Collecting data... need 20+ ticks';
    return;
  }
  
  // Store previous before calculating new one
  previousPredictionConfidence = lastPredictionConfidence;

  // ===== HEURISTIC MODEL (Original Enhanced) =====
  const last20 = digitHistory.slice(0, 20);
  let weightedUnderScore = 0;
  last20.forEach((digit, index) => {
      const weight = (20 - index) / 20; 
      if (digit <= 5) weightedUnderScore += weight;
  });
  const weightedFreq = (weightedUnderScore / 10.5) * 100;
  
  // Gap analysis
  let overGap = 0;
  for (let d of digitHistory) {
      if (d <= 5) overGap++;
      else break;
  }
  
  // Volatility calculation
  const volatility = calculateVolatility(volatilityWindow, 50);
  let volatilityLabel = 'Low';
  let volatilityPenalty = 0;
  
  if (volatility > 3.0) {
      volatilityLabel = 'Extreme';
      volatilityPenalty = -20;
  } else if (volatility > 2.5) {
      volatilityLabel = 'High';
      volatilityPenalty = -15;
  } else if (volatility > 1.8) {
      volatilityLabel = 'Medium';
      volatilityPenalty = -5;
  }
  
  document.getElementById('volatilityScore').textContent = volatilityLabel;
  
  // Trend analysis (gravity)
  let gravityBonus = 0;
  let trendLabel = 'Stable';
  if (digitHistory.length >= 3) {
      if (digitHistory[0] > digitHistory[1] && digitHistory[1] > digitHistory[2]) {
          gravityBonus = 15;
          trendLabel = 'Rising';
      } else if (digitHistory[0] < digitHistory[1] && digitHistory[1] < digitHistory[2]) {
          gravityBonus = -10;
          trendLabel = 'Falling';
      }
  }
  
  // ===== BAYESIAN MODEL =====
  const bayesianProb = updateBayesianModel(digitHistory[0] > 5);
  document.getElementById('bayesianProb').textContent = bayesianProb.toFixed(0) + '%';
  
  // ===== MARKOV MODEL =====
  const markovProb = calculateMarkovPrediction();
  document.getElementById('markovProb').textContent = markovProb.toFixed(0) + '%';
  
  // ===== HEURISTIC CONFIDENCE =====
  let heuristicConf = 0;
  let predText = 'WAIT';
  
  if (overGap >= 3) {
      predText = 'OVER 5';
      heuristicConf = 40 + (overGap * 9) + (weightedFreq * 0.1) + gravityBonus + volatilityPenalty;
  } else if (weightedFreq > 70) {
      predText = 'OVER 5';
      heuristicConf = 45 + (weightedFreq - 70) + gravityBonus + volatilityPenalty;
  }
  
  // ===== ENSEMBLE PREDICTION =====
  const ensembleScore = calculateEnsemblePrediction(
      Math.max(0, heuristicConf), 
      bayesianProb, 
      markovProb, 
      volatility
  );
  
  document.getElementById('ensembleScore').textContent = ensembleScore.toFixed(0) + '%';
  
  // Use ensemble as final confidence
  lastPredictionConfidence = Math.min(98, Math.max(0, ensembleScore));
  lastPredictionType = predText;
  
  // Adaptive threshold adjustment display
  const confAdj = calculateAdaptiveThreshold();
  document.getElementById('confAdj').textContent = (confAdj >= 0 ? '+' : '') + confAdj + '%';
  
  // Update UI
  document.getElementById('nextDigitPrediction').textContent = predText;
  document.getElementById('nextDigitPrediction').style.color = predText === 'OVER 5' ? '#22c55e' : '#f59e0b';
  document.getElementById('predictionConfidence').textContent = `${lastPredictionConfidence.toFixed(0)}% (Ensemble)`;
  document.getElementById('freqScore').textContent = weightedFreq.toFixed(0) + '%';
  document.getElementById('cycleScore').textContent = overGap;
  
  // Pattern detection display
  const pattern = detectPatterns();
  if (pattern) {
      document.getElementById('patternMatch').textContent = `Pattern detected: [${pattern.pattern}] â†’ Next likely: ${pattern.nextDigit}`;
  } else {
      document.getElementById('patternMatch').textContent = `No repeating patterns found. Using ML ensemble.`;
  }
}

// ============ TRADING FUNCTIONS ============
function placeTrade() {
  if (!isConnected || isCycleCooldown) return;
  const stakeValue = parseFloat(document.getElementById('stake').value);
  const tickValue = parseInt(document.getElementById('duration').value);
  const marketValue = document.getElementById('market').value;
  const type = isReverseTradeActive ? 'DIGITUNDER' : 'DIGITOVER';
  
  addLog(`Executing ${type} trade with ${lastPredictionConfidence.toFixed(0)}% confidence`, "info");
  
  sendAPIRequest({
    buy: 1, 
    price: stakeValue,
    parameters: { 
        contract_type: type, 
        symbol: marketValue, 
        duration: tickValue, 
        duration_unit: 't', 
        barrier: '5', 
        amount: stakeValue,
        basis: 'stake', 
        currency: 'USD' 
    }
  });
}

function toggleAuto() {
  if (!isConnected) return;
  isAutoRunning = !isAutoRunning;
  const btn = document.getElementById('autoBtn');
  const shutdownUI = document.getElementById('shutdownDisplay');

  if (isAutoRunning) {
    autoStartTime = Date.now();
    localStorage.setItem('isAutoRunning', 'true');
    localStorage.setItem('autoStartTime', autoStartTime);
    shutdownUI.style.display = 'block';
    addLog("ML Auto-Trade Enabled.", "success");
    btn.textContent = 'Stop Auto'; btn.style.background = '#ef4444';
  } else {
    autoStartTime = null;
    localStorage.removeItem('isAutoRunning');
    localStorage.removeItem('autoStartTime');
    shutdownUI.style.display = 'none';
    addLog("Auto-Trade Stopped.", "warn");
    btn.textContent = 'Start Auto'; btn.style.background = '#22c55e';
  }
}

function toggleMarketCycle() {
    isMarketCycleActive = !isMarketCycleActive;
    const btn = document.getElementById('cycleBtn');
    if (isMarketCycleActive) {
        btn.classList.add('active');
        currentMarketIndex = marketSequence.indexOf(document.getElementById('market').value);
        if(currentMarketIndex === -1) currentMarketIndex = 0;
        btn.textContent = `Auto Market Cycle: ON (${marketSequence[currentMarketIndex]})`;
        addLog(`Market Cycle Sequence Started at ${marketSequence[currentMarketIndex]}.`, "info");
    } else {
        btn.classList.remove('active');
        btn.textContent = "Auto Market Cycle: OFF";
        addLog(`Market Cycle Sequence Disabled.`, "warn");
    }
}

function toggleCooldownLoop() {
    isCooldownLoopActive = !isCooldownLoopActive;
    const btn = document.getElementById('cooldownBtn');
    if (isCooldownLoopActive) {
        btn.classList.add('active');
        btn.textContent = "Cycle Cooldown Loop: ON";
        addLog(`Cycle Cooldown Loop Enabled: Will wait after full sequence.`, "info");
    } else {
        btn.classList.remove('active');
        btn.textContent = "Cycle Cooldown Loop: OFF";
        addLog(`Cycle Cooldown Loop Disabled.`, "warn");
    }
}

function startCycleCooldown() {
    isCycleCooldown = true;
    let waitMinutes = parseInt(document.getElementById('cycleWaitTime').value);
    let secondsLeft = waitMinutes * 60;
    const timerDisplay = document.getElementById('cycleTimerDisplay');
    timerDisplay.style.display = 'block';
    addLog(`Sequence Complete. Cycle Cooldown Loop active: waiting ${waitMinutes}m...`, "warn");

    if (cycleTimerId) clearInterval(cycleTimerId);
    cycleTimerId = setInterval(() => {
        secondsLeft--;
        const mins = Math.floor(secondsLeft / 60);
        const secs = secondsLeft % 60;
        timerDisplay.textContent = `Next Loop in: ${mins.toString().padStart(2,'0')}:${secs.toString().padStart(2,'0')}`;

        if (secondsLeft <= 0) {
            clearInterval(cycleTimerId);
            isCycleCooldown = false;
            timerDisplay.style.display = 'none';
            currentMarketIndex = 0;
            const nextMarket = marketSequence[currentMarketIndex];
            document.getElementById('market').value = nextMarket;
            document.getElementById('cycleBtn').textContent = `Auto Market Cycle: ON (${nextMarket})`;
            addLog(`Cooldown finished. Restarting Cycle at ${nextMarket}.`, "success");
            subscribeToTicks();
        }
    }, 1000);
}

function handleTradeResult(contract) {
  const isWin = contract.status === 'won';
  const profitLoss = parseFloat(contract.profit || 0);
  addLog(`RESULT: ${isWin ? 'WIN' : 'LOSS'} | P/L: ${profitLoss.toFixed(2)}`, isWin ? 'success' : 'error');
  
  stats.trades++; 
  if (isWin) stats.wins++; else stats.losses++; 
  stats.profit += profitLoss;
  
  // Update win rate tracking for adaptive thresholds
  recentWinRates.push(isWin ? 1 : 0);
  if (recentWinRates.length > 20) recentWinRates.shift();
  
  updateStats();
  
  // Persistence for history
  addToHistory(stats.trades, isWin ? 'Win' : 'Loss', profitLoss, contract.display_name || 'Market');
  localStorage.setItem('trade_stats_v8', JSON.stringify(stats));
  localStorage.setItem('trade_history_v8', document.getElementById('history').innerHTML);

  const tp = parseFloat(document.getElementById('takeprofit').value);
  if (isMarketCycleActive && stats.profit >= tp) {
      if (currentMarketIndex < marketSequence.length - 1) {
          currentMarketIndex++;
          const nextMarket = marketSequence[currentMarketIndex];
          addLog(`Target reached! Switching Market: ${marketSequence[currentMarketIndex-1]} -> ${nextMarket}...`, "success");
          resetStats(); 
          document.getElementById('market').value = nextMarket;
          document.getElementById('cycleBtn').textContent = `Auto Market Cycle: ON (${nextMarket})`;
          subscribeToTicks();
          return; 
      } else {
          addLog("Final Market Sequence Finished Successfully.", "success");
          resetStats();
          if (isCooldownLoopActive) {
              startCycleCooldown();
          } else {
              if (isAutoRunning) toggleAuto();
              isMarketCycleActive = false;
              document.getElementById('cycleBtn').classList.remove('active');
              document.getElementById('cycleBtn').textContent = "Auto Market Cycle: OFF";
          }
      }
  }
  checkRiskManagement();
}

function toggleReverseTrade() {
    isReverseTradeActive = !isReverseTradeActive;
    const btn = document.getElementById('reverseBtn');
    if (isReverseTradeActive) {
        btn.classList.add('active');
        btn.textContent = "Reverse Trade: ON (Digit Under 5)";
        addLog("Reverse Mode Activated: Now trading Digit Under 5", "warn");
    } else {
        btn.classList.remove('active');
        btn.textContent = "Reverse Trade: OFF";
        addLog("Normal Mode Activated: Now trading Digit Over 5", "info");
    }
}

// ============ API COMMUNICATION ============
function sendAPIRequest(data) { 
    if (ws && ws.readyState === WebSocket.OPEN) { 
        const now = Date.now();
        if (now - lastRequestTime < 300) {
            setTimeout(() => sendAPIRequest(data), 300);
            return false;
        }
        lastRequestTime = now;
        ws.send(JSON.stringify(data)); 
        return true; 
    } 
    return false; 
}

function subscribeToTicks() {
  const market = document.getElementById('market').value;
  sendAPIRequest({ forget_all: "ticks" });
  digitHistory = [];
  document.getElementById('digitDisplay').innerHTML = '';
  addLog(`Watching ${market}...`, "info");
  sendAPIRequest({ ticks: market, subscribe: 1 });
}

document.getElementById('market').addEventListener('change', function() { 
    if (isConnected) subscribeToTicks(); 
});

// ============ UI UPDATE FUNCTIONS ============
function updateStatus(text, className) { 
    const s = document.getElementById('status'); 
    s.textContent = text; 
    s.className = 'status ' + className; 
}

function updateBalance() { 
    document.getElementById('balanceDisplay').style.display = 'block'; 
    document.getElementById('balance').textContent = parseFloat(accountBalance).toFixed(2); 
}

function updateStats() {
  document.getElementById('trades').textContent = stats.trades;
  document.getElementById('wins').textContent = stats.wins;
  document.getElementById('losses').textContent = stats.losses;
  const p = document.getElementById('profit');
  p.textContent = stats.profit.toFixed(2);
  p.style.color = stats.profit > 0 ? '#22c55e' : (stats.profit < 0 ? '#ef4444' : '#e5e7eb');
}

function startSessionTimer() {
    if (timerIntervalId) clearInterval(timerIntervalId);
    sessionStartTime = Date.now(); 
    timerIntervalId = setInterval(() => {
        updateSignalWindowTimer();
        const now = Date.now();
        const s = Math.floor((now - sessionStartTime) / 1000);
        document.getElementById('sessionTimer').textContent = `Session: ${Math.floor(s/3600).toString().padStart(2,'0')}:${Math.floor((s%3600)/60).toString().padStart(2,'0')}:${(s%60).toString().padStart(2,'0')}`;
        
        if (isAutoRunning && autoStartTime) {
            const limitHours = parseFloat(document.getElementById('autoDurationHrs').value) || 0;
            if (limitHours <= 0) {
                document.getElementById('shutdownDisplay').textContent = `Shutdown in: Unlimited`;
                return;
            }
            const limitMs = limitHours * 3600000;
            const elapsedMs = now - autoStartTime;
            const remainingMs = limitMs - elapsedMs;
            if (remainingMs <= 0) {
                addLog("Trade Duration Elapsed. Auto-Shutdown triggered.", "warn");
                toggleAuto();
            } else {
                const remS = Math.floor(remainingMs / 1000);
                const h = Math.floor(remS / 3600).toString().padStart(2, '0');
                const m = Math.floor((remS % 3600) / 60).toString().padStart(2, '0');
                const sec = (remS % 60).toString().padStart(2, '0');
                document.getElementById('shutdownDisplay').textContent = `Shutdown in: ${h}:${m}:${sec}`;
            }
        }
    }, 1000);
}

function checkRiskManagement() {
  const sl = parseFloat(document.getElementById('stoploss').value);
  const tp = parseFloat(document.getElementById('takeprofit').value);
  
  if (stats.profit <= -sl) { 
    if (isAutoRunning) toggleAuto(); 
    addLog("Stop Loss Met. Trading stopped.", "error"); 
  }
  
  if (!isMarketCycleActive && stats.profit >= tp) {
    if (isAutoRunning) toggleAuto();
    addLog("Take Profit achieved! Trading stopped.", "success");
  }
}

function addToHistory(n, res, pl, m) {
  const row = document.getElementById('history').insertRow(0);
  const cls = res === 'Win' ? 'win' : 'loss';
  row.innerHTML = `<td>${n}</td><td class="${cls}">${res}</td><td class="${cls}">${pl.toFixed(2)}</td><td>${m}</td>`;
}

function resetStats() { 
    stats = { trades: 0, wins: 0, losses: 0, profit: 0 }; 
    recentWinRates = [];
    updateStats(); 
    document.getElementById('history').innerHTML = ''; 
    localStorage.removeItem('trade_stats_v8');
    localStorage.removeItem('trade_history_v8');
    addLog("All stats reset.", "info");
}

function manualTrade() { 
    if (isConnected) {
        placeTrade(); 
    } else {
        addLog("Not connected. Please login first.", "error");
    }
}

// ============ INITIALIZATION ============
window.onload = () => {
  addLog("Initializing ML Enhanced Trading Bot...", "info");
  loadSettings();
  const savedToken = sessionStorage.getItem('derivToken');
  if (savedToken) { 
      document.getElementById('token').value = savedToken; 
      setTimeout(connect, 1000); 
  }
  addLog("ML models initialized. Ready to trade.", "success");
};

document.getElementById('logoutBtn').addEventListener('click', () => { 
    isExplicitLogout = true; 
    localStorage.removeItem('isAutoRunning');
    localStorage.removeItem('autoStartTime');
    if (ws) ws.close(); 
    sessionStorage.removeItem('derivToken'); 
    addLog("Logging out...", "info");
    setTimeout(() => location.reload(), 500);
});
</script>
</body>
</html>