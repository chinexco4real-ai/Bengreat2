<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Deriv Digit Over 5 Pro - Advanced ML Edition v3.3</title>
<style>
/* --- STYLES PRESERVED --- */
body { background: #020617; color: #e5e7eb; font-family: system-ui, -apple-system, sans-serif; margin: 0; padding: 0; }
.app { max-width: 420px; margin: auto; padding: 15px; }
.card { background: #0f172a; padding: 12px; border-radius: 12px; margin-bottom: 12px; border: 1px solid #1e293b; }
h2, h3 { text-align: center; margin-bottom: 8px; margin-top: 8px; }
h2 { color: #22c55e; }
label { font-size: 13px; opacity: 0.8; display: block; margin-top: 8px; }
input, select, button { width: 100%; padding: 10px; margin: 5px 0 10px; border-radius: 8px; border: none; box-sizing: border-box; }
input, select { background: #1e293b; color: #e5e7eb; border: 1px solid #334155; }
input:focus, select:focus { outline: none; border-color: #22c55e; }
button { background: #22c55e; color: #020617; font-weight: 700; cursor: pointer; transition: all 0.2s; }
button:hover { background: #16a34a; transform: translateY(-1px); }
button:active { transform: translateY(0); }
button:disabled { background: #374151; cursor: not-allowed; opacity: 0.5; }
.buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 12px; }
.status-container { display: flex; gap: 5px; margin-bottom: 10px; }
.status { flex: 2; text-align: center; padding: 8px; border-radius: 8px; font-weight: 600; }
.account-type { flex: 1.5; text-align: center; padding: 8px; border-radius: 8px; font-weight: 700; font-size: 11px; display: none; text-transform: uppercase; align-self: center; }
.demo-badge { background: #f59e0b; color: #020617; }
.live-badge { background: #22c55e; color: #020617; }
.connected { background: #16a34a; color: white; }
.disconnected { background: #dc2626; color: white; }
.stats { display: grid; grid-template-columns: repeat(4, 1fr); text-align: center; gap: 10px; }
.stats > div { display: flex; flex-direction: column; gap: 5px; }
.stats span { font-size: 12px; opacity: 0.7; }
.stats b { font-size: 16px; color: #22c55e; }
.table-container { overflow-x: auto; max-height: 300px; overflow-y: auto; }
table { width: 100%; font-size: 13px; border-collapse: collapse; }
thead { position: sticky; top: 0; background: #1e293b; }
th { padding: 8px; text-align: left; font-weight: 600; border-bottom: 2px solid #334155; }
td { padding: 8px; border-bottom: 1px solid #1e293b; }
tbody tr:hover { background: #1e293b; }
.win { color: #22c55e; }
.loss { color: #ef4444; }
.balance-display { text-align: center; padding: 10px; background: #0f172a; border-radius: 8px; margin-bottom: 10px; border: 1px solid #1e293b; }
.balance-display span { opacity: 0.7; font-size: 14px; }
.balance-display b { color: #22c55e; font-size: 18px; margin: 0 5px; }
.session-timer { margin-top: 8px; font-size: 12px; color: #f59e0b; font-weight: 600; }
.reset-button-permanent { background: #f59e0b !important; width: 100%; margin-bottom: 12px; font-size: 15px; display: block; }
.reset-button-permanent:hover { background: #d97706 !important; }
.analyzer-grid { display: grid; grid-template-columns: repeat(10, 1fr); gap: 5px; margin: 10px 0; }
.digit-box { aspect-ratio: 1; display: flex; align-items: center; justify-content: center; border-radius: 6px; font-weight: 700; font-size: 14px; border: 2px solid transparent; }
.digit-over { background: #22c55e; color: #020617; }
.digit-under { background: #ef4444; color: white; }
.analyzer-stats { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; text-align: center; margin-top: 10px; }
.analyzer-stats > div { background: #1e293b; padding: 8px; border-radius: 6px; }
.analyzer-stats span { font-size: 11px; opacity: 0.7; display: block; }
.analyzer-stats b { font-size: 18px; display: block; margin-top: 3px; }
.log-container { background: #020617; border: 1px solid #1e293b; border-radius: 6px; height: 120px; overflow-y: auto; padding: 8px; font-family: 'Courier New', monospace; font-size: 11px; margin-top: 10px; }
.log-entry { margin-bottom: 4px; border-bottom: 1px solid #1e293b; padding-bottom: 2px; }
.log-time { color: #94a3b8; margin-right: 5px; }
.log-msg-info { color: #3b82f6; }
.log-msg-success { color: #22c55e; }
.log-msg-error { color: #ef4444; }
.log-msg-warn { color: #f59e0b; }
.btn-cycle { background: #3b82f6; color: white; margin-bottom: 5px; font-size: 14px; }
.btn-cycle.active { background: #8b5cf6; border: 2px solid #fff; }
.btn-cooldown { background: #475569; color: white; margin-bottom: 5px; font-size: 14px; }
.btn-cooldown.active { background: #f59e0b; color: #020617; border: 2px solid #020617; }
.btn-reverse { background: #334155; color: white; margin-bottom: 12px; font-size: 14px; }
.btn-reverse.active { background: #f43f5e; }
.cycle-timer-display { color: #f59e0b; font-size: 13px; font-weight: bold; text-align: center; margin-bottom: 10px; display: none; padding: 8px; border: 2px dashed #f59e0b; border-radius: 8px; background: rgba(245, 158, 11, 0.1); }
.specific-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; margin-bottom: 10px; }
.specific-grid input { text-align: center; padding: 8px 0; margin: 0; }

/* Sequence UI Styles */
.sequence-slot { background: #1e293b; border: 1px solid #334155; border-radius: 8px; padding: 10px; margin-bottom: 10px; }
.sequence-slot-title { font-size: 11px; font-weight: 700; color: #3b82f6; margin-bottom: 5px; text-transform: uppercase; }
.seq-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px; }
.seq-grid input { font-size: 11px; padding: 5px; margin: 0; }

/* ML Enhancement Styles */
.ml-indicator { display: inline-block; padding: 3px 8px; border-radius: 4px; font-size: 10px; font-weight: 700; margin-left: 5px; }
.ml-learning { background: #8b5cf6; color: white; }
.ml-active { background: #22c55e; color: #020617; }
.advanced-stats { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-top: 8px; font-size: 10px; }
.advanced-stats > div { background: #020617; padding: 5px; border-radius: 4px; text-align: center; }

/* Radio Button Styles */
.radio-group { margin: 10px 0; }
.radio-option { display: flex; align-items: center; padding: 8px; margin: 5px 0; background: #1e293b; border-radius: 6px; cursor: pointer; border: 2px solid #334155; transition: all 0.2s; }
.radio-option:hover { border-color: #22c55e; background: #1e3a2b; }
.radio-option input[type="radio"] { margin-right: 10px; cursor: pointer; width: auto; }
.radio-option.selected { border-color: #22c55e; background: #1e3a2b; }
.radio-option label { cursor: pointer; margin: 0; opacity: 1; font-size: 13px; font-weight: 600; width: 100%; }

/* Pattern Mode UI */
.pattern-target-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; margin-top: 10px; }
.pattern-target-grid input { text-align: center; padding: 8px; margin: 0; background: #0f172a; border: 2px solid #8b5cf6; }
.pattern-mode-active { background: #8b5cf6; padding: 8px; border-radius: 6px; text-align: center; margin: 10px 0; font-weight: 700; color: white; }
.ensemble-filter-box { background: #0f172a; border: 2px solid #f59e0b; border-radius: 6px; padding: 10px; margin-top: 10px; }
.ensemble-filter-box label { color: #f59e0b; font-weight: 700; font-size: 12px; }
.ensemble-status { text-align: center; font-size: 11px; margin-top: 5px; padding: 5px; border-radius: 4px; background: #1e293b; }
.ensemble-filter-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 8px; }
.filter-warning { background: #ef4444; color: white; padding: 6px; border-radius: 4px; text-align: center; font-size: 10px; font-weight: 700; margin-top: 5px; display: none; }

/* Toggle Switch Styles */
.toggle-container { display: flex; align-items: center; justify-content: space-between; padding: 10px; background: #1e293b; border-radius: 6px; margin: 10px 0; border: 2px solid #334155; }
.toggle-label { font-size: 13px; font-weight: 700; color: #e5e7eb; }
.toggle-switch { position: relative; width: 50px; height: 26px; }
.toggle-switch input { opacity: 0; width: 0; height: 0; }
.toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #334155; border-radius: 34px; transition: .4s; }
.toggle-slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 4px; bottom: 4px; background-color: white; border-radius: 50%; transition: .4s; }
.toggle-switch input:checked + .toggle-slider { background-color: #22c55e; }
.toggle-switch input:checked + .toggle-slider:before { transform: translateX(24px); }

/* Specific Ensemble Percentages */
.specific-ensemble-section { background: #0f172a; border: 2px solid #8b5cf6; border-radius: 6px; padding: 10px; margin-top: 10px; display: none; }
.specific-ensemble-section.active { display: block; }
.specific-ensemble-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; margin-top: 8px; }
.specific-ensemble-grid input { text-align: center; padding: 8px; margin: 0; background: #1e293b; border: 2px solid #8b5cf6; }

/* Model Performance Indicators */
.model-performance { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px; margin-top: 8px; font-size: 10px; }
.model-performance > div { background: #1e293b; padding: 5px; border-radius: 4px; text-align: center; border: 1px solid #334155; }
.model-perf-high { border-color: #22c55e; }
.model-perf-low { border-color: #ef4444; }

/* Virtual Trade Styles */
.virtual-trade-container { background: #1e293b; border: 2px solid #8b5cf6; border-radius: 8px; padding: 10px; margin-bottom: 12px; }
.virtual-trade-header { font-size: 13px; font-weight: 700; color: #8b5cf6; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; }
.virtual-trade-status { background: #8b5cf6; color: white; padding: 6px 10px; border-radius: 6px; text-align: center; font-size: 11px; font-weight: 700; margin-top: 8px; display: none; }
.virtual-trade-status.active { display: block; }
.virtual-trade-stats { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 8px; }
.virtual-trade-stats > div { background: #0f172a; padding: 6px; border-radius: 4px; text-align: center; }
.virtual-trade-stats span { font-size: 10px; opacity: 0.7; display: block; }
.virtual-trade-stats b { font-size: 14px; display: block; margin-top: 2px; color: #8b5cf6; }
.switch-notice { background: #22c55e; color: #020617; padding: 6px; border-radius: 4px; text-align: center; font-size: 11px; font-weight: 700; margin-top: 8px; display: none; }
.switch-notice.active { display: block; }

/* Histogram Display */
.histogram-container { background: #0f172a; border: 2px solid #3b82f6; border-radius: 8px; padding: 10px; margin-bottom: 12px; }
.histogram-header { font-size: 13px; font-weight: 700; color: #3b82f6; margin-bottom: 8px; text-align: center; }
.histogram-grid { display: grid; grid-template-columns: repeat(10, 1fr); gap: 4px; }
.histogram-bar { display: flex; flex-direction: column; align-items: center; }
.histogram-bar-fill { width: 100%; background: #22c55e; border-radius: 4px; transition: all 0.3s; position: relative; }
.histogram-bar-fill.low { background: #ef4444; }
.histogram-bar-fill.medium { background: #f59e0b; }
.histogram-digit { font-size: 10px; font-weight: 700; margin-top: 4px; }
.histogram-count { font-size: 9px; opacity: 0.7; }
.histogram-bias { text-align: center; margin-top: 8px; padding: 6px; border-radius: 4px; font-weight: 700; font-size: 11px; }
.histogram-bias.favorable { background: #22c55e; color: #020617; }
.histogram-bias.unfavorable { background: #ef4444; color: white; }
.histogram-bias.neutral { background: #334155; color: #e5e7eb; }

/* Histogram Toggle */
.histogram-toggle-container { background: #1e293b; padding: 8px; border-radius: 6px; margin-top: 8px; }

/* Regime Indicator */
.regime-indicator { background: #1e293b; padding: 8px; border-radius: 6px; margin-top: 8px; text-align: center; }
.regime-indicator .regime-label { font-size: 10px; opacity: 0.7; }
.regime-indicator .regime-value { font-size: 14px; font-weight: 700; margin-top: 4px; }
.regime-random { color: #ef4444; }
.regime-structured { color: #22c55e; }
.regime-transitioning { color: #f59e0b; }

/* Feature Importance */
.feature-importance { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-top: 8px; font-size: 9px; }
.feature-importance > div { background: #1e293b; padding: 4px; border-radius: 4px; text-align: center; }
.feature-high { border: 1px solid #22c55e; }
.feature-low { opacity: 0.5; }

/* Confidence Calibration Display */
.calibration-display { background: #0f172a; padding: 6px; border-radius: 4px; margin-top: 8px; text-align: center; font-size: 10px; }
.calibration-display .cal-label { opacity: 0.7; }
.calibration-display .cal-value { font-weight: 700; color: #8b5cf6; margin-top: 2px; }

/* NEW: Prediction Gap Mode Styles */
.prediction-gap-container { background: #0f172a; border: 2px solid #06b6d4; border-radius: 6px; padding: 10px; margin-top: 10px; display: none; }
.prediction-gap-container.active { display: block; }
.slot-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 8px; }
.slot-grid input { text-align: center; padding: 8px; margin: 0; background: #1e293b; border: 2px solid #06b6d4; }
</style>
</head>
<body>
<div class="app">

<h2>Deriv Digit Over 5 Pro <span class="ml-indicator ml-active">ML Enhanced v3.3</span></h2>

<div class="status-container">
    <div id="status" class="status disconnected">Disconnected</div>
    <div id="accountType" class="account-type"></div>
</div>

<div id="balanceDisplay" class="balance-display" style="display:none;">
  <span>Balance:</span>
  <b id="balance">0.00</b>
  <span id="balanceCurrency">USD</span>
  <div id="sessionTimer" class="session-timer">Session: 00:00:00</div>
</div>

<div class="card">
  <input id="token" type="password" placeholder="Deriv API Token" required>
  <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <button onclick="connect()">Login</button>
    <button id="logoutBtn" style="background: #ef4444;">Logout</button>
  </div>
</div>

<!-- Virtual Trade Feature -->
<div class="virtual-trade-container">
  <div class="virtual-trade-header">
    üéÆ Virtual Trade Mode
  </div>
  
  <div class="toggle-container" style="margin: 0;">
    <span class="toggle-label">Enable Virtual Trade First</span>
    <label class="toggle-switch">
      <input type="checkbox" id="virtualTradeToggle" onchange="toggleVirtualTrade()">
      <span class="toggle-slider"></span>
    </label>
  </div>
  
  <div id="virtualTradeSettings" style="display: none; margin-top: 10px;">
    <label>Consecutive Losses to Switch to Live</label>
    <input id="virtualLossThreshold" class="save-setting" type="number" value="3" min="1" max="20">
    
    <div class="virtual-trade-stats">
      <div>
        <span>Virtual Losses</span>
        <b id="virtualLossCount">0</b>
      </div>
      <div>
        <span>Threshold</span>
        <b id="virtualThresholdDisplay">3</b>
      </div>
    </div>
    
    <div class="virtual-trade-status" id="virtualTradeStatus">
      üéÆ Trading on VIRTUAL account
    </div>
    
    <div class="switch-notice" id="switchNotice">
      ‚ö†Ô∏è Switched to LIVE account after hitting loss threshold!
    </div>
  </div>
</div>

<!-- Histogram Display -->
<div class="histogram-container">
  <div class="histogram-header">üìä Digit Histogram (Last 1000 Ticks)</div>
  <div class="histogram-grid" id="histogramDisplay">
    <!-- Generated dynamically -->
  </div>
  <div class="histogram-bias" id="histogramBias">Collecting data...</div>
  
  <!-- Histogram Filter Toggle -->
  <div class="histogram-toggle-container">
    <div class="toggle-container" style="margin: 0;">
      <span class="toggle-label">Enable Histogram Filter</span>
      <label class="toggle-switch">
        <input type="checkbox" id="histogramFilterToggle" onchange="toggleHistogramFilter()">
        <span class="toggle-slider"></span>
      </label>
    </div>
    <div style="font-size: 10px; opacity: 0.7; margin-top: 6px; text-align: center;">
      When enabled, blocks trades if histogram shows unfavorable bias
    </div>
  </div>
  
  <div class="regime-indicator">
    <div class="regime-label">Market Regime</div>
    <div class="regime-value" id="regimeValue">Initializing...</div>
  </div>
</div>

<div class="card">
  <h3>üìä Advanced ML Analyzer v3.3</h3>
  <div class="analyzer-grid" id="digitDisplay"></div>
  <div class="analyzer-stats">
    <div><span>Over 5</span><b id="overCount" style="color: #22c55e;">0</b></div>
    <div><span>Total Ticks</span><b id="totalCount" style="color: #e5e7eb;">0</b></div>
    <div><span>Over %</span><b id="overPercent" style="color: #22c55e;">0%</b></div>
  </div>
  
  <div style="margin-top: 10px; padding: 12px; background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%); border-radius: 8px; border: 2px solid #22c55e;">
    <div style="font-size: 14px; font-weight: 700; margin-bottom: 10px; color: #22c55e;">üîÆ ML Prediction Engine v3.3</div>

    <div style="background: #0f172a; padding: 10px; border-radius: 6px; margin-bottom: 8px; margin-top: 8px;">
      <div style="font-size: 11px; opacity: 0.7; margin-bottom: 5px;">Next Digit Prediction:</div>
      <div style="font-size: 24px; font-weight: 700; text-align: center;" id="nextDigitPrediction">-</div>
      <div style="font-size: 11px; text-align: center; margin-top: 5px;" id="predictionConfidence">-</div>
    </div>
    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; font-size: 11px;">
      <div style="background: #1e293b; padding: 6px; border-radius: 4px; text-align: center;"><div>Freq Bias</div><b id="freqScore" style="color: #22c55e;">0%</b></div>
      <div style="background: #1e293b; padding: 6px; border-radius: 4px; text-align: center;"><div>Gap Count</div><b id="cycleScore" style="color: #3b82f6;">0</b></div>
      <div style="background: #1e293b; padding: 6px; border-radius: 4px; text-align: center;"><div>Volatility</div><b id="volatilityScore" style="color: #f59e0b;">Low</b></div>
    </div>
    
    <div class="advanced-stats">
      <div><span style="opacity:0.6">Bayesian Prob</span><b id="bayesianProb" style="color:#8b5cf6">50%</b></div>
      <div><span style="opacity:0.6">Markov Pred</span><b id="markovProb" style="color:#3b82f6">50%</b></div>
      <div><span style="opacity:0.6">LightGBM</span><b id="lgbmScore" style="color:#f59e0b">50%</b></div>
      <div><span style="opacity:0.6">Ensemble</span><b id="ensembleScore" style="color:#22c55e">50%</b></div>
    </div>
    
    <div class="model-performance">
      <div id="heuristicPerf"><span style="opacity:0.6">Heuristic</span><b style="color:#22c55e">--%</b></div>
      <div id="bayesianPerf"><span style="opacity:0.6">Bayesian</span><b style="color:#8b5cf6">--%</b></div>
      <div id="markovPerf"><span style="opacity:0.6">Markov</span><b style="color:#3b82f6">--%</b></div>
    </div>
    
    <div class="calibration-display">
      <div class="cal-label">Calibrated Confidence</div>
      <div class="cal-value" id="calibratedConf">--</div>
    </div>
    
    <div class="feature-importance">
      <div id="featFreq"><span>Freq: --</span></div>
      <div id="featGap"><span>Gap: --</span></div>
      <div id="featBayes"><span>Bayes: --</span></div>
      <div id="featMarkov"><span>Markov: --</span></div>
    </div>
    
    <div style="margin-top: 8px; font-size: 11px; opacity: 0.7; text-align: center;" id="patternMatch">Analyzing patterns...</div>
    
    <div style="margin-top: 15px; border-top: 1px solid #334155; padding-top: 10px;">
        <div style="font-size: 12px; font-weight: 600; color: #94a3b8; display: flex; justify-content: space-between;">
            <span>SYSTEM & TRADE LOG</span>
            <span style="cursor:pointer; color:#3b82f6" onclick="document.getElementById('logContainer').innerHTML=''">Clear</span>
        </div>
        <div class="log-container" id="logContainer">
            <div class="log-entry"><span class="log-time">[System]</span> <span class="log-msg-success">ML Engine v3.3 Ready.</span></div>
        </div>
    </div>
  </div>
</div>

<div class="card">
  <h3>Trade Settings</h3>
  <label>Stake ($)</label>
  <input id="stake" class="save-setting" type="number" value="1" min="0.35" step="0.01">
  <label>Duration (Ticks)</label>
  <input id="duration" class="save-setting" type="number" value="1" min="1" max="10">
  <label>Cooldown (seconds)</label>
  <input id="cooldown" class="save-setting" type="number" value="2" min="1">

  <label>Confidence Selection Mode</label>
  <div class="radio-group" id="confidenceModeRadios">
      <div class="radio-option" onclick="selectConfidenceMode('range')">
          <input type="radio" name="confidenceMode" value="range" id="modeRange" checked>
          <label for="modeRange">Mode 1: Range (Min-Max)</label>
      </div>
      <div class="radio-option" onclick="selectConfidenceMode('specific')">
          <input type="radio" name="confidenceMode" value="specific" id="modeSpecific">
          <label for="modeSpecific">Mode 2: Specific Numbers (Pick 5)</label>
      </div>
      <div class="radio-option" onclick="selectConfidenceMode('sequence')">
          <input type="radio" name="confidenceMode" value="sequence" id="modeSequence">
          <label for="modeSequence">Mode 3: Sequence Pattern (3 Slots)</label>
      </div>
      <div class="radio-option" onclick="selectConfidenceMode('pattern')">
          <input type="radio" name="confidenceMode" value="pattern" id="modePattern">
          <label for="modePattern">Mode 4: Pattern Detection (Next Likely Digit)</label>
      </div>
      <div class="radio-option" onclick="selectConfidenceMode('predictionGap')">
          <input type="radio" name="confidenceMode" value="predictionGap" id="modePredictionGap">
          <label for="modePredictionGap">Mode 5: Prediction % + Gap Count (6 Slots)</label>
      </div>
  </div>

  <div id="rangeUI">
      <label>Confidence Range (Min - Max %)</label>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
        <input id="minConfidence" class="save-setting" type="number" value="55" min="0" max="100" placeholder="Min">
        <input id="maxConfidence" class="save-setting" type="number" value="70" min="0" max="100" placeholder="Max">
      </div>
  </div>

  <div id="specificUI" style="display:none;">
      <label>Specific Target Numbers</label>
      <div class="specific-grid">
          <input id="spec1" class="save-setting" type="number" value="10" min="0" max="100">
          <input id="spec2" class="save-setting" type="number" value="25" min="0" max="100">
          <input id="spec3" class="save-setting" type="number" value="49" min="0" max="100">
          <input id="spec4" class="save-setting" type="number" value="50" min="0" max="100">
          <input id="spec5" class="save-setting" type="number" value="65" min="0" max="100">
      </div>
  </div>

  <div id="sequenceUI" style="display:none;">
      <label>Sequence Slots Logic</label>
      
      <div class="sequence-slot">
          <div class="sequence-slot-title">Slot 1</div>
          <div class="seq-grid">
              <div><span style="font-size:9px">1st Pred >=</span><input id="s1_p1_min" class="save-setting" type="number" value="40"></div>
              <div><span style="font-size:9px">2nd Pred >=</span><input id="s1_p2_min" class="save-setting" type="number" value="50"></div>
              <div><span style="font-size:9px">2nd Pred <=</span><input id="s1_p2_max" class="save-setting" type="number" value="98"></div>
          </div>
      </div>

      <div class="sequence-slot">
          <div class="sequence-slot-title">Slot 2</div>
          <div class="seq-grid">
              <div><span style="font-size:9px">1st Pred >=</span><input id="s2_p1_min" class="save-setting" type="number" value="15"></div>
              <div><span style="font-size:9px">2nd Pred >=</span><input id="s2_p2_min" class="save-setting" type="number" value="60"></div>
              <div><span style="font-size:9px">2nd Pred <=</span><input id="s2_p2_max" class="save-setting" type="number" value="98"></div>
          </div>
      </div>

      <div class="sequence-slot">
          <div class="sequence-slot-title">Slot 3</div>
          <div class="seq-grid">
              <div><span style="font-size:9px">1st Pred >=</span><input id="s3_p1_min" class="save-setting" type="number" value="50"></div>
              <div><span style="font-size:9px">2nd Pred >=</span><input id="s3_p2_min" class="save-setting" type="number" value="50"></div>
              <div><span style="font-size:9px">2nd Pred <=</span><input id="s3_p2_max" class="save-setting" type="number" value="98"></div>
          </div>
      </div>
  </div>

  <div id="patternUI" style="display:none;">
      <div class="pattern-mode-active">üéØ Pattern Detection Mode Active</div>
      <label>Target Digits for Pattern Match (0-9)</label>
      <div class="pattern-target-grid">
          <input id="pattern1" class="save-setting" type="number" value="0" min="0" max="9" placeholder="Digit 1">
          <input id="pattern2" class="save-setting" type="number" value="1" min="0" max="9" placeholder="Digit 2">
          <input id="pattern3" class="save-setting" type="number" value="6" min="0" max="9" placeholder="Digit 3">
          <input id="pattern4" class="save-setting" type="number" value="7" min="0" max="9" placeholder="Digit 4">
          <input id="pattern5" class="save-setting" type="number" value="8" min="0" max="9" placeholder="Digit 5">
      </div>
      <div style="font-size: 11px; opacity: 0.7; margin-top: 8px; text-align: center;">
          Bot will trade when pattern's "Next Likely" digit matches any of the above targets
      </div>
      
      <div class="ensemble-filter-box">
        <label>‚ö° Next Likely % Filter (Use ONE at a time)</label>
          <div class="ensemble-filter-grid">
              <div>
                  <span style="font-size: 10px; opacity: 0.7; display: block; margin-bottom: 3px;">Trade if ‚â§ (Less/Equal)</span>
                  <input id="patternEnsembleMax" class="save-setting ensemble-filter-input" type="number" value="0" min="0" max="100" placeholder="0 = OFF">
              </div>
              <div>
                  <span style="font-size: 10px; opacity: 0.7; display: block; margin-bottom: 3px;">Trade if ‚â• (Greater/Equal)</span>
                  <input id="patternEnsembleMin" class="save-setting ensemble-filter-input" type="number" value="0" min="0" max="100" placeholder="0 = OFF">
              </div>
          </div>
          <div class="filter-warning" id="filterWarning">
              ‚ö†Ô∏è Cannot use multiple filters! Only ONE can be active
          </div>
          <div class="ensemble-status" id="ensembleFilterStatus">
              All filters disabled - Trading on pattern match only
          </div>
          <div style="font-size: 10px; opacity: 0.6; margin-top: 8px; line-height: 1.4;">
              üìå <strong>Quick Guide:</strong><br>
              <strong>‚â§ (Max):</strong> Trade when Next Likely % is LOW (0 = OFF)<br>
              <strong>‚â• (Min):</strong> Trade when Next Likely % is HIGH (0 = OFF)<br>
              <strong>‚ö†Ô∏è Only ONE filter active at a time</strong>
          </div>
      </div>
      
      <!-- Specific Ensemble Percentages Toggle -->
      <div class="toggle-container">
          <span class="toggle-label">üìä Specific Next Likely % Filter</span>
          <label class="toggle-switch">
              <input type="checkbox" id="specificEnsembleToggle" onchange="toggleSpecificEnsemble()">
              <span class="toggle-slider"></span>
          </label>
      </div>
      
      <div class="specific-ensemble-section" id="specificEnsembleSection">
          <label style="color: #8b5cf6; font-weight: 700; font-size: 12px; margin-bottom: 8px; display: block;">
              üéØ Specific Next Likely Percentages (Pick up to 5)
          </label>
          <div class="specific-ensemble-grid">
              <input id="specEns1" class="save-setting" type="number" value="25" min="0" max="100" placeholder="%1">
              <input id="specEns2" class="save-setting" type="number" value="50" min="0" max="100" placeholder="%2">
              <input id="specEns3" class="save-setting" type="number" value="65" min="0" max="100" placeholder="%3">
              <input id="specEns4" class="save-setting" type="number" value="75" min="0" max="100" placeholder="%4">
              <input id="specEns5" class="save-setting" type="number" value="85" min="0" max="100" placeholder="%5">
          </div>
          <div style="text-align: center; font-size: 11px; margin-top: 8px; padding: 6px; background: #1e293b; border-radius: 4px;" id="specificEnsembleStatus">
              Trade only when Next Likely % matches these specific values
          </div>
          <div style="font-size: 10px; opacity: 0.6; margin-top: 8px; line-height: 1.4;">
              üí° Example: If you set 25, 50, 75 - bot will ONLY trade when Next Likely % is exactly 25%, 50%, or 75%
          </div>
      </div>
  </div>

  <!-- NEW: Mode 5 - Prediction % + Gap Count -->
  <div id="predictionGapUI" class="prediction-gap-container">
      <div style="background: #06b6d4; color: white; padding: 8px; border-radius: 6px; text-align: center; margin-bottom: 10px; font-weight: 700;">
          ‚ö° Mode 5: Prediction % + Gap Count (6 Slots)
      </div>
      
      <div style="font-size: 11px; opacity: 0.8; margin-bottom: 10px; line-height: 1.4;">
          Each slot checks BOTH prediction % range AND gap count. Trade triggers when ANY slot matches BOTH conditions.
      </div>
      
      <div class="sequence-slot" style="border-color: #06b6d4;">
          <div class="sequence-slot-title" style="color: #06b6d4;">Slot 1</div>
          <div class="slot-grid">
              <div><span style="font-size:9px">Prediction % Min</span><input id="pg_s1_pred_min" class="save-setting" type="number" value="55" min="0" max="100"></div>
              <div><span style="font-size:9px">Prediction % Max</span><input id="pg_s1_pred_max" class="save-setting" type="number" value="70" min="0" max="100"></div>
          </div>
          <div style="margin-top: 5px;">
              <span style="font-size:9px; display: block; margin-bottom: 3px;">Gap Count (Exact)</span>
              <input id="pg_s1_gap" class="save-setting" type="number" value="3" min="0" max="50" style="width: 100%; text-align: center;">
          </div>
      </div>

      <div class="sequence-slot" style="border-color: #06b6d4;">
          <div class="sequence-slot-title" style="color: #06b6d4;">Slot 2</div>
          <div class="slot-grid">
              <div><span style="font-size:9px">Prediction % Min</span><input id="pg_s2_pred_min" class="save-setting" type="number" value="60" min="0" max="100"></div>
              <div><span style="font-size:9px">Prediction % Max</span><input id="pg_s2_pred_max" class="save-setting" type="number" value="80" min="0" max="100"></div>
          </div>
          <div style="margin-top: 5px;">
              <span style="font-size:9px; display: block; margin-bottom: 3px;">Gap Count (Exact)</span>
              <input id="pg_s2_gap" class="save-setting" type="number" value="5" min="0" max="50" style="width: 100%; text-align: center;">
          </div>
      </div>

      <div class="sequence-slot" style="border-color: #06b6d4;">
          <div class="sequence-slot-title" style="color: #06b6d4;">Slot 3</div>
          <div class="slot-grid">
              <div><span style="font-size:9px">Prediction % Min</span><input id="pg_s3_pred_min" class="save-setting" type="number" value="65" min="0" max="100"></div>
              <div><span style="font-size:9px">Prediction % Max</span><input id="pg_s3_pred_max" class="save-setting" type="number" value="85" min="0" max="100"></div>
          </div>
          <div style="margin-top: 5px;">
              <span style="font-size:9px; display: block; margin-bottom: 3px;">Gap Count (Exact)</span>
              <input id="pg_s3_gap" class="save-setting" type="number" value="7" min="0" max="50" style="width: 100%; text-align: center;">
          </div>
      </div>

      <div class="sequence-slot" style="border-color: #06b6d4;">
          <div class="sequence-slot-title" style="color: #06b6d4;">Slot 4</div>
          <div class="slot-grid">
              <div><span style="font-size:9px">Prediction % Min</span><input id="pg_s4_pred_min" class="save-setting" type="number" value="70" min="0" max="100"></div>
              <div><span style="font-size:9px">Prediction % Max</span><input id="pg_s4_pred_max" class="save-setting" type="number" value="90" min="0" max="100"></div>
          </div>
          <div style="margin-top: 5px;">
              <span style="font-size:9px; display: block; margin-bottom: 3px;">Gap Count (Exact)</span>
              <input id="pg_s4_gap" class="save-setting" type="number" value="10" min="0" max="50" style="width: 100%; text-align: center;">
          </div>
      </div>

      <div class="sequence-slot" style="border-color: #06b6d4;">
          <div class="sequence-slot-title" style="color: #06b6d4;">Slot 5</div>
          <div class="slot-grid">
              <div><span style="font-size:9px">Prediction % Min</span><input id="pg_s5_pred_min" class="save-setting" type="number" value="50" min="0" max="100"></div>
              <div><span style="font-size:9px">Prediction % Max</span><input id="pg_s5_pred_max" class="save-setting" type="number" value="65" min="0" max="100"></div>
          </div>
          <div style="margin-top: 5px;">
              <span style="font-size:9px; display: block; margin-bottom: 3px;">Gap Count (Exact)</span>
              <input id="pg_s5_gap" class="save-setting" type="number" value="4" min="0" max="50" style="width: 100%; text-align: center;">
          </div>
      </div>

      <div class="sequence-slot" style="border-color: #06b6d4;">
          <div class="sequence-slot-title" style="color: #06b6d4;">Slot 6</div>
          <div class="slot-grid">
              <div><span style="font-size:9px">Prediction % Min</span><input id="pg_s6_pred_min" class="save-setting" type="number" value="75" min="0" max="100"></div>
              <div><span style="font-size:9px">Prediction % Max</span><input id="pg_s6_pred_max" class="save-setting" type="number" value="95" min="0" max="100"></div>
          </div>
          <div style="margin-top: 5px;">
              <span style="font-size:9px; display: block; margin-bottom: 3px;">Gap Count (Exact)</span>
              <input id="pg_s6_gap" class="save-setting" type="number" value="12" min="0" max="50" style="width: 100%; text-align: center;">
          </div>
      </div>

      <div style="background: #1e293b; padding: 8px; border-radius: 4px; margin-top: 10px; font-size: 10px; line-height: 1.4;">
          <strong style="color: #06b6d4;">How it works:</strong><br>
          ‚Ä¢ Each slot checks if prediction % is within range <strong>AND</strong> gap count matches exactly<br>
          ‚Ä¢ Trade executes if <strong>ANY</strong> slot's conditions are met<br>
          ‚Ä¢ Example: Slot 1 = Pred 55-70% + Gap=3 ‚Üí Trades only when BOTH match
      </div>
  </div>

  <label>Market</label>
  <div class="radio-group" id="marketRadios">
      <div class="radio-option" onclick="selectMarket('R_10')">
          <input type="radio" name="market" value="R_10" id="marketR10" checked>
          <label for="marketR10">R_10</label>
      </div>
      <div class="radio-option" onclick="selectMarket('R_25')">
          <input type="radio" name="market" value="R_25" id="marketR25">
          <label for="marketR25">R_25</label>
      </div>
      <div class="radio-option" onclick="selectMarket('R_50')">
          <input type="radio" name="market" value="R_50" id="marketR50">
          <label for="marketR50">R_50</label>
      </div>
      <div class="radio-option" onclick="selectMarket('R_75')">
          <input type="radio" name="market" value="R_75" id="marketR75">
          <label for="marketR75">R_75</label>
      </div>
      <div class="radio-option" onclick="selectMarket('R_100')">
          <input type="radio" name="market" value="R_100" id="marketR100">
          <label for="marketR100">R_100</label>
      </div>
  </div>
</div>

<div class="card">
  <h3>Risk Management</h3>
  <label>Stop Loss ($)</label>
  <input id="stoploss" class="save-setting" type="number" value="10" min="1">
  <label>Take Profit ($)</label>
  <input id="takeprofit" class="save-setting" type="number" value="10" min="1">
</div>

<button onclick="toggleMarketCycle()" id="cycleBtn" class="btn-cycle">Auto Market Cycle: OFF</button>
<button onclick="toggleCooldownLoop()" id="cooldownBtn" class="btn-cooldown">Cycle Cooldown Loop: OFF</button>
<div id="cycleTimerDisplay" class="cycle-timer-display">Next Loop in: --:--</div>

<div class="card" style="margin-top: 0;">
  <label>Wait Time (Minutes)</label>
  <input id="cycleWaitTime" class="save-setting" type="number" value="5" min="1">
</div>

<button onclick="toggleReverseTrade()" id="reverseBtn" class="btn-reverse">Reverse Trade: OFF</button>

<div class="buttons">
  <button onclick="manualTrade()" id="manualBtn">Manual Trade</button>
  <button onclick="toggleAuto()" id="autoBtn">Start Auto</button>
</div>

<button onclick="resetStats()" class="reset-button-permanent">üîÑ Reset All Stats</button>

<div class="card stats">
  <div><span>Trades</span><b id="trades">0</b></div>
  <div><span>Wins</span><b id="wins">0</b></div>
  <div><span>Losses</span><b id="losses">0</b></div>
  <div><span>P/L</span><b id="profit">0.00</b></div>
</div>

<div class="card">
<h3>Trade History</h3>
<div class="table-container">
<table>
<thead><tr><th>#</th><th>Result</th><th>P/L</th><th>Market</th></tr></thead>
<tbody id="history"></tbody>
</table>
</div>
</div>

</div>

<script>
// ============ CORE VARIABLES ============
let ws = null;
let isConnected = false;
let isAutoRunning = false;
let currentContractId = null;
let accountBalance = 0;
let stats = { trades: 0, wins: 0, losses: 0, profit: 0 };
let digitHistory = [];
let sessionStartTime = null;
let timerIntervalId = null;
let isExplicitLogout = false;
let lastPredictionConfidence = 0; 
let previousPredictionConfidence = 0;
let lastPredictionType = '-';
let lastTradeTime = 0;
let lastRequestTime = 0; 
let currentConfidenceMode = 'range';
let currentMarketValue = 'R_10';
let isSpecificEnsembleActive = false;
let currentGapCount = 0;

let isMarketCycleActive = false;
let isCooldownLoopActive = false;
let isCycleCooldown = false;
const marketSequence = ["R_10", "R_25", "R_50", "R_75", "R_100"];
let currentMarketIndex = 0;
let isReverseTradeActive = false;
let cycleTimerId = null;

// ============ VIRTUAL TRADE VARIABLES ============
let isVirtualTradeEnabled = false;
let virtualLossStreak = 0;
let hasSwatchedToLive = false;
let virtualTradeHistory = [];

// ============ ENHANCED ML VARIABLES v3.3 ============
let bayesianAlpha = 1;
let bayesianBeta = 1;
let markovTransitionMatrix = {};
let markovTransitionMatrix2ndOrder = {};
let recentWinRates = [];
let extendedHistory = [];
let patternCache = {};
let volatilityWindow = [];
let detectedPattern = null;

// Model performance tracking
let modelAccuracies = {
    heuristic: 0,
    bayesian: 0,
    markov: 0,
    lgbm: 0
};
let modelPredictions = {
    heuristic: [],
    bayesian: [],
    markov: [],
    lgbm: []
};

// Advanced pattern detection
let fuzzyPatternCache = {};
let patternDecayTimer = 0;

// Decay factor for Bayesian
const BAYESIAN_DECAY = 0.995;

// Histogram-based entry filter with toggle
let digitHistogram = Array(10).fill(0);
let histogramWindow = 1000;
let histogramBias = 'neutral';
let isHistogramFilterEnabled = false;

// Regime Detection
let marketRegime = 'initializing';
let regimeHistory = [];

// Feature Importance Tracking
let featureImportance = {
    frequency: 0,
    gap: 0,
    bayesian: 0,
    markov: 0,
    pattern: 0
};
let featureWinCounts = {
    frequency: 0,
    gap: 0,
    bayesian: 0,
    markov: 0,
    pattern: 0
};
let featureTotalCounts = {
    frequency: 0,
    gap: 0,
    bayesian: 0,
    markov: 0,
    pattern: 0
};

// Confidence Calibration
let calibrationData = [];
let calibrationCurve = null;

// Multi-Scale Patterns
let microPatterns = [];
let mesoPatterns = [];
let macroPatterns = [];

// Weighted Temporal Patterns
const TEMPORAL_DECAY = 0.98;

// LightGBM-style feature engineering
let rollingFeatures = {
    mean_10: 0,
    mean_20: 0,
    mean_50: 0,
    std_10: 0,
    std_20: 0,
    ema_10: 0,
    ema_20: 0,
    roc_5: 0,
    roc_10: 0,
    autocorr_1: 0,
    autocorr_2: 0
};

// HMM States
let hmmStates = ['random', 'structured', 'transitioning'];
let currentHMMState = 'random';
let hmmTransitionProbs = {
    'random': { 'random': 0.7, 'structured': 0.2, 'transitioning': 0.1 },
    'structured': { 'random': 0.1, 'structured': 0.7, 'transitioning': 0.2 },
    'transitioning': { 'random': 0.3, 'structured': 0.3, 'transitioning': 0.4 }
};

// Stacking Meta-Learner weights
let stackingWeights = {
    heuristic: 0.25,
    bayesian: 0.25,
    markov: 0.25,
    lgbm: 0.25
};

// ============ VIRTUAL TRADE FUNCTIONS ============
function toggleVirtualTrade() {
    isVirtualTradeEnabled = document.getElementById('virtualTradeToggle').checked;
    const settingsDiv = document.getElementById('virtualTradeSettings');
    const statusDiv = document.getElementById('virtualTradeStatus');
    const switchNotice = document.getElementById('switchNotice');
    
    if (isVirtualTradeEnabled) {
        settingsDiv.style.display = 'block';
        statusDiv.classList.add('active');
        virtualLossStreak = 0;
        hasSwatchedToLive = false;
        switchNotice.classList.remove('active');
        updateVirtualTradeUI();
        addLog("üéÆ Virtual Trade Mode ENABLED - Trading on virtual account first", "success");
    } else {
        settingsDiv.style.display = 'none';
        statusDiv.classList.remove('active');
        switchNotice.classList.remove('active');
        virtualLossStreak = 0;
        hasSwatchedToLive = false;
        addLog("Virtual Trade Mode DISABLED - Trading on main account", "warn");
    }
    
    saveSettings();
}

function updateVirtualTradeUI() {
    document.getElementById('virtualLossCount').textContent = virtualLossStreak;
    const threshold = parseInt(document.getElementById('virtualLossThreshold').value) || 3;
    document.getElementById('virtualThresholdDisplay').textContent = threshold;
    
    const statusDiv = document.getElementById('virtualTradeStatus');
    const switchNotice = document.getElementById('switchNotice');
    
    if (hasSwatchedToLive) {
        statusDiv.style.display = 'none';
        switchNotice.classList.add('active');
    } else {
        statusDiv.classList.add('active');
        switchNotice.classList.remove('active');
    }
}

function handleVirtualTradeResult(isWin) {
    if (!isVirtualTradeEnabled || hasSwatchedToLive) return;
    
    if (isWin) {
        virtualLossStreak = 0;
        addLog("üéÆ Virtual Trade WIN - Loss streak reset to 0", "success");
    } else {
        virtualLossStreak++;
        addLog(`üéÆ Virtual Trade LOSS - Consecutive losses: ${virtualLossStreak}`, "error");
        
        const threshold = parseInt(document.getElementById('virtualLossThreshold').value) || 3;
        
        if (virtualLossStreak >= threshold) {
            hasSwatchedToLive = true;
            addLog(`‚ö†Ô∏è SWITCHING TO LIVE ACCOUNT after ${virtualLossStreak} consecutive losses!`, "warn");
            addLog("üî¥ Now trading on LIVE account - Real money at risk!", "error");
            updateVirtualTradeUI();
        }
    }
    
    updateVirtualTradeUI();
}

function isCurrentlyVirtualMode() {
    return isVirtualTradeEnabled && !hasSwatchedToLive;
}

// ============ HISTOGRAM FUNCTIONS WITH TOGGLE ============
function toggleHistogramFilter() {
    isHistogramFilterEnabled = document.getElementById('histogramFilterToggle').checked;
    
    if (isHistogramFilterEnabled) {
        addLog("üìä Histogram Filter ENABLED - Will block unfavorable trades", "success");
    } else {
        addLog("üìä Histogram Filter DISABLED - Histogram for display only", "warn");
    }
    
    saveSettings();
}

function updateHistogram(digit) {
    digitHistogram[digit]++;
    
    const total = digitHistogram.reduce((a, b) => a + b, 0);
    if (total > histogramWindow) {
        const oldestIndex = Math.floor(Math.random() * 10);
        if (digitHistogram[oldestIndex] > 0) {
            digitHistogram[oldestIndex]--;
        }
    }
    
    displayHistogram();
    calculateHistogramBias();
}

function displayHistogram() {
    const container = document.getElementById('histogramDisplay');
    if (!container) return;
    
    const total = digitHistogram.reduce((a, b) => a + b, 0);
    if (total === 0) return;
    
    const maxCount = Math.max(...digitHistogram);
    container.innerHTML = '';
    
    digitHistogram.forEach((count, digit) => {
        const percentage = (count / total) * 100;
        const height = (count / maxCount) * 60;
        
        const bar = document.createElement('div');
        bar.className = 'histogram-bar';
        
        let barClass = '';
        if (percentage < 8) barClass = 'low';
        else if (percentage < 10) barClass = 'medium';
        
        bar.innerHTML = `
            <div class="histogram-bar-fill ${barClass}" style="height: ${height}px;"></div>
            <div class="histogram-digit">${digit}</div>
            <div class="histogram-count">${count}</div>
        `;
        
        container.appendChild(bar);
    });
}

function calculateHistogramBias() {
    const total = digitHistogram.reduce((a, b) => a + b, 0);
    if (total < 100) {
        histogramBias = 'neutral';
        updateHistogramBiasDisplay();
        return;
    }
    
    const under5Count = digitHistogram.slice(0, 6).reduce((a, b) => a + b, 0);
    const over5Count = digitHistogram.slice(6, 10).reduce((a, b) => a + b, 0);
    
    const under5Percent = (under5Count / total) * 100;
    const over5Percent = (over5Count / total) * 100;
    
    const imbalanceThreshold = 20;
    
    if (under5Percent < (50 - imbalanceThreshold / 2)) {
        histogramBias = 'favorable_over';
    } else if (over5Percent < (50 - imbalanceThreshold / 2)) {
        histogramBias = 'favorable_under';
    } else {
        histogramBias = 'neutral';
    }
    
    updateHistogramBiasDisplay();
}

function updateHistogramBiasDisplay() {
    const biasEl = document.getElementById('histogramBias');
    if (!biasEl) return;
    
    const total = digitHistogram.reduce((a, b) => a + b, 0);
    const under5Count = digitHistogram.slice(0, 6).reduce((a, b) => a + b, 0);
    const over5Count = digitHistogram.slice(6, 10).reduce((a, b) => a + b, 0);
    const under5Percent = total > 0 ? ((under5Count / total) * 100).toFixed(1) : 0;
    const over5Percent = total > 0 ? ((over5Count / total) * 100).toFixed(1) : 0;
    
    if (histogramBias === 'favorable_over') {
        biasEl.className = 'histogram-bias favorable';
        biasEl.textContent = `‚úÖ FAVORABLE for Over 5 (Under: ${under5Percent}% | Over: ${over5Percent}%)`;
    } else if (histogramBias === 'favorable_under') {
        biasEl.className = 'histogram-bias unfavorable';
        biasEl.textContent = `‚ö†Ô∏è UNFAVORABLE for Over 5 (Under: ${under5Percent}% | Over: ${over5Percent}%)`;
    } else {
        biasEl.className = 'histogram-bias neutral';
        biasEl.textContent = `‚ö™ NEUTRAL (Under: ${under5Percent}% | Over: ${over5Percent}%)`;
    }
}

// ============ REGIME DETECTION ============
function detectMarketRegime() {
    if (digitHistory.length < 50) {
        marketRegime = 'initializing';
        updateRegimeDisplay();
        return;
    }
    
    const recentDigits = digitHistory.slice(0, 50);
    
    const digitCounts = Array(10).fill(0);
    recentDigits.forEach(d => digitCounts[d]++);
    
    const entropy = calculateEntropy(digitCounts);
    
    let longestRun = 1;
    let currentRun = 1;
    for (let i = 1; i < recentDigits.length; i++) {
        if (recentDigits[i] === recentDigits[i-1]) {
            currentRun++;
            longestRun = Math.max(longestRun, currentRun);
        } else {
            currentRun = 1;
        }
    }
    
    let changeCount = 0;
    for (let i = 1; i < recentDigits.length; i++) {
        if (recentDigits[i] !== recentDigits[i-1]) changeCount++;
    }
    const changeFrequency = changeCount / recentDigits.length;
    
    if (entropy > 3.0 && changeFrequency > 0.85) {
        marketRegime = 'random';
    } else if (entropy < 2.5 && longestRun > 5) {
        marketRegime = 'structured';
    } else {
        marketRegime = 'transitioning';
    }
    
    regimeHistory.push(marketRegime);
    if (regimeHistory.length > 20) regimeHistory.shift();
    
    updateRegimeDisplay();
}

function calculateEntropy(counts) {
    const total = counts.reduce((a, b) => a + b, 0);
    if (total === 0) return 0;
    
    let entropy = 0;
    counts.forEach(count => {
        if (count > 0) {
            const p = count / total;
            entropy -= p * Math.log2(p);
        }
    });
    
    return entropy;
}

function updateRegimeDisplay() {
    const regimeEl = document.getElementById('regimeValue');
    if (!regimeEl) return;
    
    let regimeText = '';
    let regimeClass = '';
    
    switch(marketRegime) {
        case 'random':
            regimeText = 'üé≤ Random (High Entropy)';
            regimeClass = 'regime-random';
            break;
        case 'structured':
            regimeText = 'üìä Structured (Low Entropy)';
            regimeClass = 'regime-structured';
            break;
        case 'transitioning':
            regimeText = '‚ö° Transitioning';
            regimeClass = 'regime-transitioning';
            break;
        default:
            regimeText = 'üîÑ Initializing...';
            regimeClass = '';
    }
    
    regimeEl.textContent = regimeText;
    regimeEl.className = 'regime-value ' + regimeClass;
}

// ============ FEATURE IMPORTANCE TRACKING ============
function updateFeatureImportance(features, isWin) {
    if (features.frequency) {
        featureTotalCounts.frequency++;
        if (isWin) featureWinCounts.frequency++;
    }
    
    if (features.gap) {
        featureTotalCounts.gap++;
        if (isWin) featureWinCounts.gap++;
    }
    
    if (features.bayesian) {
        featureTotalCounts.bayesian++;
        if (isWin) featureWinCounts.bayesian++;
    }
    
    if (features.markov) {
        featureTotalCounts.markov++;
        if (isWin) featureWinCounts.markov++;
    }
    
    if (features.pattern) {
        featureTotalCounts.pattern++;
        if (isWin) featureWinCounts.pattern++;
    }
    
    for (let feature in featureImportance) {
        if (featureTotalCounts[feature] > 0) {
            featureImportance[feature] = (featureWinCounts[feature] / featureTotalCounts[feature]) * 100;
        }
    }
    
    updateFeatureImportanceDisplay();
}

function updateFeatureImportanceDisplay() {
    const freqEl = document.getElementById('featFreq');
    const gapEl = document.getElementById('featGap');
    const bayesEl = document.getElementById('featBayes');
    const markovEl = document.getElementById('featMarkov');
    
    if (freqEl && featureImportance.frequency > 0) {
        freqEl.innerHTML = `<span>Freq: ${featureImportance.frequency.toFixed(0)}%</span>`;
        freqEl.className = featureImportance.frequency >= 55 ? 'feature-high' : 'feature-low';
    }
    
    if (gapEl && featureImportance.gap > 0) {
        gapEl.innerHTML = `<span>Gap: ${featureImportance.gap.toFixed(0)}%</span>`;
        gapEl.className = featureImportance.gap >= 55 ? 'feature-high' : 'feature-low';
    }
    
    if (bayesEl && featureImportance.bayesian > 0) {
        bayesEl.innerHTML = `<span>Bayes: ${featureImportance.bayesian.toFixed(0)}%</span>`;
        bayesEl.className = featureImportance.bayesian >= 55 ? 'feature-high' : 'feature-low';
    }
    
    if (markovEl && featureImportance.markov > 0) {
        markovEl.innerHTML = `<span>Markov: ${featureImportance.markov.toFixed(0)}%</span>`;
        markovEl.className = featureImportance.markov >= 55 ? 'feature-high' : 'feature-low';
    }
}

// ============ CONFIDENCE CALIBRATION ============
function calibrateConfidence(rawConfidence) {
    if (calibrationData.length < 20) {
        return rawConfidence;
    }
    
    const bins = [0, 40, 45, 50, 55, 60, 65, 70, 75, 80, 100];
    const binIndex = bins.findIndex(bin => rawConfidence <= bin) - 1;
    
    if (binIndex < 0 || binIndex >= bins.length - 1) {
        return rawConfidence;
    }
    
    const binData = calibrationData.filter(d => 
        d.predicted >= bins[binIndex] && d.predicted < bins[binIndex + 1]
    );
    
    if (binData.length < 3) {
        return rawConfidence;
    }
    
    const actualWinRate = binData.filter(d => d.actual === 1).length / binData.length;
    const calibratedConf = actualWinRate * 100;
    
    return calibratedConf;
}

function addCalibrationData(predicted, actual) {
    calibrationData.push({ predicted, actual });
    
    if (calibrationData.length > 200) {
        calibrationData.shift();
    }
}

function updateCalibrationDisplay(calibrated) {
    const calEl = document.getElementById('calibratedConf');
    if (calEl) {
        calEl.textContent = `${calibrated.toFixed(1)}%`;
    }
}

// ============ ROLLING FEATURES (LightGBM-style) ============
function calculateRollingFeatures() {
    if (digitHistory.length < 10) return;
    
    const recent10 = digitHistory.slice(0, 10);
    const recent20 = digitHistory.slice(0, Math.min(20, digitHistory.length));
    const recent50 = digitHistory.slice(0, Math.min(50, digitHistory.length));
    
    rollingFeatures.mean_10 = recent10.reduce((a, b) => a + b, 0) / recent10.length;
    rollingFeatures.mean_20 = recent20.reduce((a, b) => a + b, 0) / recent20.length;
    rollingFeatures.mean_50 = recent50.reduce((a, b) => a + b, 0) / recent50.length;
    
    const variance10 = recent10.reduce((sum, val) => sum + Math.pow(val - rollingFeatures.mean_10, 2), 0) / recent10.length;
    rollingFeatures.std_10 = Math.sqrt(variance10);
    
    const variance20 = recent20.reduce((sum, val) => sum + Math.pow(val - rollingFeatures.mean_20, 2), 0) / recent20.length;
    rollingFeatures.std_20 = Math.sqrt(variance20);
    
    if (digitHistory.length === 1) {
        rollingFeatures.ema_10 = digitHistory[0];
        rollingFeatures.ema_20 = digitHistory[0];
    } else {
        const alpha10 = 2 / (10 + 1);
        const alpha20 = 2 / (20 + 1);
        rollingFeatures.ema_10 = alpha10 * digitHistory[0] + (1 - alpha10) * rollingFeatures.ema_10;
        rollingFeatures.ema_20 = alpha20 * digitHistory[0] + (1 - alpha20) * rollingFeatures.ema_20;
    }
    
    if (digitHistory.length >= 5) {
        rollingFeatures.roc_5 = ((digitHistory[0] - digitHistory[4]) / (digitHistory[4] + 0.1)) * 100;
    }
    if (digitHistory.length >= 10) {
        rollingFeatures.roc_10 = ((digitHistory[0] - digitHistory[9]) / (digitHistory[9] + 0.1)) * 100;
    }
    
    if (digitHistory.length >= 20) {
        rollingFeatures.autocorr_1 = calculateAutocorrelation(digitHistory.slice(0, 20), 1);
        rollingFeatures.autocorr_2 = calculateAutocorrelation(digitHistory.slice(0, 20), 2);
    }
}

function calculateAutocorrelation(data, lag) {
    if (data.length <= lag) return 0;
    
    const mean = data.reduce((a, b) => a + b, 0) / data.length;
    let numerator = 0;
    let denominator = 0;
    
    for (let i = 0; i < data.length - lag; i++) {
        numerator += (data[i] - mean) * (data[i + lag] - mean);
    }
    
    for (let i = 0; i < data.length; i++) {
        denominator += Math.pow(data[i] - mean, 2);
    }
    
    return denominator !== 0 ? numerator / denominator : 0;
}

// ============ LIGHTGBM-STYLE PREDICTION ============
function calculateLightGBMPrediction() {
    if (digitHistory.length < 20) return 50;
    
    calculateRollingFeatures();
    
    let score = 50;
    
    const meanDeviation = rollingFeatures.mean_10 - 4.5;
    if (meanDeviation < -0.5) {
        score += 8;
    } else if (meanDeviation > 0.5) {
        score -= 5;
    }
    
    if (rollingFeatures.std_10 < 2.0) {
        score += 5;
    } else if (rollingFeatures.std_10 > 3.0) {
        score -= 8;
    }
    
    if (rollingFeatures.ema_10 < rollingFeatures.ema_20) {
        score += 6;
    }
    
    if (rollingFeatures.roc_5 < -10) {
        score += 7;
    } else if (rollingFeatures.roc_5 > 10) {
        score -= 6;
    }
    
    if (rollingFeatures.autocorr_1 < -0.2) {
        score += 5;
    }
    
    const recent10 = digitHistory.slice(0, 10);
    const over5Count = recent10.filter(d => d > 5).length;
    const over5Ratio = over5Count / 10;
    
    if (over5Ratio < 0.3) {
        score += 12;
    } else if (over5Ratio > 0.7) {
        score -= 10;
    }
    
    if (marketRegime === 'random') {
        score *= 0.85;
    } else if (marketRegime === 'structured') {
        score *= 1.1;
    }
    
    return Math.min(98, Math.max(2, score));
}

// ============ IMPROVED PATTERN DETECTION v3.3 ============
function detectMultiScalePatterns() {
    if (digitHistory.length < 10) return null;
    
    const sourceData = extendedHistory.length > 100 ? extendedHistory : digitHistory;
    
    // More conservative depth range for better quality patterns
    for (let depth = 3; depth <= 6; depth++) {
        if (digitHistory.length < depth) continue;
        
        const currentPattern = digitHistory.slice(0, depth);
        let totalFound = 0;
        let nextOverCount = 0;
        let nextLikelyFreq = Array(10).fill(0);
        
        const scanLimit = Math.min(sourceData.length - depth - 1, 500);
        
        for (let i = 1; i < scanLimit; i++) {
            let matchCount = 0;
            
            for (let k = 0; k < depth; k++) {
                if (sourceData[i + k] === currentPattern[k]) {
                    matchCount++;
                }
            }
            
            // More strict matching: 85% or better for quality
            const matchPercent = matchCount / depth;
            if (matchPercent >= 0.85) {
                const weight = Math.pow(TEMPORAL_DECAY, i / 10) * matchPercent;
                totalFound += weight;
                
                const nextDigit = sourceData[i - 1];
                if (nextDigit > 5) nextOverCount += weight;
                nextLikelyFreq[nextDigit] += weight;
            }
        }
        
        // Higher threshold for pattern quality
        if (totalFound >= 2.5) {
            const probOver = (nextOverCount / totalFound) * 100;
            
            let bestDigit = -1;
            let maxFreq = -1;
            for (let d = 0; d <= 9; d++) {
                if (nextLikelyFreq[d] > maxFreq) {
                    maxFreq = nextLikelyFreq[d];
                    bestDigit = d;
                }
            }
            
            const patternStr = [...currentPattern].reverse().join('-');
            const isExactMatch = totalFound > (scanLimit * 0.02);
            
            return {
                pattern: `Pattern(${depth}): ${patternStr}`,
                nextDigit: bestDigit,
                confidence: probOver,
                fuzzy: !isExactMatch,
                distance: totalFound,
                scale: depth >= 5 ? 'meso' : 'micro'
            };
        }
    }
    
    // Fallback to statistical if no quality pattern found
    if (digitHistory.length >= 15) {
        const recent15 = digitHistory.slice(0, 15);
        const over5Count = recent15.filter(d => d > 5).length;
        const probOver = (over5Count / 15) * 100;
        
        const digitCounts = Array(10).fill(0);
        recent15.forEach(d => digitCounts[d]++);
        let mostCommon = 0;
        let maxCount = 0;
        digitCounts.forEach((count, digit) => {
            if (count > maxCount) {
                maxCount = count;
                mostCommon = digit;
            }
        });
        
        return {
            pattern: `Statistical(15): Freq-Based`,
            nextDigit: mostCommon,
            confidence: probOver,
            fuzzy: true,
            distance: 15,
            scale: 'statistical'
        };
    }
    
    return null;
}

// ============ STACKING META-LEARNER ============
function updateStackingWeights() {
    if (modelAccuracies.heuristic === 0 && modelAccuracies.bayesian === 0 && 
        modelAccuracies.markov === 0 && modelAccuracies.lgbm === 0) {
        stackingWeights = {
            heuristic: 0.25,
            bayesian: 0.25,
            markov: 0.25,
            lgbm: 0.25
        };
        return;
    }
    
    const totalAccuracy = modelAccuracies.heuristic + modelAccuracies.bayesian + 
                          modelAccuracies.markov + modelAccuracies.lgbm;
    
    if (totalAccuracy > 0) {
        stackingWeights.heuristic = modelAccuracies.heuristic / totalAccuracy;
        stackingWeights.bayesian = modelAccuracies.bayesian / totalAccuracy;
        stackingWeights.markov = modelAccuracies.markov / totalAccuracy;
        stackingWeights.lgbm = modelAccuracies.lgbm / totalAccuracy;
    }
    
    const expSum = Math.exp(stackingWeights.heuristic) + Math.exp(stackingWeights.bayesian) + 
                   Math.exp(stackingWeights.markov) + Math.exp(stackingWeights.lgbm);
    
    stackingWeights.heuristic = Math.exp(stackingWeights.heuristic) / expSum;
    stackingWeights.bayesian = Math.exp(stackingWeights.bayesian) / expSum;
    stackingWeights.markov = Math.exp(stackingWeights.markov) / expSum;
    stackingWeights.lgbm = Math.exp(stackingWeights.lgbm) / expSum;
}

// ============ UTILITY FUNCTIONS ============
function addLog(msg, type = 'info') {
    const container = document.getElementById('logContainer');
    const time = new Date().toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
    const entry = document.createElement('div');
    entry.className = 'log-entry';
    entry.innerHTML = `<span class="log-time">[${time}]</span> <span class="log-msg-${type}">${msg}</span>`;
    container.appendChild(entry);
    container.scrollTop = container.scrollHeight;
}

function selectConfidenceMode(mode) {
    currentConfidenceMode = mode;
    document.querySelectorAll('#confidenceModeRadios .radio-option').forEach(opt => {
        opt.classList.remove('selected');
    });
    const selectedOption = document.querySelector(`#confidenceModeRadios .radio-option input[value="${mode}"]`).parentElement;
    selectedOption.classList.add('selected');
    document.getElementById(`mode${mode.charAt(0).toUpperCase() + mode.slice(1)}`).checked = true;
    
    toggleConfidenceUI();
    saveSettings();
}

function selectMarket(market) {
    currentMarketValue = market;
    document.querySelectorAll('#marketRadios .radio-option').forEach(opt => {
        opt.classList.remove('selected');
    });
    const selectedOption = document.querySelector(`#marketRadios .radio-option input[value="${market}"]`).parentElement;
    selectedOption.classList.add('selected');
    document.getElementById(`market${market.replace('_', '')}`).checked = true;
    
    if (isConnected) subscribeToTicks();
    saveSettings();
}

function toggleSpecificEnsemble() {
    isSpecificEnsembleActive = document.getElementById('specificEnsembleToggle').checked;
    const section = document.getElementById('specificEnsembleSection');
    
    if (isSpecificEnsembleActive) {
        section.classList.add('active');
        document.getElementById('patternEnsembleMax').value = 0;
        document.getElementById('patternEnsembleMin').value = 0;
        addLog("Specific Next Likely % Filter ENABLED", "info");
    } else {
        section.classList.remove('active');
        addLog("Specific Next Likely % Filter DISABLED", "warn");
    }
    
    updateEnsembleFilterStatus();
    saveSettings();
}

function updateEnsembleFilterStatus() {
    const maxEnsemble = parseInt(document.getElementById('patternEnsembleMax').value) || 0;
    const minEnsemble = parseInt(document.getElementById('patternEnsembleMin').value) || 0;
    const statusEl = document.getElementById('ensembleFilterStatus');
    const warningEl = document.getElementById('filterWarning');
    
    let activeCount = 0;
    if (maxEnsemble > 0) activeCount++;
    if (minEnsemble > 0) activeCount++;
    if (isSpecificEnsembleActive) activeCount++;
    
    if (activeCount > 1) {
        warningEl.style.display = 'block';
        statusEl.textContent = '‚ö†Ô∏è CONFLICT! Multiple filters active - Only ONE allowed';
        statusEl.style.color = '#ef4444';
        statusEl.style.background = 'rgba(239, 68, 68, 0.1)';
        statusEl.style.border = '1px solid #ef4444';
        return;
    }
    
    warningEl.style.display = 'none';
    statusEl.style.background = '#1e293b';
    statusEl.style.border = 'none';
    
    if (activeCount === 0) {
        statusEl.textContent = 'üîì All filters DISABLED - Trading on pattern match only';
        statusEl.style.color = '#22c55e';
    }
    else if (maxEnsemble > 0) {
        statusEl.textContent = `üîí Active: Trade if Next Likely % ‚â§ ${maxEnsemble}% (LOW confidence)`;
        statusEl.style.color = '#f59e0b';
    }
    else if (minEnsemble > 0) {
        statusEl.textContent = `üîí Active: Trade if Next Likely % ‚â• ${minEnsemble}% (HIGH confidence)`;
        statusEl.style.color = '#3b82f6';
    }
    else if (isSpecificEnsembleActive) {
        const specs = [
            parseInt(document.getElementById('specEns1').value),
            parseInt(document.getElementById('specEns2').value),
            parseInt(document.getElementById('specEns3').value),
            parseInt(document.getElementById('specEns4').value),
            parseInt(document.getElementById('specEns5').value)
        ].filter(v => !isNaN(v) && v >= 0 && v <= 100);
        statusEl.textContent = `üéØ Active: Trade if Next Likely % = ${specs.join(', ')}%`;
        statusEl.style.color = '#8b5cf6';
    }
}

function toggleConfidenceUI() {
    const mode = currentConfidenceMode;
    document.getElementById('rangeUI').style.display = (mode === 'range') ? 'block' : 'none';
    document.getElementById('specificUI').style.display = (mode === 'specific') ? 'block' : 'none';
    document.getElementById('sequenceUI').style.display = (mode === 'sequence') ? 'block' : 'none';
    document.getElementById('patternUI').style.display = (mode === 'pattern') ? 'block' : 'none';
    document.getElementById('predictionGapUI').classList.toggle('active', mode === 'predictionGap');
    
    if (mode === 'pattern') {
        updateEnsembleFilterStatus();
    }
    
    addLog(`Confidence Mode: ${mode}`, "info");
}

function saveSettings() {
    const settings = {
        confidenceMode: currentConfidenceMode,
        market: currentMarketValue,
        specificEnsembleActive: isSpecificEnsembleActive,
        virtualTradeEnabled: isVirtualTradeEnabled,
        virtualLossStreak: virtualLossStreak,
        hasSwatchedToLive: hasSwatchedToLive,
        histogramFilterEnabled: isHistogramFilterEnabled
    };
    document.querySelectorAll('.save-setting').forEach(el => settings[el.id] = el.value);
    localStorage.setItem('bot_settings_v13_ml', JSON.stringify(settings));
}

function loadSettings() {
    const saved = localStorage.getItem('bot_settings_v13_ml');
    if (saved) {
        const settings = JSON.parse(saved);
        for (const id in settings) {
            const el = document.getElementById(id);
            if (el) el.value = settings[id];
        }
        
        if (settings.confidenceMode) {
            currentConfidenceMode = settings.confidenceMode;
            selectConfidenceMode(currentConfidenceMode);
        }
        
        if (settings.market) {
            currentMarketValue = settings.market;
            selectMarket(currentMarketValue);
        }
        
        if (settings.specificEnsembleActive) {
            isSpecificEnsembleActive = settings.specificEnsembleActive;
            document.getElementById('specificEnsembleToggle').checked = isSpecificEnsembleActive;
            if (isSpecificEnsembleActive) {
                document.getElementById('specificEnsembleSection').classList.add('active');
            }
        }
        
        if (settings.virtualTradeEnabled !== undefined) {
            isVirtualTradeEnabled = settings.virtualTradeEnabled;
            document.getElementById('virtualTradeToggle').checked = isVirtualTradeEnabled;
            if (isVirtualTradeEnabled) {
                document.getElementById('virtualTradeSettings').style.display = 'block';
            }
        }
        
        if (settings.virtualLossStreak !== undefined) {
            virtualLossStreak = settings.virtualLossStreak;
        }
        
        if (settings.hasSwatchedToLive !== undefined) {
            hasSwatchedToLive = settings.hasSwatchedToLive;
        }
        
        if (settings.histogramFilterEnabled !== undefined) {
            isHistogramFilterEnabled = settings.histogramFilterEnabled;
            document.getElementById('histogramFilterToggle').checked = isHistogramFilterEnabled;
        }
        
        updateVirtualTradeUI();
    }
    toggleConfidenceUI();
    
    const savedExtHistory = localStorage.getItem('extended_history_v13');
    if(savedExtHistory) {
        try {
            extendedHistory = JSON.parse(savedExtHistory);
            addLog(`Loaded ${extendedHistory.length} historical ticks for ML`, "success");
        } catch(e) {
            addLog("Error loading extended history", "warn");
            extendedHistory = [];
        }
    }
    
    const savedHistory = localStorage.getItem('trade_history_v13');
    if(savedHistory) document.getElementById('history').innerHTML = savedHistory;
    
    const savedStats = localStorage.getItem('trade_stats_v13');
    if(savedStats) { 
        stats = JSON.parse(savedStats); 
        updateStats(); 
    }
    
    const savedBayesian = localStorage.getItem('bayesian_params_v13');
    if(savedBayesian) {
        const params = JSON.parse(savedBayesian);
        bayesianAlpha = params.alpha || 1;
        bayesianBeta = params.beta || 1;
    }
    
    const savedMarkov = localStorage.getItem('markov_matrix_v13');
    if(savedMarkov) {
        try {
            markovTransitionMatrix = JSON.parse(savedMarkov);
            addLog("Loaded Markov transition matrix", "success");
        } catch(e) {
            markovTransitionMatrix = {};
        }
    }
    
    const savedMarkov2nd = localStorage.getItem('markov_matrix_2nd_v13');
    if(savedMarkov2nd) {
        try {
            markovTransitionMatrix2ndOrder = JSON.parse(savedMarkov2nd);
            addLog("Loaded 2nd-order Markov matrix", "success");
        } catch(e) {
            markovTransitionMatrix2ndOrder = {};
        }
    }
    
    const savedCalibration = localStorage.getItem('calibration_data_v13');
    if(savedCalibration) {
        try {
            calibrationData = JSON.parse(savedCalibration);
            addLog("Loaded calibration data", "success");
        } catch(e) {
            calibrationData = [];
        }
    }
}

document.querySelectorAll('.save-setting').forEach(el => {
    el.addEventListener('input', saveSettings);
    el.addEventListener('change', saveSettings);
});

// ============ WEBSOCKET CONNECTION ============
function connect() {
  const token = document.getElementById('token').value.trim();
  if (!token) { addLog("Error: API Token missing.", "error"); return; }
  if (ws) ws.close();
  sessionStorage.setItem('derivToken', token);
  isExplicitLogout = false;
  updateStatus('Connecting...', 'disconnected');
  ws = new WebSocket('wss://ws.derivws.com/websockets/v3?app_id=1089');
  ws.onopen = () => { addLog("WebSocket Connected.", "info"); sendAPIRequest({ authorize: token }); };
  ws.onmessage = (msg) => handleMessage(JSON.parse(msg.data));
  ws.onclose = () => {
    isConnected = false;
    updateStatus('Disconnected', 'disconnected');
    document.getElementById('accountType').style.display = 'none';
    if (!isExplicitLogout) { 
        addLog("Connection lost. Reconnecting in 5s...", "warn"); 
        setTimeout(connect, 5000); 
    }
  };
  ws.onerror = (error) => {
    addLog("WebSocket error occurred", "error");
    console.error("WebSocket error:", error);
  };
}

function handleMessage(data) {
  if (data.error) { 
    addLog(`API ERROR: ${data.error.message}`, "error"); 
    console.error("API Error:", data.error);
    return; 
  }
  
  if (data.authorize) {
    isConnected = true;
    updateStatus('Connected', 'connected');
    const accTypeEl = document.getElementById('accountType');
    const isVirtual = data.authorize.is_virtual === 1 || data.authorize.loginid.includes('VRTC');
    accTypeEl.textContent = isVirtual ? 'Demo Account' : 'Live Account';
    accTypeEl.className = 'account-type ' + (isVirtual ? 'demo-badge' : 'live-badge');
    accTypeEl.style.display = 'block';
    addLog(`Authorized: ${data.authorize.email}`, "success");
    sendAPIRequest({ balance: 1, subscribe: 1 });
    subscribeToTicks();
    startSessionTimer();
  }
  
  if (data.balance) { 
    accountBalance = data.balance.balance; 
    updateBalance(); 
  }
  
  if (data.tick) {
    const lastDigit = parseInt(data.tick.quote.toString().slice(-1));
    addDigitToAnalyzer(lastDigit);
  }
  
  if (data.buy) {
    currentContractId = data.buy.contract_id;
    const tradeMode = isCurrentlyVirtualMode() ? "VIRTUAL" : "LIVE";
    addLog(`${tradeMode} Trade Placed (ID: ${currentContractId})`, "success");
    sendAPIRequest({ proposal_open_contract: 1, contract_id: currentContractId, subscribe: 1 });
  }
  
  if (data.proposal_open_contract) {
    const contract = data.proposal_open_contract;
    if (contract.is_settled === 1 || ['won', 'lost', 'sold'].includes(contract.status)) {
      handleTradeResult(contract);
      currentContractId = null;
      if (data.subscription) sendAPIRequest({ forget: data.subscription.id });
    }
  }
}

// ============ ENHANCED ML FUNCTIONS v3.3 ============

function smoothOutliers(digit, history) {
    if (history.length < 10) return digit;
    
    const mean = history.reduce((a, b) => a + b, 0) / history.length;
    const variance = history.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / history.length;
    const stdDev = Math.sqrt(variance);
    
    if (stdDev > 0 && Math.abs(digit - mean) > 3 * stdDev) {
        const smoothed = Math.round(mean);
        addLog(`Outlier detected: ${digit} ‚Üí smoothed to ${smoothed}`, "warn");
        return smoothed;
    }
    
    return digit;
}

function calculateVolatility(data, windowSize = 50) {
    if (data.length < windowSize) windowSize = data.length;
    if (windowSize < 2) return 0;
    
    const recent = data.slice(0, windowSize);
    const mean = recent.reduce((a, b) => a + b, 0) / recent.length;
    const variance = recent.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / recent.length;
    return Math.sqrt(variance);
}

function updateBayesianModel(isOver5) {
    bayesianAlpha *= BAYESIAN_DECAY;
    bayesianBeta *= BAYESIAN_DECAY;
    
    if (isOver5) {
        bayesianAlpha += 1;
    } else {
        bayesianBeta += 1;
    }
    
    if ((bayesianAlpha + bayesianBeta) % 20 < 1) {
        localStorage.setItem('bayesian_params_v13', JSON.stringify({
            alpha: bayesianAlpha,
            beta: bayesianBeta
        }));
    }
    
    const posteriorMean = bayesianAlpha / (bayesianAlpha + bayesianBeta);
    return posteriorMean * 100;
}

function updateMarkovModel(currentDigit) {
    if (digitHistory.length < 1) return;
    
    const prevDigit = digitHistory[0];
    if (!markovTransitionMatrix[prevDigit]) {
        markovTransitionMatrix[prevDigit] = Array(10).fill(0);
    }
    markovTransitionMatrix[prevDigit][currentDigit]++;
    
    if (digitHistory.length >= 2) {
        const state = `${digitHistory[1]}-${digitHistory[0]}`;
        if (!markovTransitionMatrix2ndOrder[state]) {
            markovTransitionMatrix2ndOrder[state] = Array(10).fill(0);
        }
        markovTransitionMatrix2ndOrder[state][currentDigit]++;
    }
    
    if (digitHistory.length % 50 === 0) {
        localStorage.setItem('markov_matrix_v13', JSON.stringify(markovTransitionMatrix));
        localStorage.setItem('markov_matrix_2nd_v13', JSON.stringify(markovTransitionMatrix2ndOrder));
    }
}

function calculateMarkovPrediction() {
    let prediction = 50;
    
    if (digitHistory.length >= 2) {
        const state = `${digitHistory[1]}-${digitHistory[0]}`;
        if (markovTransitionMatrix2ndOrder[state]) {
            const transitions = markovTransitionMatrix2ndOrder[state];
            const totalTransitions = transitions.reduce((a, b) => a + b, 0);
            
            if (totalTransitions > 0) {
                const smoothedTransitions = transitions.map(t => t + 1);
                const smoothedTotal = smoothedTransitions.reduce((a, b) => a + b, 0);
                const over5Transitions = smoothedTransitions.slice(6, 10).reduce((a, b) => a + b, 0);
                prediction = (over5Transitions / smoothedTotal) * 100;
                return prediction;
            }
        }
    }
    
    if (digitHistory.length >= 1 && markovTransitionMatrix[digitHistory[0]]) {
        const transitions = markovTransitionMatrix[digitHistory[0]];
        const totalTransitions = transitions.reduce((a, b) => a + b, 0);
        
        if (totalTransitions > 0) {
            const smoothedTransitions = transitions.map(t => t + 1);
            const smoothedTotal = smoothedTransitions.reduce((a, b) => a + b, 0);
            const over5Transitions = smoothedTransitions.slice(6, 10).reduce((a, b) => a + b, 0);
            prediction = (over5Transitions / smoothedTotal) * 100;
        }
    }
    
    return prediction;
}

function calculateAdaptiveThreshold() {
    if (recentWinRates.length < 5) return 0;
    
    const recentAvg = recentWinRates.slice(-10).reduce((a, b) => a + b, 0) / Math.min(10, recentWinRates.length);
    
    if (recentAvg < 0.40) {
        return 15;
    } else if (recentAvg < 0.45) {
        return 10;
    } else if (recentAvg > 0.65) {
        return -8;
    } else if (recentAvg > 0.60) {
        return -5;
    }
    return 0;
}

function calculateEnsemblePrediction(heuristicConf, bayesianProb, markovProb, lgbmProb, volatility) {
    updateStackingWeights();
    
    const pattern = detectMultiScalePatterns();
    let patternBonus = 0;
    if (pattern) {
        patternBonus = pattern.fuzzy ? 3 : 5;
        if (pattern.confidence > 70) patternBonus += 5;
        if (pattern.scale === 'meso') patternBonus += 3;
    }
    
    const ensemble = (
        heuristicConf * stackingWeights.heuristic +
        bayesianProb * stackingWeights.bayesian +
        markovProb * stackingWeights.markov +
        lgbmProb * stackingWeights.lgbm +
        patternBonus
    );
    
    let regimeAdjustment = 1.0;
    if (marketRegime === 'random') {
        regimeAdjustment = 0.85;
    } else if (marketRegime === 'structured') {
        regimeAdjustment = 1.15;
    }
    
    return Math.min(98, Math.max(0, ensemble * regimeAdjustment));
}

function updateModelAccuracies(actualResult) {
    const isOver5 = actualResult > 5;
    
    if (modelPredictions.heuristic.length > 0) {
        const lastHeuristic = modelPredictions.heuristic[modelPredictions.heuristic.length - 1];
        const heuristicCorrect = (lastHeuristic.prediction === 'OVER' && isOver5) || 
                                  (lastHeuristic.prediction === 'UNDER' && !isOver5);
        
        modelPredictions.heuristic.push({ correct: heuristicCorrect });
        if (modelPredictions.heuristic.length > 50) modelPredictions.heuristic.shift();
        
        const correctCount = modelPredictions.heuristic.filter(p => p.correct).length;
        modelAccuracies.heuristic = (correctCount / modelPredictions.heuristic.length) * 100;
    }
    
    if (modelPredictions.bayesian.length > 0) {
        const lastBayesian = modelPredictions.bayesian[modelPredictions.bayesian.length - 1];
        const bayesianCorrect = (lastBayesian.prediction > 50 && isOver5) || 
                                 (lastBayesian.prediction <= 50 && !isOver5);
        
        modelPredictions.bayesian.push({ correct: bayesianCorrect });
        if (modelPredictions.bayesian.length > 50) modelPredictions.bayesian.shift();
        
        const correctCount = modelPredictions.bayesian.filter(p => p.correct).length;
        modelAccuracies.bayesian = (correctCount / modelPredictions.bayesian.length) * 100;
    }
    
    if (modelPredictions.markov.length > 0) {
        const lastMarkov = modelPredictions.markov[modelPredictions.markov.length - 1];
        const markovCorrect = (lastMarkov.prediction > 50 && isOver5) || 
                               (lastMarkov.prediction <= 50 && !isOver5);
        
        modelPredictions.markov.push({ correct: markovCorrect });
        if (modelPredictions.markov.length > 50) modelPredictions.markov.shift();
        
        const correctCount = modelPredictions.markov.filter(p => p.correct).length;
        modelAccuracies.markov = (correctCount / modelPredictions.markov.length) * 100;
    }
    
    if (modelPredictions.lgbm.length > 0) {
        const lastLGBM = modelPredictions.lgbm[modelPredictions.lgbm.length - 1];
        const lgbmCorrect = (lastLGBM.prediction > 50 && isOver5) || 
                            (lastLGBM.prediction <= 50 && !isOver5);
        
        modelPredictions.lgbm.push({ correct: lgbmCorrect });
        if (modelPredictions.lgbm.length > 50) modelPredictions.lgbm.shift();
        
        const correctCount = modelPredictions.lgbm.filter(p => p.correct).length;
        modelAccuracies.lgbm = (correctCount / modelPredictions.lgbm.length) * 100;
    }
    
    updateModelPerformanceUI();
}

function updateModelPerformanceUI() {
    const heuristicEl = document.getElementById('heuristicPerf');
    const bayesianEl = document.getElementById('bayesianPerf');
    const markovEl = document.getElementById('markovPerf');
    
    if (modelAccuracies.heuristic > 0) {
        heuristicEl.innerHTML = `<span style="opacity:0.6">Heuristic</span><b style="color:#22c55e">${modelAccuracies.heuristic.toFixed(0)}%</b>`;
        heuristicEl.className = modelAccuracies.heuristic >= 55 ? 'model-perf-high' : (modelAccuracies.heuristic < 45 ? 'model-perf-low' : '');
    }
    
    if (modelAccuracies.bayesian > 0) {
        bayesianEl.innerHTML = `<span style="opacity:0.6">Bayesian</span><b style="color:#8b5cf6">${modelAccuracies.bayesian.toFixed(0)}%</b>`;
        bayesianEl.className = modelAccuracies.bayesian >= 55 ? 'model-perf-high' : (modelAccuracies.bayesian < 45 ? 'model-perf-low' : '');
    }
    
    if (modelAccuracies.markov > 0) {
        markovEl.innerHTML = `<span style="opacity:0.6">Markov</span><b style="color:#3b82f6">${modelAccuracies.markov.toFixed(0)}%</b>`;
        markovEl.className = modelAccuracies.markov >= 55 ? 'model-perf-high' : (modelAccuracies.markov < 45 ? 'model-perf-low' : '');
    }
}

// ============ DIGIT ANALYZER ============
function addDigitToAnalyzer(digit) {
  digit = smoothOutliers(digit, digitHistory);
  
  digitHistory.unshift(digit);
  if (digitHistory.length > 50) digitHistory.pop();
  
  extendedHistory.unshift(digit);
  if (extendedHistory.length > 5000) extendedHistory.pop();
  
  if (extendedHistory.length % 100 === 0) {
    localStorage.setItem('extended_history_v13', JSON.stringify(extendedHistory));
  }
  
  const isOver5 = digit > 5;
  updateBayesianModel(isOver5);
  updateMarkovModel(digit);
  
  updateHistogram(digit);
  
  if (digitHistory.length > 1) {
    updateModelAccuracies(digit);
  }
  
  volatilityWindow.unshift(digit);
  if (volatilityWindow.length > 100) volatilityWindow.pop();
  
  if (digitHistory.length % 10 === 0) {
    detectMarketRegime();
  }
  
  updateAnalyzerDisplay();
  if (isAutoRunning && !isCycleCooldown) checkAndAutoTrade();
}

function checkAndAutoTrade() {
    if (currentContractId !== null) return;
    
    if (isHistogramFilterEnabled && histogramBias === 'favorable_under' && !isReverseTradeActive) {
        return;
    }
    
    if (marketRegime === 'random' && digitHistory.length > 50) {
        const randomRoll = Math.random();
        if (randomRoll > 0.3) {
            return;
        }
    }
    
    // Mode 5: Prediction % + Gap Count
    if (currentConfidenceMode === 'predictionGap') {
        const now = Date.now();
        const cooldownMs = parseInt(document.getElementById('cooldown').value) * 1000;
        if (now - lastTradeTime < Math.max(cooldownMs, 1000)) return;
        
        const currentConf = Math.round(lastPredictionConfidence);
        const gap = currentGapCount;
        
        // Check all 6 slots
        for (let i = 1; i <= 6; i++) {
            const predMin = parseInt(document.getElementById(`pg_s${i}_pred_min`).value);
            const predMax = parseInt(document.getElementById(`pg_s${i}_pred_max`).value);
            const targetGap = parseInt(document.getElementById(`pg_s${i}_gap`).value);
            
            // Both conditions must match
            const predInRange = (currentConf >= predMin && currentConf <= predMax);
            const gapMatches = (gap === targetGap);
            
            if (predInRange && gapMatches) {
                addLog(`Mode 5 Match! Slot ${i}: Pred=${currentConf}% (${predMin}-${predMax}%) + Gap=${gap} (=${targetGap})`, "success");
                lastTradeTime = now;
                placeTrade();
                return;
            }
        }
        return;
    }
    
    if (currentConfidenceMode === 'pattern') {
        const now = Date.now();
        const cooldownMs = parseInt(document.getElementById('cooldown').value) * 1000;
        if (now - lastTradeTime < Math.max(cooldownMs, 1000)) return;
        
        if (detectedPattern && detectedPattern.nextDigit !== null && detectedPattern.nextDigit !== undefined) {
            const targetDigits = [
                parseInt(document.getElementById('pattern1').value),
                parseInt(document.getElementById('pattern2').value),
                parseInt(document.getElementById('pattern3').value),
                parseInt(document.getElementById('pattern4').value),
                parseInt(document.getElementById('pattern5').value)
            ];
            
            if (targetDigits.includes(detectedPattern.nextDigit)) {
                const maxNextLikely = parseInt(document.getElementById('patternEnsembleMax').value) || 0;
                const minNextLikely = parseInt(document.getElementById('patternEnsembleMin').value) || 0;
                const currentNextLikely = Math.round(detectedPattern.confidence);
                
                let activeFilters = 0;
                if (maxNextLikely > 0) activeFilters++;
                if (minNextLikely > 0) activeFilters++;
                if (isSpecificEnsembleActive) activeFilters++;
                
                if (activeFilters > 1) {
                    addLog(`Pattern Match! But CONFLICT: Multiple filters active (${activeFilters}). Only ONE allowed!`, "error");
                    return;
                }
                
                if (activeFilters === 0) {
                    addLog(`Pattern Match! Next Likely: ${detectedPattern.nextDigit} (${currentNextLikely}%) | All Filters: DISABLED - Trading NOW!`, "success");
                    lastTradeTime = now;
                    placeTrade();
                    return;
                }
                
                if (maxNextLikely > 0) {
                    if (currentNextLikely <= maxNextLikely) {
                        addLog(`Pattern Match! Next Likely: ${detectedPattern.nextDigit} (${currentNextLikely}%) ‚â§ ${maxNextLikely}% ‚úì - Trading NOW!`, "success");
                        lastTradeTime = now;
                        placeTrade();
                    } else {
                        addLog(`Pattern Match! Next Likely: ${detectedPattern.nextDigit} (${currentNextLikely}%) > ${maxNextLikely}% ‚úó - SKIPPED (too high)`, "warn");
                    }
                    return;
                }
                
                if (minNextLikely > 0) {
                    if (currentNextLikely >= minNextLikely) {
                        addLog(`Pattern Match! Next Likely: ${detectedPattern.nextDigit} (${currentNextLikely}%) ‚â• ${minNextLikely}% ‚úì - Trading NOW!`, "success");
                        lastTradeTime = now;
                        placeTrade();
                    } else {
                        addLog(`Pattern Match! Next Likely: ${detectedPattern.nextDigit} (${currentNextLikely}%) < ${minNextLikely}% ‚úó - SKIPPED (too low)`, "warn");
                    }
                    return;
                }
                
                if (isSpecificEnsembleActive) {
                    const specificTargets = [
                        parseInt(document.getElementById('specEns1').value),
                        parseInt(document.getElementById('specEns2').value),
                        parseInt(document.getElementById('specEns3').value),
                        parseInt(document.getElementById('specEns4').value),
                        parseInt(document.getElementById('specEns5').value)
                    ].filter(v => !isNaN(v) && v >= 0 && v <= 100);
                    
                    if (specificTargets.includes(currentNextLikely)) {
                        addLog(`Pattern Match! Next Likely: ${detectedPattern.nextDigit} (${currentNextLikely}%) = Target ‚úì - Trading NOW!`, "success");
                        lastTradeTime = now;
                        placeTrade();
                    } else {
                        addLog(`Pattern Match! Next Likely: ${detectedPattern.nextDigit} (${currentNextLikely}%) ‚â† Targets [${specificTargets.join(',')}] ‚úó - SKIPPED`, "warn");
                    }
                    return;
                }
            }
        }
        return;
    }

    const now = Date.now();
    const cooldownMs = parseInt(document.getElementById('cooldown').value) * 1000;
    if (now - lastTradeTime < Math.max(cooldownMs, 1000)) return;

    const mode = currentConfidenceMode;
    let isConfidenceMet = false;
    const currentConf = Math.round(lastPredictionConfidence);
    const prevConf = Math.round(previousPredictionConfidence);

    if (mode === 'range') {
        let minConf = parseFloat(document.getElementById('minConfidence').value);
        let maxConf = parseFloat(document.getElementById('maxConfidence').value);
        
        const adjustment = calculateAdaptiveThreshold();
        minConf += adjustment;
        
        if (currentConf >= minConf && currentConf <= maxConf) isConfidenceMet = true;
    } 
    else if (mode === 'specific') {
        const targets = [
            parseInt(document.getElementById('spec1').value),
            parseInt(document.getElementById('spec2').value),
            parseInt(document.getElementById('spec3').value),
            parseInt(document.getElementById('spec4').value),
            parseInt(document.getElementById('spec5').value)
        ];
        if (targets.includes(currentConf)) isConfidenceMet = true;
    }
    else if (mode === 'sequence') {
        const s1_p1 = parseInt(document.getElementById('s1_p1_min').value);
        const s1_p2_min = parseInt(document.getElementById('s1_p2_min').value);
        const s1_p2_max = parseInt(document.getElementById('s1_p2_max').value);
        
        const s2_p1 = parseInt(document.getElementById('s2_p1_min').value);
        const s2_p2_min = parseInt(document.getElementById('s2_p2_min').value);
        const s2_p2_max = parseInt(document.getElementById('s2_p2_max').value);

        const s3_p1 = parseInt(document.getElementById('s3_p1_min').value);
        const s3_p2_min = parseInt(document.getElementById('s3_p2_min').value);
        const s3_p2_max = parseInt(document.getElementById('s3_p2_max').value);

        const match1 = (prevConf >= s1_p1 && currentConf >= s1_p2_min && currentConf <= s1_p2_max);
        const match2 = (prevConf >= s2_p1 && currentConf >= s2_p2_min && currentConf <= s2_p2_max);
        const match3 = (prevConf >= s3_p1 && currentConf >= s3_p2_min && currentConf <= s3_p2_max);

        if (match1 || match2 || match3) isConfidenceMet = true;
    }

    if (lastPredictionType === 'OVER 5' && isConfidenceMet) {
        lastTradeTime = now;
        placeTrade();
    }
}

function updateAnalyzerDisplay() {
  const container = document.getElementById('digitDisplay');
  container.innerHTML = '';
  digitHistory.forEach(digit => {
    const box = document.createElement('div');
    box.className = 'digit-box ' + (digit > 5 ? 'digit-over' : 'digit-under');
    box.textContent = digit;
    container.appendChild(box);
  });
  
  const overCount = digitHistory.filter(d => d > 5).length;
  document.getElementById('overCount').textContent = overCount;
  document.getElementById('totalCount').textContent = digitHistory.length;
  document.getElementById('overPercent').textContent = (digitHistory.length > 0 ? ((overCount / digitHistory.length) * 100).toFixed(1) : 0) + '%';
  
  predictNextDigit();
}

function predictNextDigit() {
  if (digitHistory.length < 20) {
    document.getElementById('patternMatch').textContent = 'Collecting data... need 20+ ticks';
    detectedPattern = null;
    return;
  }
  
  previousPredictionConfidence = lastPredictionConfidence;

  const last20 = digitHistory.slice(0, 20);
  let weightedUnderScore = 0;
  last20.forEach((digit, index) => {
      const weight = (20 - index) / 20; 
      if (digit <= 5) weightedUnderScore += weight;
  });
  const weightedFreq = (weightedUnderScore / 10.5) * 100;
  
  let overGap = 0;
  for (let d of digitHistory) {
      if (d <= 5) overGap++;
      else break;
  }
  currentGapCount = overGap; // Store for Mode 5
  
  const volatility = calculateVolatility(volatilityWindow, 50);
  let volatilityLabel = 'Low';
  let volatilityPenalty = 0;
  
  if (volatility > 3.0) {
      volatilityLabel = 'Extreme';
      volatilityPenalty = -20;
  } else if (volatility > 2.5) {
      volatilityLabel = 'High';
      volatilityPenalty = -15;
  } else if (volatility > 1.8) {
      volatilityLabel = 'Medium';
      volatilityPenalty = -5;
  }
  
  document.getElementById('volatilityScore').textContent = volatilityLabel;
  
  let gravityBonus = 0;
  if (digitHistory.length >= 3) {
      if (digitHistory[0] > digitHistory[1] && digitHistory[1] > digitHistory[2]) {
          gravityBonus = 15;
      } else if (digitHistory[0] < digitHistory[1] && digitHistory[1] < digitHistory[2]) {
          gravityBonus = -10;
      }
  }
  
  const bayesianProb = updateBayesianModel(digitHistory[0] > 5);
  document.getElementById('bayesianProb').textContent = bayesianProb.toFixed(0) + '%';
  
  const markovProb = calculateMarkovPrediction();
  document.getElementById('markovProb').textContent = markovProb.toFixed(0) + '%';
  
  const lgbmProb = calculateLightGBMPrediction();
  document.getElementById('lgbmScore').textContent = lgbmProb.toFixed(0) + '%';
  
  let heuristicConf = 0;
  let predText = 'WAIT';
  
  if (overGap >= 3) {
      predText = 'OVER 5';
      heuristicConf = 40 + (overGap * 9) + (weightedFreq * 0.1) + gravityBonus + volatilityPenalty;
  } else if (weightedFreq > 70) {
      predText = 'OVER 5';
      heuristicConf = 45 + (weightedFreq - 70) + gravityBonus + volatilityPenalty;
  }
  
  modelPredictions.heuristic.push({ prediction: predText });
  modelPredictions.bayesian.push({ prediction: bayesianProb });
  modelPredictions.markov.push({ prediction: markovProb });
  modelPredictions.lgbm.push({ prediction: lgbmProb });
  
  const ensembleScore = calculateEnsemblePrediction(
      Math.max(0, heuristicConf), 
      bayesianProb, 
      markovProb,
      lgbmProb,
      volatility
  );
  
  document.getElementById('ensembleScore').textContent = ensembleScore.toFixed(0) + '%';
  
  const rawConfidence = Math.min(98, Math.max(0, ensembleScore));
  const calibratedConfidence = calibrateConfidence(rawConfidence);
  
  lastPredictionConfidence = calibratedConfidence;
  lastPredictionType = predText;
  
  updateCalibrationDisplay(calibratedConfidence);
  
  document.getElementById('nextDigitPrediction').textContent = predText;
  document.getElementById('nextDigitPrediction').style.color = predText === 'OVER 5' ? '#22c55e' : '#f59e0b';
  document.getElementById('predictionConfidence').textContent = `${lastPredictionConfidence.toFixed(0)}% (Calibrated)`;
  document.getElementById('freqScore').textContent = weightedFreq.toFixed(0) + '%';
  document.getElementById('cycleScore').textContent = overGap;
  
  const pattern = detectMultiScalePatterns();
  detectedPattern = pattern;
  
  if (pattern) {
      const sampleSize = pattern.distance;
      const confidence = pattern.confidence;
      
      let color = '#94a3b8';
      let strength = "Weak";

      if (confidence >= 60 || confidence <= 40) {
          color = '#f59e0b';
          strength = "Mod";
      }
          
       if (confidence >= 70 || confidence <= 30) {
          color = '#22c55e';
          strength = "Strong";
      }

      const fuzzyIndicator = pattern.fuzzy ? ' [Fuzzy]' : '';
      document.getElementById('patternMatch').innerHTML = 
          `<span style="color:#3b82f6">${pattern.pattern}${fuzzyIndicator}:</span> Samples: <b>${sampleSize.toFixed(1)}</b> | Over 5: <b style="color:${color}">${confidence.toFixed(1)}%</b> [${strength}] | Next: <b style="color:#8b5cf6">${pattern.nextDigit}</b>`;
  } else {
      document.getElementById('patternMatch').textContent = `No quality pattern detected (${extendedHistory.length} ticks analyzed)`;
  }
}

// ============ TRADING FUNCTIONS ============
function placeTrade() {
  if (!isConnected || isCycleCooldown) return;
  
  const stakeValue = parseFloat(document.getElementById('stake').value);
  const tickValue = parseInt(document.getElementById('duration').value);
  const marketValue = currentMarketValue;
  const type = isReverseTradeActive ? 'DIGITUNDER' : 'DIGITOVER';
  
  if (isCurrentlyVirtualMode()) {
      addLog(`üéÆ VIRTUAL TRADE SIMULATED (Not placing real trade)`, "warn");
      
      setTimeout(() => {
          const simulatedWin = Math.random() > 0.5;
          const simulatedProfit = simulatedWin ? stakeValue * 0.95 : -stakeValue;
          
          handleVirtualTradeResult(simulatedWin);
          
          stats.trades++;
          if (simulatedWin) stats.wins++; else stats.losses++;
          stats.profit += simulatedProfit;
          
          recentWinRates.push(simulatedWin ? 1 : 0);
          if (recentWinRates.length > 20) recentWinRates.shift();
          
          const usedFeatures = {
              frequency: true,
              gap: true,
              bayesian: true,
              markov: true,
              pattern: detectedPattern !== null
          };
          updateFeatureImportance(usedFeatures, simulatedWin);
          
          addCalibrationData(lastPredictionConfidence, simulatedWin ? 1 : 0);
          
          updateStats();
          addToHistory(stats.trades, simulatedWin ? 'Win (Virtual)' : 'Loss (Virtual)', simulatedProfit, marketValue);
          
          addLog(`üéÆ VIRTUAL ${simulatedWin ? 'WIN' : 'LOSS'} | P/L: ${simulatedProfit.toFixed(2)}`, simulatedWin ? 'success' : 'error');
          
          localStorage.setItem('trade_stats_v13', JSON.stringify(stats));
          localStorage.setItem('trade_history_v13', document.getElementById('history').innerHTML);
          localStorage.setItem('calibration_data_v13', JSON.stringify(calibrationData));
          
          checkRiskManagement();
      }, 2000);
      
      return;
  }
  
  let confidenceMsg = '';
  if (currentConfidenceMode === 'pattern' && detectedPattern) {
      const maxNextLikely = parseInt(document.getElementById('patternEnsembleMax').value) || 0;
      const minNextLikely = parseInt(document.getElementById('patternEnsembleMin').value) || 0;
      const nextLikelyPercent = Math.round(detectedPattern.confidence);
      
      if (maxNextLikely === 0 && minNextLikely === 0 && !isSpecificEnsembleActive) {
          confidenceMsg = `Pattern: [${detectedPattern.pattern}] ‚Üí ${detectedPattern.nextDigit} (${nextLikelyPercent}%) | Filters: OFF`;
      } else if (maxNextLikely > 0) {
          confidenceMsg = `Pattern: [${detectedPattern.pattern}] ‚Üí ${detectedPattern.nextDigit} | Next Likely: ${nextLikelyPercent}% ‚â§ ${maxNextLikely}%`;
      } else if (minNextLikely > 0) {
          confidenceMsg = `Pattern: [${detectedPattern.pattern}] ‚Üí ${detectedPattern.nextDigit} | Next Likely: ${nextLikelyPercent}% ‚â• ${minNextLikely}%`;
      } else if (isSpecificEnsembleActive) {
          confidenceMsg = `Pattern: [${detectedPattern.pattern}] ‚Üí ${detectedPattern.nextDigit} | Next Likely: ${nextLikelyPercent}% = Target`;
      }
  } else if (currentConfidenceMode === 'predictionGap') {
      confidenceMsg = `Prediction: ${lastPredictionConfidence.toFixed(0)}% | Gap: ${currentGapCount}`;
  } else {
      confidenceMsg = `${lastPredictionConfidence.toFixed(0)}% confidence`;
  }
  
  addLog(`üî¥ LIVE: Executing ${type} trade with ${confidenceMsg}`, "info");
  
  sendAPIRequest({
    buy: 1, 
    price: stakeValue,
    parameters: { 
        contract_type: type, 
        symbol: marketValue, 
        duration: tickValue, 
        duration_unit: 't', 
        barrier: '5', 
        amount: stakeValue,
        basis: 'stake', 
        currency: 'USD' 
    }
  });
}

function toggleAuto() {
  if (!isConnected) return;
  isAutoRunning = !isAutoRunning;
  const btn = document.getElementById('autoBtn');

  if (isAutoRunning) {
    addLog("ML Auto-Trade v3.3 Enabled.", "success");
    btn.textContent = 'Stop Auto'; btn.style.background = '#ef4444';
  } else {
    addLog("Auto-Trade Stopped.", "warn");
    btn.textContent = 'Start Auto'; btn.style.background = '#22c55e';
  }
}

function toggleMarketCycle() {
    isMarketCycleActive = !isMarketCycleActive;
    const btn = document.getElementById('cycleBtn');
    if (isMarketCycleActive) {
        btn.classList.add('active');
        currentMarketIndex = marketSequence.indexOf(currentMarketValue);
        if(currentMarketIndex === -1) currentMarketIndex = 0;
        btn.textContent = `Auto Market Cycle: ON (${marketSequence[currentMarketIndex]})`;
        addLog(`Market Cycle Sequence Started at ${marketSequence[currentMarketIndex]}.`, "info");
    } else {
        btn.classList.remove('active');
        btn.textContent = "Auto Market Cycle: OFF";
        addLog(`Market Cycle Sequence Disabled.`, "warn");
    }
}

function toggleCooldownLoop() {
    isCooldownLoopActive = !isCooldownLoopActive;
    const btn = document.getElementById('cooldownBtn');
    if (isCooldownLoopActive) {
        btn.classList.add('active');
        btn.textContent = "Cycle Cooldown Loop: ON";
        addLog(`Cycle Cooldown Loop Enabled: Will wait after full sequence.`, "info");
    } else {
        btn.classList.remove('active');
        btn.textContent = "Cycle Cooldown Loop: OFF";
        addLog(`Cycle Cooldown Loop Disabled.`, "warn");
    }
}

function startCycleCooldown() {
    isCycleCooldown = true;
    let waitMinutes = parseInt(document.getElementById('cycleWaitTime').value);
    let secondsLeft = waitMinutes * 60;
    const timerDisplay = document.getElementById('cycleTimerDisplay');
    timerDisplay.style.display = 'block';
    addLog(`Sequence Complete. Cycle Cooldown Loop active: waiting ${waitMinutes}m...`, "warn");

    if (cycleTimerId) clearInterval(cycleTimerId);
    cycleTimerId = setInterval(() => {
        secondsLeft--;
        const mins = Math.floor(secondsLeft / 60);
        const secs = secondsLeft % 60;
        timerDisplay.textContent = `Next Loop in: ${mins.toString().padStart(2,'0')}:${secs.toString().padStart(2,'0')}`;

        if (secondsLeft <= 0) {
            clearInterval(cycleTimerId);
            isCycleCooldown = false;
            timerDisplay.style.display = 'none';
            currentMarketIndex = 0;
            const nextMarket = marketSequence[currentMarketIndex];
            currentMarketValue = nextMarket;
            selectMarket(nextMarket);
            document.getElementById('cycleBtn').textContent = `Auto Market Cycle: ON (${nextMarket})`;
            addLog(`Cooldown finished. Restarting Cycle at ${nextMarket}.`, "success");
            subscribeToTicks();
        }
    }, 1000);
}

function handleTradeResult(contract) {
  const isWin = contract.status === 'won';
  const profitLoss = parseFloat(contract.profit || 0);
  
  const tradeMode = isCurrentlyVirtualMode() ? "VIRTUAL" : "LIVE";
  addLog(`${tradeMode} RESULT: ${isWin ? 'WIN' : 'LOSS'} | P/L: ${profitLoss.toFixed(2)}`, isWin ? 'success' : 'error');
  
  handleVirtualTradeResult(isWin);
  
  stats.trades++; 
  if (isWin) stats.wins++; else stats.losses++; 
  stats.profit += profitLoss;
  
  recentWinRates.push(isWin ? 1 : 0);
  if (recentWinRates.length > 20) recentWinRates.shift();
  
  const usedFeatures = {
      frequency: true,
      gap: true,
      bayesian: true,
      markov: true,
      pattern: detectedPattern !== null
  };
  updateFeatureImportance(usedFeatures, isWin);
  
  addCalibrationData(lastPredictionConfidence, isWin ? 1 : 0);
  
  updateStats();
  
  const historyLabel = isCurrentlyVirtualMode() ? `${isWin ? 'Win' : 'Loss'} (Virtual)` : (isWin ? 'Win' : 'Loss');
  addToHistory(stats.trades, historyLabel, profitLoss, contract.display_name || 'Market');
  localStorage.setItem('trade_stats_v13', JSON.stringify(stats));
  localStorage.setItem('trade_history_v13', document.getElementById('history').innerHTML);
  localStorage.setItem('calibration_data_v13', JSON.stringify(calibrationData));

  const tp = parseFloat(document.getElementById('takeprofit').value);
  if (isMarketCycleActive && stats.profit >= tp) {
      if (currentMarketIndex < marketSequence.length - 1) {
          currentMarketIndex++;
          const nextMarket = marketSequence[currentMarketIndex];
          addLog(`Target reached! Switching Market: ${marketSequence[currentMarketIndex-1]} -> ${nextMarket}...`, "success");
          resetStats(); 
          currentMarketValue = nextMarket;
          selectMarket(nextMarket);
          document.getElementById('cycleBtn').textContent = `Auto Market Cycle: ON (${nextMarket})`;
          subscribeToTicks();
          return; 
      } else {
          addLog("Final Market Sequence Finished Successfully.", "success");
          resetStats();
          if (isCooldownLoopActive) {
              startCycleCooldown();
          } else {
              if (isAutoRunning) toggleAuto();
              isMarketCycleActive = false;
              document.getElementById('cycleBtn').classList.remove('active');
              document.getElementById('cycleBtn').textContent = "Auto Market Cycle: OFF";
          }
      }
  }
  checkRiskManagement();
}

function toggleReverseTrade() {
    isReverseTradeActive = !isReverseTradeActive;
    const btn = document.getElementById('reverseBtn');
    if (isReverseTradeActive) {
        btn.classList.add('active');
        btn.textContent = "Reverse Trade: ON (Digit Under 5)";
        addLog("Reverse Mode Activated: Now trading Digit Under 5", "warn");
    } else {
        btn.classList.remove('active');
        btn.textContent = "Reverse Trade: OFF";
        addLog("Normal Mode Activated: Now trading Digit Over 5", "info");
    }
}

// ============ API COMMUNICATION ============
function sendAPIRequest(data) { 
    if (ws && ws.readyState === WebSocket.OPEN) { 
        const now = Date.now();
        if (now - lastRequestTime < 300) {
            setTimeout(() => sendAPIRequest(data), 300);
            return false;
        }
        lastRequestTime = now;
        ws.send(JSON.stringify(data)); 
        return true; 
    } 
    return false; 
}

function subscribeToTicks() {
  const market = currentMarketValue;
  sendAPIRequest({ forget_all: "ticks" });
  digitHistory = [];
  digitHistogram = Array(10).fill(0);
  document.getElementById('digitDisplay').innerHTML = '';
  addLog(`Watching ${market}...`, "info");
  sendAPIRequest({ ticks: market, subscribe: 1 });
}

// ============ UI UPDATE FUNCTIONS ============
function updateStatus(text, className) { 
    const s = document.getElementById('status'); 
    s.textContent = text; 
    s.className = 'status ' + className; 
}

function updateBalance() { 
    document.getElementById('balanceDisplay').style.display = 'block'; 
    document.getElementById('balance').textContent = parseFloat(accountBalance).toFixed(2); 
}

function updateStats() {
  document.getElementById('trades').textContent = stats.trades;
  document.getElementById('wins').textContent = stats.wins;
  document.getElementById('losses').textContent = stats.losses;
  const p = document.getElementById('profit');
  p.textContent = stats.profit.toFixed(2);
  p.style.color = stats.profit > 0 ? '#22c55e' : (stats.profit < 0 ? '#ef4444' : '#e5e7eb');
}

function startSessionTimer() {
    if (timerIntervalId) clearInterval(timerIntervalId);
    sessionStartTime = Date.now(); 
    timerIntervalId = setInterval(() => {
        const now = Date.now();
        const s = Math.floor((now - sessionStartTime) / 1000);
        document.getElementById('sessionTimer').textContent = `Session: ${Math.floor(s/3600).toString().padStart(2,'0')}:${Math.floor((s%3600)/60).toString().padStart(2,'0')}:${(s%60).toString().padStart(2,'0')}`;
    }, 1000);
}

function checkRiskManagement() {
  const sl = parseFloat(document.getElementById('stoploss').value);
  const tp = parseFloat(document.getElementById('takeprofit').value);
  
  if (stats.profit <= -sl) { 
    if (isAutoRunning) toggleAuto(); 
    addLog("Stop Loss Met. Trading stopped.", "error"); 
  }
  
  if (!isMarketCycleActive && stats.profit >= tp) {
    if (isAutoRunning) toggleAuto();
    addLog("Take Profit achieved! Trading stopped.", "success");
  }
}

function addToHistory(n, res, pl, m) {
  const row = document.getElementById('history').insertRow(0);
  const cls = res.includes('Win') ? 'win' : 'loss';
  row.innerHTML = `<td>${n}</td><td class="${cls}">${res}</td><td class="${cls}">${pl.toFixed(2)}</td><td>${m}</td>`;
}

function resetStats() { 
    stats = { trades: 0, wins: 0, losses: 0, profit: 0 }; 
    recentWinRates = [];
    
    virtualLossStreak = 0;
    hasSwatchedToLive = false;
    updateVirtualTradeUI();
    
    modelAccuracies = {
        heuristic: 0,
        bayesian: 0,
        markov: 0,
        lgbm: 0
    };
    modelPredictions = {
        heuristic: [],
        bayesian: [],
        markov: [],
        lgbm: []
    };
    
    featureImportance = {
        frequency: 0,
        gap: 0,
        bayesian: 0,
        markov: 0,
        pattern: 0
    };
    featureWinCounts = {
        frequency: 0,
        gap: 0,
        bayesian: 0,
        markov: 0,
        pattern: 0
    };
    featureTotalCounts = {
        frequency: 0,
        gap: 0,
        bayesian: 0,
        markov: 0,
        pattern: 0
    };
    
    calibrationData = [];
    
    updateStats(); 
    updateModelPerformanceUI();
    updateFeatureImportanceDisplay();
    document.getElementById('history').innerHTML = ''; 
    localStorage.removeItem('trade_stats_v13');
    localStorage.removeItem('trade_history_v13');
    localStorage.removeItem('calibration_data_v13');
    addLog("All stats reset.", "info");
    
    saveSettings();
}

function manualTrade() { 
    if (isConnected) {
        placeTrade(); 
    } else {
        addLog("Not connected. Please login first.", "error");
    }
}

// ============ INITIALIZATION ============
window.onload = () => {
  addLog("Initializing ML Enhanced Trading Bot v3.3...", "info");
  loadSettings();
  
  const ensembleMaxInput = document.getElementById('patternEnsembleMax');
  const ensembleMinInput = document.getElementById('patternEnsembleMin');
  const specEnsInputs = ['specEns1', 'specEns2', 'specEns3', 'specEns4', 'specEns5'];
  
  if (ensembleMaxInput) {
      ensembleMaxInput.addEventListener('input', updateEnsembleFilterStatus);
      ensembleMaxInput.addEventListener('change', updateEnsembleFilterStatus);
  }
  
  if (ensembleMinInput) {
      ensembleMinInput.addEventListener('input', updateEnsembleFilterStatus);
      ensembleMinInput.addEventListener('change', updateEnsembleFilterStatus);
  }
  
  specEnsInputs.forEach(id => {
      const input = document.getElementById(id);
      if (input) {
          input.addEventListener('input', saveSettings);
          input.addEventListener('change', saveSettings);
      }
  });
  
  const virtualThresholdInput = document.getElementById('virtualLossThreshold');
  if (virtualThresholdInput) {
      virtualThresholdInput.addEventListener('input', () => {
          updateVirtualTradeUI();
          saveSettings();
      });
      virtualThresholdInput.addEventListener('change', () => {
          updateVirtualTradeUI();
          saveSettings();
      });
  }
  
  const histogramFilterToggle = document.getElementById('histogramFilterToggle');
  if (histogramFilterToggle) {
      histogramFilterToggle.addEventListener('change', saveSettings);
  }
  
  updateEnsembleFilterStatus();
  
  const savedToken = sessionStorage.getItem('derivToken');
  if (savedToken) { 
      document.getElementById('token').value = savedToken; 
      setTimeout(connect, 1000); 
  }
  
  addLog("‚úÖ ML v3.3 ENHANCEMENTS Applied:", "success");
  addLog("NEW: Mode 5 - Prediction % + Gap Count (6 Slots)", "success");
  addLog("IMPROVED: Pattern detection quality (85% match threshold)", "info");
  addLog("REMOVED: Window closing/opening timing restrictions", "warn");
  addLog("REMOVED: Auto Trade Duration limit", "warn");
  addLog("Priority 1: Histogram filter (TOGGLEABLE)", "info");
  addLog("Priority 1: Better pattern quality scoring", "info");
  addLog("Priority 2: LightGBM-style engineered features", "info");
  addLog("Priority 2: Weighted temporal pattern matching", "info");
  addLog("Priority 2: Multi-scale pattern analysis", "info");
  addLog("Priority 2: Confidence calibration system", "info");
  addLog("Priority 3: HMM regime detection", "info");
  addLog("Priority 3: Stacking meta-learner ensemble", "info");
  addLog("- Extended history: 5000 ticks", "info");
  addLog("- 2nd-order Markov chain enabled", "info");
  addLog("- üéÆ Virtual Trade Mode with auto-switch", "success");
  addLog("Ready to trade with v3.3 enhanced features!", "success");
};

document.getElementById('logoutBtn').addEventListener('click', () => { 
    isExplicitLogout = true; 
    if (ws) ws.close(); 
    sessionStorage.removeItem('derivToken'); 
    addLog("Logging out...", "info");
    setTimeout(() => location.reload(), 500);
});
</script>
</body>
</html>